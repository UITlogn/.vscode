{
    "dp_dnc": {
    "prefix": "#dp_dnc",
    "body": [
        "#include <bits/stdc++.h>                                                                                                                                                                                      //Logm",
        "using namespace std;",
        "#define int long long",
        "#define II pair<int,int>",
        "#define fi first",
        "#define se second",
        "",
        "template<class X, class Y> bool mini(X& x, const Y y) {",
        "    if (x > y) return x = y, 1;",
        "    return 0;",
        "}",
        "const int N = 4005, K = 805;",
        "int n, k;",
        "int a[N][N], pre[N][N];",
        "int dp[N][K];",
        "",
        "int get(int i, int j) {",
        "    return (pre[j][j] - pre[i - 1][j] - pre[j][i - 1] + pre[i - 1][i - 1]) / 2;",
        "}",
        "",
        "void calc(int k, int l, int r, int optl, int optr) {",
        "    if (l > r) return;",
        "",
        "    int mid = l + r >> 1;",
        "",
        "    II best(1e9, -1);",
        "    for (int j = optl; j <= min(mid, optr); ++j)",
        "        mini(best, II(dp[j - 1][k - 1] + get(j, mid), j));",
        "    ",
        "    dp[mid][k] = best.fi;",
        "    int opt = best.se;",
        "    calc(k, l, mid - 1, optl, opt);",
        "    calc(k, mid + 1, r, opt, optr);",
        "}",
        "signed main() {",
        "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
        "    if (fopen(\"_ab.inp\", \"r\")) {",
        "        freopen(\"_ab.inp\", \"r\", stdin);",
        "        freopen(\"_ab.out\", \"w\", stdout);",
        "    }",
        "",
        "    cin >> n >> k;",
        "    for (int i = 1; i <= n; ++i)",
        "        for (int j = 1; j <= n; ++j) {",
        "            cin >> a[i][j];",
        "            pre[i][j] = pre[i][j - 1] + pre[i - 1][j] - pre[i - 1][j - 1] + a[i][j];",
        "        }",
        "    ",
        "    memset(dp, 0x3f, sizeof dp);",
        "    for (int i = 1; i <= n; ++i)",
        "        dp[i][1] = get(1, i);",
        "",
        "    for (int x = 2; x <= k; ++x) {",
        "        // for (int i = 1; i <= n; ++i) {",
        "        //     for (int j = 1; j <= i; ++j) {",
        "        //         mini(dp[i][x], dp[j - 1][x - 1] + get(j, i));",
        "        //     }",
        "        // }",
        "        calc(x, 1, n, 1, n);",
        "    }",
        "    cout << dp[n][k];",
        "    return 0;",
        "}"
    ],
    "description": "dp_dnc"
    },
  "#bignum_binarysearch": {
    "prefix": "#bignum_binarysearch",
    "body": [
      "string add(string x, string y) {",
      "    reverse(x.begin(), x.end());",
      "    reverse(y.begin(), y.end());",
      "",
      "    int tmp = 0;",
      "    while (y.size() < x.size()) y += '0';",
      "    while (x.size() < y.size()) x += '0';",
      "",
      "    string res = \"\";",
      "    for (int i = 0; i < x.size(); ++i) {",
      "        int val = (x[i] - '0' + y[i] - '0') + tmp;",
      "        tmp = val / 10;",
      "        val %= 10;",
      "        res.push_back(char(val + '0'));",
      "    }",
      "",
      "    if (tmp > 0) res += to_string(tmp);",
      "    reverse(res.begin(), res.end());",
      "    return res;",
      "}",
      "",
      "string div2(const string &t) {",
      "    string res = \"\";",
      "    int tmp = 0;",
      "    for (int i = 0; i < t.size(); ++i) {",
      "        int num1 = (t[i] - '0') + tmp * 10;",
      "        int val = num1 / 2;",
      "        res.push_back(char(val + '0'));",
      "        int num2 = val * 2;",
      "        tmp = num1 - num2;",
      "    }",
      "    while (res[0] == '0') res.erase(0, 1);",
      "    return res;",
      "}",
      "bool comp(string l, string r) {",
      "    if (l.size() != r.size()) return l.size() < r.size();",
      "    for (int i = 0; i < l.size(); ++i) {",
      "        if (l[i] != r[i])",
      "            return l[i] < r[i];",
      "    }",
      "    return 1;",
      "}",
      "    string l = \"1\";",
      "    string r = \"1\";",
      "    for (int i = 0; i < 22; ++i) r += \"0\";",
      "",
      "    string num;",
      "    while (comp(l, r)) {",
      "        string mid = div2(add(l, r));",
      "        int x = calc(mid);",
      "        if (calc(mid) >= k) {",
      "            num = mid;",
      "            r = mid;",
      "        } else",
      "            l = add(mid, \"1\");",
      "        if (l == r) break;",
      "    }"
    ],
    "description": "#bignum_binarysearch"
  },
  "#flow_trace": {
    "prefix": "#flow_trace",
    "body": [
      "#include <bits/stdc++.h>                                                                                                                                                 //Logm",
      "using namespace std;",
      "#define int long long",
      "",
      "const int N = 1005;",
      "queue<int> qu[N];",
      "vector<int> ans[N];",
      "",
      "struct DinicFlow {",
      "    vector<int> flow, capa;",
      "    vector<int> point, next, head, work, dist;",
      "    int numNode, numEdge;",
      " ",
      "    DinicFlow(int _n = 0) {",
      "        flow.clear(), capa.clear();",
      "        point.clear(), next.clear();",
      "        numNode = _n, numEdge = 0;",
      " ",
      "        head.assign(_n + 7, -1);",
      "        dist.assign(_n + 7, 0);",
      "        work.assign(_n + 7, 0);",
      "    }",
      " ",
      "    void addEdge(int u, int v, int c1, int c2 = 0) {",
      "        flow.push_back(0), capa.push_back(c1);",
      "        point.push_back(v), next.push_back(head[u]), head[u] = numEdge++;",
      " ",
      "        flow.push_back(0), capa.push_back(c2);",
      "        point.push_back(u), next.push_back(head[v]), head[v] = numEdge++;",
      "    }",
      " ",
      "    bool bfs(int s, int t) {",
      "        queue<int> qu;",
      "        for (int i = 1; i <= numNode; ++i)",
      "            dist[i] = -1;",
      " ",
      "        dist[s] = 0;",
      "        qu.push(s);",
      " ",
      "        while(!qu.empty()) {",
      "            int u(qu.front());",
      "            qu.pop();",
      " ",
      "            for (int i = head[u]; i >= 0; i = next[i])",
      "                if(flow[i] < capa[i] && dist[point[i]] < 0) {",
      "                    dist[point[i]] = dist[u] + 1;",
      "                    qu.push(point[i]);",
      "                }",
      "        }",
      " ",
      "        return (dist[t] >= 0);",
      "    }",
      " ",
      "    int dfs(int s, int t, int Flow) {",
      "        if (s == t) return Flow;",
      " ",
      "        for (int &i = work[s]; i >= 0; i = next[i])",
      "            if(flow[i] < capa[i] && dist[point[i]] == dist[s] + 1) {",
      "                int fl = dfs(point[i], t, min(Flow, capa[i] - flow[i]));",
      "                if(fl > 0) {",
      "                    flow[i] += fl;",
      "                    flow[i ^ 1] -= fl;",
      "                    return fl;",
      "                }",
      "            }",
      " ",
      "        return 0;",
      "    }",
      " ",
      "    int maxFlow(int s, int t) {",
      "        for (int i = 0; i < flow.size(); ++i)",
      "            flow[i] = 0;",
      " ",
      "        int totFlow(0);",
      "        while (bfs(s, t)) {",
      "            for (int i = 1; i <= numNode; ++i)",
      "                work[i] = head[i];",
      " ",
      "            while (1) {",
      "                int d = dfs(s, t, 1e9+7);",
      "                totFlow += d;",
      "                if (!d) break;",
      "            }",
      "        }",
      " ",
      "        return totFlow;",
      "    }",
      "};",
      "",
      "signed main() {",
      "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
      "    #ifndef ONLINE_JUDGE",
      "    freopen(\"_ab.inp\", \"r\", stdin);",
      "    freopen(\"_ab.out\", \"w\", stdout);",
      "    #endif",
      "",
      "    int n, m; cin >> n >> m;",
      " ",
      "    DinicFlow flow(n);",
      "    while (m--) {",
      "        int u, v; cin >> u >> v;",
      "        flow.addEdge(u, v, 1);",
      "    }",
      " ",
      "    int res = flow.maxFlow(1, n);",
      "    for (int i = 0; i < flow.flow.size(); ++i) {",
      "        if (flow.flow[i] > 0) {",
      "            int u = flow.point[i ^ 1], v = flow.point[i];",
      "            qu[v].push(u);",
      "        }",
      "    }",
      " ",
      "    cout << res << '\\n';",
      "    while (qu[n].size()) {",
      "        stack<int> st;",
      "        int z = n;",
      "        while (z > 1) {",
      "            st.push(z);",
      "            int tmp = z;",
      "            z = qu[z].front();",
      "            qu[tmp].pop();",
      "        }",
      " ",
      "        cout << st.size() + 1 << \"\\n1 \";",
      "        while (!st.empty()) {",
      "            cout << st.top() << ' ';",
      "            st.pop();",
      "        }",
      "        cout << '\\n';",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "#flow_trace"
  },
  "inputedgelist": {
    "prefix": "#edgeinput(cost)",
    "body": [
      "for (int i = 0; i < m; ++i) {",
      "    int u, v, c; cin >> u >> v >> c;",
      "    adj[u].push_back(II(v, c));",
      "    adj[v].push_back(II(u, c));",
      "}"
    ],
    "description": "inputedgelist"
  },
  "inputedgelistnocost": {
    "prefix": "#edgeinput",
    "body": [
      "for (int i = 0; i < m; ++i) {",
      "    int u, v; cin >> u >> v;",
      "    adj[u].push_back(v);",
      "    adj[v].push_back(u);",
      "}"
    ],
    "description": "inputedgelistnocost"
  },
  "cppmain": {
    "prefix": "#logm",
    "body": [
      "#include <bits/stdc++.h>                                                                                                                                                                                      //Logm",
      "using namespace std;",
      "#define int long long",
      "",
      "signed main() {",
      "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
      "    if (fopen(\"_ab$1.inp\", \"r\")) {",
      "        freopen(\"_ab$1.inp\", \"r\", stdin);",
      "        freopen(\"_ab$1.out\", \"w\", stdout);",
      "    }",
      "",
      "    return 0;",
      "}"
    ],
    "description": "cppmain"
  },
  "mt19937": {
    "prefix": "#rand",
    "body": [
      "mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());"
    ],
    "description": "mt19937"
  },
  "#dxy4": {
    "prefix": "#dxy4",
    "body": [
      "int dx[] = {0, 1, 0, -1};",
      "int dy[] = {1, 0, -1, 0};",
      ""
    ],
    "description": "#dxy4"
  },
  "#dxy8": {
    "prefix": "#dxy8",
    "body": [
      "int dx[] = {-2, -2, -1, 1, 2, 2, 1, -1};",
      "int dy[] = {-1, 1, 2, 2, 1, -1, -2, -2};"
    ],
    "description": "#dxy8"
  },
  "#pragma": {
    "prefix": "#pragmafull",
    "body": [
      "#pragma GCC optimize(\"inline,fast-math,unroll-loops,O3,Ofast,unroll-loops,tree-vectorize,inline,fast-math,unroll-loops,no-stack-protector\")",
      "#pragma GCC target(\"f16c,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native,bmi,bmi2,lzcnt\")",
      "#pragma loop_opt(on)",
      "#pragma comment(linker, \"/stack:200000000\")"
    ],
    "description": "#pragma"
  },
  "#pragmacodeforces": {
    "prefix": "#pragmafull2",
    "body": [
      "#pragma GCC optimize(\"O3,unroll-loops\")",
      "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
    ],
    "description": "#pragmacodeforces"
  },
  "#sinhtest": {
    "prefix": "#sinhtest",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <windows.h>",
      "using namespace std;",
      "#define int long long",
      "#define ld long double",
      "#define II pair<int,int>",
      "#define fi first",
      "#define se second",
      "",
      "mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());",
      "long long Rand(long long l, long long h) { ",
      "    // sinh số ngẫu nhiên trong -1e18 <= l <= Rand(l,r) <= r <= 1e18",
      "    if (l >= h) return l;",
      "    long long range = (h - l + 1);",
      "    long long ans = rd()%10;",
      "    while (ans < 1e18) {",
      "        ans = ans*10 + rd()%10;",
      "        if (ans < 0) ans = -ans;",
      "    }",
      "    return l + ans % range;",
      "}",
      "bool bit01() { // tra ve 0 hoac 1",
      "    return Rand(1, 1e5)%2;",
      "}",
      "char az() { // tra ve ki tu ngau nhien tong ['a' .. 'z']",
      "    return (char)(Rand('a', 'z'));",
      "}",
      "char AZ() { // tra ve ki tu ngau nhien tong ['A' .. 'Z']",
      "    return (char)(Rand('A', 'Z'));",
      "}",
      "char num() { // tra ve ['0' .. '9']",
      "    return '0' + Rand(0, 9);",
      "}",
      "bool isPrime(int x) {",
      "    if (x == 2 || x == 3) return 1;",
      "    if (x<2 || x%2 == 0 || x%3 == 0) return 0;",
      "    for (int i = 5; i*i <= x; i += 6)",
      "        if (x%i == 0 || x%(i+2) == 0)",
      "            return 0;",
      "    return 1;",
      "}",
      "signed main() {",
      "    string NAME = \"SIMPLE\";",
      "    string NAME2 = NAME;",
      "",
      "    HANDLE cons;",
      "    cons = GetStdHandle(STD_OUTPUT_HANDLE);",
      "    SetConsoleTextAttribute(cons, 15);",
      "    cout << \"Creating \" << NAME << \".exe\" << endl;",
      "    system((\"g++ -g \" + NAME + \".cpp -o \" + NAME + \".exe\").c_str());",
      "    cout << \"Creating \" << NAME << \"_.exe\" << endl;",
      "    system((\"g++ -g \" + NAME + \"_.cpp -o \" + NAME + \"_.exe\").c_str());",
      "    cout << endl;",
      "",
      "    for (int iTest = 1; iTest <= 1e5; iTest++) {",
      "        ofstream out(NAME2 + \".inp\");",
      "        cout << \"Test \" << iTest << \": \";",
      "        //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv<<<<<<",
      "",
      "            int n = Rand(1, 10000);",
      "            out << n << '\\n';",
      "            while (n--) out << char(Rand('a', 'z'));",
      "",
      "        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<<<<<<",
      "        out.close();",
      "        ifstream checkempty(NAME2 + \".inp\");",
      "        if (checkempty.peek() == std::ifstream::traits_type::eof()) {",
      "            cout << \"___EMPTY INPUT___\";",
      "            break;",
      "        }",
      "        int time_begin = clock();",
      "        signed valerr = system((NAME + \".exe\").c_str());",
      "        if (valerr != 0) {",
      "            SetConsoleTextAttribute(cons, 96);",
      "            cout << \" RTE \" << valerr << endl;",
      "            SetConsoleTextAttribute(cons, 15);",
      "            system(\"pause\");",
      "            continue;",
      "        }",
      "        int time_end = clock();",
      "        cout << \"time: \" << time_end-time_begin << \"ms, bruteforce: \";",
      "        cout.flush();",
      "        if (time_end-time_begin > 1e50) {",
      "            SetConsoleTextAttribute(cons, 112);",
      "            cout << \" TLE \";",
      "            SetConsoleTextAttribute(cons, 15);",
      "            system(\"pause\");",
      "        }",
      "        time_begin = clock();",
      "        system((NAME + \"_.exe\").c_str());",
      "        time_end = clock();",
      "        cout << time_end-time_begin << \"ms: \";",
      "        ",
      "        SetConsoleTextAttribute(cons, 15);",
      "        if (system((\"fc \" + NAME2 + \".out _ab.ans\").c_str()) != 0) {",
      "            SetConsoleTextAttribute(cons, 64);",
      "            cout << \" WRONG \" << endl;",
      "            SetConsoleTextAttribute(cons, 15);",
      "            system(\"pause\");",
      "        } else {",
      "            SetConsoleTextAttribute(cons, 160);",
      "            cout << \" ACCEPTED \" << endl;",
      "            SetConsoleTextAttribute(cons, 15);",
      "        }",
      "    }",
      "    system(\"pause\");",
      "    return 0;",
      "}"
    ],
    "description": "#sinhtest"
  },
  "sortquery": {
    "prefix": "#mo",
    "body": [
      "const int N = 2e5+5, S = 455;",
      "struct query {",
      "    int l, r, id;",
      "    bool operator < (const query &x) {",
      "        if (l / S == x.l / S) return r < x.r;",
      "        return l / S < x.l / S;",
      "    }",
      "} qr[N];",
      "",
      "    for (int i = 1; i <= q; ++i) {",
      "        cin >> qr[i].l >> qr[i].r;",
      "        qr[i].id = i;",
      "    }",
      "",
      "    sort(qr + 1, qr + q + 1);",
      "    int u = 1, v = 0;",
      "    for (int i = 1; i <= q; ++i) {",
      "        while (v < qr[i].r) update(a[++v], 1);",
      "        while (u > qr[i].l) update(a[--u], 1);",
      "        while (v > qr[i].r) update(a[v--], -1);",
      "        while (u < qr[i].l) update(a[u++], -1);",
      "",
      "        ",
      "    }",
      "",
      "    for (int i = 1; i <= q; ++i) cout << ans[i] << '\\n';"
    ],
    "description": "sortquery"
  },
  "trace_min_cuts_O(n^3)": {
    "prefix": "#mincuts",
    "body": [
      "const int N = 505;",
      "int n, m;",
      "vector<int> adj[N];",
      "bool vis[N];",
      "int f[N][N];",
      "int par[N];",
      "bool found_augment(int s, int t) {",
      "    for (int i = 1; i <= n; ++i) vis[i] = 0;",
      "    queue<int> q;",
      "    q.push(s);",
      "    vis[s] = 1;",
      "    while (!q.empty()) {",
      "        int u = q.front(); q.pop();",
      "        for (int v: adj[u]) {",
      "            if (!vis[v] && f[u][v] > 0) {",
      "                q.push(v);",
      "                par[v] = u;",
      "                vis[v] = 1;",
      "            }",
      "        }",
      "    }",
      "    return vis[t];",
      "}",
      "void dfs(int u) {",
      "    vis[u] = 1;",
      "    for (int v: adj[u])",
      "        if (!vis[v] && f[u][v] > 0)",
      "            dfs(v);",
      "}",
      "void find_min_cuts(int s, int t) {",
      "    while (found_augment(s, t)) {",
      "        int u = n;",
      "        int val = 1e18;",
      "        while (u != 1) {",
      "            val = min(val, f[par[u]][u]);",
      "            u = par[u];",
      "        }",
      "        u = n;",
      "        while (u != 1) {",
      "            f[par[u]][u] -= val;",
      "            f[u][par[u]] += val;",
      "            u = par[u];",
      "        }",
      "    }",
      "    for (int i = 1; i <= n; ++i) vis[i] = 0;",
      "    dfs(s);",
      "    vector<II> mincuts;",
      "    for (int u = 1; u <= n; ++u) if (vis[u])",
      "        for (int v: adj[u])",
      "            if (!vis[v])",
      "                mincuts.push_back(II(u, v));",
      "    cout << mincuts.size() << '\\n';",
      "    for (II e: mincuts) cout << e.fi << ' ' << e.se << '\\n';",
      "}",
      "",
      "signed main() {",
      "    cin >> n >> m;",
      "    for (int i = 1; i <= m; ++i) {",
      "        int u, v; cin >> u >> v;",
      "        adj[u].push_back(v);",
      "        adj[v].push_back(u);",
      "        ++f[u][v];",
      "        ++f[v][u];",
      "    }",
      "    find_min_cuts(1, n);",
      "    return 0;",
      "}"
    ],
    "description": "trace_min_cuts_O(n^3)"
  },
  "max_matching_trace": {
    "prefix": "#maxmatching",
    "body": [
      "const int N = 502;",
      "int n, m, mch[N];",
      "int vis[N], t = 0;",
      "vector<int> adj[N];",
      "bool matching(int u) {",
      "    if (vis[u] != t) vis[u] = t;",
      "    else return 0;",
      "    for (int v: adj[u]) {",
      "        if (!mch[v] || matching(mch[v])) {",
      "            mch[v] = u;",
      "            return 1;",
      "        }",
      "    }",
      "    return 0;",
      "}",
      "",
      "int main() {",
      "    int k; cin >> n >> m >> k;",
      "    while (k--) {",
      "        int u, v; cin >> u >> v;",
      "        adj[u].push_back(v);",
      "    }",
      "    int cnt = 0;",
      "    for (int i = 1; i <= n; i++) {",
      "        ++t;",
      "        cnt += matching(i);",
      "    }",
      "    cout << cnt << '\\n';",
      "    for (int i = 1; i <= m; ++i)",
      "        if (mch[i])",
      "            cout << mch[i] << ' ' << i << '\\n';",
      "    return 0;",
      "}"
    ],
    "description": "max_matching_trace"
  },
  "cses_Polynomial_Queries": {
    "prefix": "$segpolyupdate",
    "body": [
      "int calc(int l, int r) {",
      "    return (l + r) * (r - l + 1) / 2;",
      "}",
      "int seg[N * 4];",
      "void build(int id = 1, int l = 1, int r = n) {",
      "    if (l == r) {",
      "        seg[id] = a[l];",
      "        return;",
      "    }",
      "    int mid = l + r >> 1;",
      "    build(id << 1, l, mid);",
      "    build(id << 1 | 1, mid + 1, r);",
      "    seg[id] = seg[id << 1] + seg[id << 1 | 1];",
      "}",
      "int cnt[N * 4], sum[N * 4];",
      "// a[i] = i * x - (u - 1) * y",
      "// a[i] = cnt[i] - sum[i]",
      "// seg[l..r] = cnt[i]",
      "void pushdown(int id, int l, int r) {",
      "    if (cnt[id] == 0) return;",
      "    int mid = l + r >> 1;",
      "    cnt[id << 1] += cnt[id];",
      "    sum[id << 1] += sum[id];",
      "    seg[id << 1] += cnt[id] * calc(l, mid) - sum[id] * (mid - l + 1);",
      "",
      "    cnt[id << 1 | 1] += cnt[id];",
      "    sum[id << 1 | 1] += sum[id];",
      "    seg[id << 1 | 1] += cnt[id] * calc(mid + 1, r) - sum[id] * (r - mid);",
      "",
      "    cnt[id] = sum[id] = 0;",
      "}",
      "// i = u..v: cnt[i] += i, sum[i] += u - 1;",
      "// a[u] += 1, a[u + 1] += 2, a[u + 2] += 3, ..., a[v] += a[v - u + 1]",
      "void update(int u, int v, int id = 1, int l = 1, int r = n) {",
      "    if (u <= l && r <= v) {",
      "        cnt[id] += 1;",
      "        sum[id] += u - 1;",
      "        seg[id] += calc(l, r) - (u - 1) * (r - l + 1);",
      "        return;",
      "    }",
      "    if (l > v || r < u) return;",
      "    pushdown(id, l, r);",
      "    int mid = l + r >> 1;",
      "    update(u, v, id << 1, l, mid);",
      "    update(u, v, id << 1 | 1, mid + 1, r);",
      "    seg[id] = seg[id << 1] + seg[id << 1 | 1];",
      "}",
      "// a[u] + a[u + 1] + a[u + 2] + ... + a[v]",
      "int get(int u, int v, int id = 1, int l = 1, int r = n) {",
      "    if (u <= l && r <= v) return seg[id];",
      "    if (l > v || r < u) return 0;",
      "    pushdown(id, l, r);",
      "    int mid = l + r >> 1;",
      "    return get(u, v, id << 1, l, mid) + get(u, v, id << 1 | 1, mid + 1, r);",
      "}"
    ],
    "description": "cses_Polynomial_Queries"
  },
  "diophantine(ax+by=c)": {
    "prefix": "#diophantine",
    "body": [
      "// Trả về gcd(a, b) và cập nhật nghiệm (x_g, y_g) của phương trình.",
      "int extended_euclid(int a, int b, int &x, int &y)",
      "{",
      "    if (b == 0)",
      "    {",
      "        x = 1;",
      "        y = 0;",
      "        return a;",
      "    }",
      "    int x1, y1;",
      "    int d = extended_euclid(b, a % b, x1, y1);",
      "    x = y1;",
      "    y = x1 - y1 * (a / b);",
      "    return d;",
      "}",
      "",
      "// Trả về true và cập nhật nghiệm (x0, y0) nếu có nghiệm.",
      "// Ngược lại trả về false và không cập nhật nghiệm.",
      "bool find_one_solution(int a, int b, int c, int &x0, int &y0, int g)",
      "{",
      "    g = extended_euclid(abs(a), abs(b), x0, y0);",
      "    ",
      "    if (c % g != 0)",
      "        return false;",
      "    x0 *= c / g;",
      "    y0 *= c / g;",
      "    if (a < 0)",
      "        x0 = -x0;",
      "    if (b < 0)",
      "        y0 = -y0;",
      "    return true;",
      "}",
      "",
      "void solve_diophantine_equation(int a, int b, int c)",
      "{",
      "    // Trường hợp suy biến: a = 0 và b = 0.",
      "    if (a == 0 && b == 0)",
      "    {",
      "        if (c == 0)",
      "            cout << \"The equation has infinite solutions\";",
      "        else ",
      "            cout << \"Solution is not existed\";",
      "    }",
      "    // Giải phương trình và tìm một nghiệm hoặc thông báo vô nghiệm.",
      "    int x0, y0, g;",
      "    bool has_solution = find_one_solution(a, b, c, x0, y0, g);",
      "    if (has_solution)",
      "        cout << x0 << ' ' << y0;",
      "    else ",
      "        cout << \"Solution is not existed\";",
      "}"
    ],
    "description": "diophantine(ax+by=c)"
  },
  "seg_assignpoint_getmaxrange": {
    "prefix": "$seg_i=max",
    "body": [
      "int seg[N*4];",
      "int szSeg;",
      "    szSeg = (1 << (int)ceil(log2(n))) - 1;",
      "void update(int pos, int val) {",
      "    int id = pos + szSeg;",
      "    seg[id] = val;",
      "    while (id >>= 1)",
      "        seg[id] = max(seg[id << 1], seg[id << 1 | 1]);",
      "}",
      "int get(int l, int r) {",
      "    l += szSeg, r += szSeg;",
      "    int res = 0;",
      "    while (l <= r) {",
      "        if (l & 1) {",
      "            res = maxi(res, seg[l]);",
      "            ++l;",
      "        }",
      "        if (~r & 1) {",
      "            res = maxi(res, seg[r]);",
      "            --r;",
      "        }",
      "        l >>= 1, r >>= 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "seg_assignpoint_getmaxrange"
  },
  "seg_maxrange": {
    "prefix": "$seg_maxrange",
    "body": [
      "const int INF = 1e18;",
      "struct node {",
      "    int rng, sum, pre, sub;",
      "};",
      "node seg[N * 4];",
      "void update(int pos, int val, int id = 1, int l = 1, int r = n) {",
      "    if (l == r) {",
      "        seg[id] = {val, val, val, val};",
      "        return ;",
      "    }",
      "    int mid = l + r >> 1;",
      "    int lf = id << 1, rt = id << 1 | 1;",
      "    if (pos <= mid)",
      "        update(pos, val, lf, l, mid);",
      "    else",
      "        update(pos, val, rt, mid + 1, r);",
      "",
      "    seg[id].rng = max({seg[lf].rng, seg[rt].rng, seg[lf].sub + seg[rt].pre});",
      "    seg[id].sum = seg[lf].sum + seg[rt].sum;",
      "    seg[id].pre = max(seg[lf].pre, seg[lf].sum + seg[rt].pre);",
      "    seg[id].sub = max(seg[lf].sub + seg[rt].sum, seg[rt].sub);",
      "}",
      "node get(int u, int v, int id = 1, int l = 1, int r = n) {",
      "    if (l > r || r < u || v < l) return {-INF, -INF, -INF, -INF};",
      "    if (u <= l && r <= v) return seg[id];",
      "    int mid = l + r >> 1;",
      "",
      "    node lf = get(u, v, id << 1, l, mid);",
      "    node rt = get(u, v, id << 1 | 1, mid + 1, r);",
      "",
      "    node res;",
      "    res.rng = max({lf.rng, rt.rng, lf.sub + rt.pre});",
      "    res.sum = lf.sum + rt.sum;",
      "    res.pre = max(lf.pre, lf.sum + rt.pre);",
      "    res.sub = max(lf.sub + rt.sum, rt.sub);",
      "    return res;",
      "}"
    ],
    "description": "seg_maxrange"
  },
  "persitent": {
    "prefix": "$persitent",
    "body": [
      "vector<int> ver;",
      " ",
      "struct node {",
      "    int l, r, s;",
      "};",
      "node seg[N*4*18];",
      "int cur = 1;",
      " ",
      "void update(int &id, int l, int r, int pos, int val) {",
      "    seg[cur] = seg[id];",
      "    seg[cur].s += val;",
      "    id = cur++;",
      "    if (l == r) return;",
      " ",
      "    int mid = l + r >> 1;",
      "    if (pos <= mid) update(seg[id].l, l, mid, pos, val);",
      "    else update(seg[id].r, mid+1, r, pos, val);",
      "}",
      " ",
      "int get(int id, int l, int r, int u, int v) {",
      "    if (u <= l && r <= v) return seg[id].s;",
      "    if (r < u || l > v) return 0;",
      "    int mid = l + r >> 1;",
      "    return get(seg[id].l, l, mid, u, v)",
      "        + get(seg[id].r, mid+1, r, u, v);",
      "}"
    ],
    "description": "persitent"
  },
  "trie_sumkth": {
    "prefix": "$trie_sumkth",
    "body": [
      "const int SZ = 2, K = 30;",
      "struct TrieNode {",
      "    TrieNode *child[SZ];",
      "    int cnt;",
      "    int sum;",
      "    TrieNode() {",
      "        cnt = 0;",
      "        sum = 0;",
      "        for (int i = 0; i < SZ; ++i) child[i] = NULL;",
      "    }",
      "};",
      "void add(TrieNode *root, int x) {",
      "    TrieNode *cur = root;",
      "    for (int i = K - 1; i >= 0; --i) {",
      "        int id = x >> i & 1;",
      "        if (cur -> child[id] == NULL)",
      "            cur -> child[id] = new TrieNode();",
      "        cur = cur -> child[id];",
      "        cur -> cnt += 1;",
      "        cur -> sum += x;",
      "",
      "    }",
      "}",
      "void remove(TrieNode *root, int x) {",
      "    TrieNode *cur = root;",
      "    for (int i = K - 1; i >= 0; --i) {",
      "        int id = x >> i & 1;",
      "        if (cur -> child[id] == NULL)",
      "            return;",
      "        cur = cur -> child[id];",
      "        cur -> cnt -= 1;",
      "        cur -> sum -= x;",
      "    }",
      "}",
      "int getsum(TrieNode *root, int k) {",
      "    TrieNode *cur = root;",
      "    int res = 0, val = 0;",
      "    for (int i = K - 1; i >= 0; --i) {",
      "        for (int j = 0; j < 2; ++j) {",
      "            TrieNode *nxt = cur -> child[j];",
      "            if (nxt == NULL || nxt -> cnt == 0)",
      "                continue;",
      "            if (nxt -> cnt <= k) {",
      "                res += nxt -> sum;",
      "                k -= nxt -> cnt;",
      "                if (k == 0) return res;",
      "            }",
      "            else {",
      "                cur = nxt;",
      "                if (j) val |= 1 << i;",
      "                break;",
      "            }",
      "        }",
      "    }",
      "    if (k > 0) res += val * k;",
      "    return res;",
      "}"
    ],
    "description": "trie_sumkth"
  },
  "automodint": {
  "prefix": "#modnum",
  "body": [
    "template <typename T> T mod_inv_in_range(T a, T m) {",
    "    // assert(0 <= a && a < m);",
    "    T x = a, y = m;",
    "    T vx = 1, vy = 0;",
    "    while (x) {",
    "        T k = y / x;",
    "        y %= x;",
    "        vy -= k * vx;",
    "        swap(x, y);",
    "        swap(vx, vy);",
    "    }",
    "    assert(y == 1);",
    "    return vy < 0 ? m + vy : vy;",
    "}",
    " ",
    "template <typename T> T mod_inv(T a, T m) {",
    "    a %= m;",
    "    a = a < 0 ? a + m : a;",
    "    return mod_inv_in_range(a, m);",
    "}",
    " ",
    "template <int MOD_> struct modnum {",
    "    static constexpr int MOD = 1e9+7;",
    " ",
    "private:",
    "    int v;",
    " ",
    "public:",
    " ",
    "    modnum() : v(0) {}",
    "    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }",
    "    explicit operator int() const { return v; }",
    "    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }",
    "    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }",
    " ",
    "    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
    "    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
    " ",
    "    modnum inv() const {",
    "        modnum res;",
    "        res.v = mod_inv_in_range(v, MOD);",
    "        return res;",
    "    }",
    "    friend modnum inv(const modnum& m) { return m.inv(); }",
    "    modnum neg() const {",
    "        modnum res;",
    "        res.v = v ? MOD - v : 0;",
    "        return res;",
    "    }",
    "    friend modnum neg(const modnum& m) { return m.neg(); }",
    " ",
    "    modnum operator- () const {",
    "        return neg();",
    "    }",
    "    modnum operator+ () const {",
    "        return modnum(*this);",
    "    }",
    " ",
    "    modnum& operator ++ () {",
    "        v ++;",
    "        if (v == MOD) v = 0;",
    "        return *this;",
    "    }",
    "    modnum& operator -- () {",
    "        if (v == 0) v = MOD;",
    "        v --;",
    "        return *this;",
    "    }",
    "    modnum& operator += (const modnum& o) {",
    "        v -= MOD - o.v;",
    "        v = (v < 0) ? v + MOD : v;",
    "        return *this;",
    "    }",
    "    modnum& operator -= (const modnum& o) {",
    "        v -= o.v;",
    "        v = (v < 0) ? v + MOD : v;",
    "        return *this;",
    "    }",
    "    modnum& operator *= (const modnum& o) {",
    "        v = int(int64_t(v) * int64_t(o.v) % MOD);",
    "        return *this;",
    "    }",
    "    modnum& operator /= (const modnum& o) {",
    "        return *this *= o.inv();",
    "    }",
    " ",
    "    friend modnum operator ++ (modnum& a, int32_t) { modnum r = a; ++a; return r; }",
    "    friend modnum operator -- (modnum& a, int32_t) { modnum r = a; --a; return r; }",
    "    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
    "    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
    "    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
    "    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }",
    " ",
    "    // Added By Me",
    "    friend string to_string(const modnum& b) {",
    "        return to_string(b.v);",
    "    }",
    "    friend modnum Mpow(modnum b, int64_t p) {",
    "        modnum res = 1;",
    "        while (p > 0) { if (p & 1)  res *= b; p >>= 1; b *= b; }",
    "        return res;",
    "    }",
    "    int get() { modnum res; res.v = v; return res.v; }",
    "};",
    " ",
    "const int64_t MOD_ = 1000000007;",
    "using Mint = modnum <MOD_>;",
    "template <typename U, typename V> Mint bpow(U x, V y) {",
    "    Mint res = 1, num = x; int64_t p = y;",
    "    if (p > (MOD_ - 1)) p = p % (MOD_ - 1);",
    "    while (p > 0) {",
    "        if (p & 1) res *= num;",
    "        p >>= 1; num = num * num;",
    "    }",
    "    return res;",
    "}",
    "/*",
    "vector<Mint> fact(maxN), invfact(maxN), inverse(maxN);",
    "void preNCR() {",
    "    fact[0] = fact[1] = 1;",
    "    for (int i = 2; i < maxN; i++) {",
    "        fact[i] = fact[i - 1] * int64_t(i);",
    "    }",
    "    invfact[maxN - 1] = inv(fact[maxN - 1]);",
    "    for (int i = maxN - 2; i >= 0; i--) {",
    "        invfact[i] = invfact[i + 1] * int64_t(i + 1);",
    "    }",
    "    for (int i = 1; i < maxN; i++) {",
    "        inverse[i] = fact[i - 1] * invfact[i];",
    "    }",
    "}",
    "Mint nCr(int n, int r) {",
    "    if (r > n || r < 0 || n < 0) return 0;",
    "    return fact[n] * invfact[r] * invfact[n - r];",
    "}",
    "Mint nPr(int n, int r) {",
    "    if (r > n || r < 0 || n < 0) return 0;",
    "    return fact[n] * invfact[n - r];",
    "}",
    "*/"
  ],
  "description": "automodint"
},
"compress": {
  "prefix": "#eraseunique",
  "body": [
    "    sort(val.begin(), val.end());",
    "    val.erase(unique(val.begin(), val.end()), val.end());",
    "    for (int i = 1; i <= n; ++i) {",
    "        a[i] = lower_bound(val.begin(), val.end(), a[i]) - val.begin();",
    "    }"
  ],
  "description": "compress"
},  
  "bellman": {
    "prefix": "#bellman",
    "body": [
      "int d[N];",
      "bool inqueue[N];",
      "void bellman(int u) {",
      "    for (int i = 1; i <= n; ++i) d[i] = INF;",
      "    d[u] = 0;",
      "    queue<int> qu;",
      "    qu.push(u);",
      "    inqueue[u] = 1;",
      "    while (!qu.empty()) {",
      "        u = qu.front();",
      "        inqueue[u] = 0;",
      "        qu.pop();",
      "        for (II e: adj[u]) {",
      "            int v = e.se, uv = e.fi;",
      "            if (mini(d[v], d[u] + uv)) {",
      "                if (!inqueue[v]) {",
      "                    qu.push(v);",
      "                    inqueue[v] = 1;",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "bellman"
  },
  "HashMod": {
		"prefix": "@HashMod",
		"body": [
		  "int pw[NMOD][LENGTH + 1];",
		  "",
		  "void calcpw() {",
		  "    for (int i = 0; i < NMOD; i++) {",
		  "        pw[i][0] = 1;",
		  "        for (int j = 1; j <= LENGTH; j++) {",
		  "            pw[i][j] = pw[i][j - 1] * BASE % HashMod[i];",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "",
		  "struct Hash {",
		  "    string s;",
		  "    int sz;",
		  "    vector<vector<int>> f;",
		  "    vector<vector<int>> g;",
		  "    Hash(string _s = \"\") {",
		  "        s = _s;",
		  "        sz = SZ(s);",
		  "    }",
		  "    void input() {",
		  "        cin >> s;",
		  "        sz = SZ(s);",
		  "    }",
		  "    void calcf() {",
		  "        f.assign(NMOD, vector<int>(sz + 5, 0));",
		  "        for (int i = 0; i < NMOD; i++) {",
		  "            for (int j = 1; j <= sz; j++) {",
		  "                f[i][j] = (f[i][j - 1] + pw[i][j] * s[j - 1] % HashMod[i]) % HashMod[i];",
		  "            }",
		  "        }",
		  "    }",
		  "    void calcg() {",
		  "        g.assign(NMOD, vector<int>(sz + 5, 0));",
		  "        for (int i = 0; i < NMOD; i++) {",
		  "            for (int j = sz; j >= 1; j--) {",
		  "                g[i][j] = (g[i][j + 1] + pw[i][sz - j + 1] * s[j - 1] % HashMod[i]) % HashMod[i];",
		  "            }",
		  "        }",
		  "    }",
		  "    void output() {",
		  "        cout << s << \" \" << sz << endl;",
		  "    }",
		  "};",
		  "",
		  "",
		  "struct ValueHash {",
		  "    int value[NMOD];",
		  "    ValueHash() {",
		  "        for (int i = 0; i < NMOD; i++) value[i] = -1;",
		  "    }",
		  "    ValueHash(Hash &a, const int &l, const int &r, const bool &type) {",
		  "        if (l <= r) {",
		  "            if (type) {",
		  "                for (int i = 0; i < NMOD; i++) {",
		  "                    value[i] = (a.f[i][r] - a.f[i][l - 1] + HashMod[i]) % HashMod[i] * pw[i][LENGTH - r] % HashMod[i];",
		  "                }",
		  "            }",
		  "            else {",
		  "                for (int i = 0; i < NMOD; i++) {",
		  "                    value[i] = (a.g[i][l] - a.g[i][r + 1] + HashMod[i]) % HashMod[i] * pw[i][LENGTH - (a.sz - l + 1)] % HashMod[i];",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "    bool operator == (const ValueHash &other) const {",
		  "        for (int i = 0; i < NMOD; i++) {",
		  "            if (value[i] != other.value[i]) return false;",
		  "        }",
		  "        return true;",
		  "    }",
		  "    bool operator != (const ValueHash &other) const {",
		  "        for (int i = 0; i < NMOD; i++) {",
		  "            if (value[i] == other.value[i]) return false;",
		  "        }",
		  "        return true;",
		  "    }",
		  "    bool operator < (const ValueHash &other) const {",
		  "        for (int i = 0; i < NMOD; i++) {",
		  "            if (value[i] != other.value[i]) return value[i] < other.value[i];",
		  "        }",
		  "        return false;",
		  "    }",
		  "    void output() {",
		  "        for (int i = 0; i < NMOD; i++) {",
		  "            cout << value[i] << \" \";",
		  "        }",
		  "        cout << endl;",
		  "    }",
		  "};",
		  "",
		  "bool IsPalindrome(Hash &a, int l, int r) {",
		  "    if (l > r) return false;",
		  "    int mid = (l + r) / 2;",
		  "    return ((r - l + 1) % 2 == 0) ? ValueHash(a, l, mid, 1) == ValueHash(a, mid + 1, r, 0)",
		  "                                  : ValueHash(a, l, mid, 1) == ValueHash(a, mid, r, 0);",
		  "}"
		],
		"description": "HashMod"
	},
	"CustomHash": {
		"prefix": "@CustomHash",
		"body": [
		  "struct custom_hash {",
		  "    static uint64_t splitmix64(uint64_t x) {",
		  "        // http://xorshift.di.unimi.it/splitmix64.c",
		  "        x += 0x9e3779b97f4a7c15;",
		  "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
		  "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
		  "        return x ^ (x >> 31);",
		  "    }",
		  "",
		  "    size_t operator()(uint64_t x) const {",
		  "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
		  "        return splitmix64(x + FIXED_RANDOM);",
		  "    }",
		  "};"
		],
		"description": "CustomHash"
	},
	"geometry": {
		"prefix": "@geometry",
		"body": [
		  "const double DIFF = 0.0000001;",
		  "const double PI = acos(-1);",
		  "",
		  "using TCoord = int;",
		  "",
		  "bool same(const TCoord &u, const TCoord &v) {",
		  "    return abs(u - v) <= DIFF;",
		  "}",
		  "",
		  "struct TVector {",
		  "    TCoord x, y;",
		  "    TVector(TCoord _x = 0, TCoord _y = 0) {",
		  "        x = _x;",
		  "        y = _y;",
		  "    }",
		  "",
		  "    // AC = AB + BC ",
		  "    // BC = AC - AB",
		  "    // atan2 calc % of 2 vector",
		  "",
		  "    bool operator < (const TVector &other) const {",
		  "        return y == other.y ? x < other.x : y < other.y;",
		  "    }",
		  "    bool operator == (const TVector &other) const {",
		  "        return same(y, other.y) && same(x, other.x);",
		  "    }",
		  "",
		  "    TVector operator + (const TVector &other) const {",
		  "        return TVector(x + other.x, y + other.y);",
		  "    }",
		  " ",
		  "    TVector operator - (const TVector &other) const {",
		  "        return TVector(x - other.x, y - other.y);",
		  "    }",
		  " ",
		  "    TCoord operator % (const TVector &other) const {",
		  "        return x * other.x + y * other.y;",
		  "    }",
		  " ",
		  "    TCoord operator * (const TVector &other) const {",
		  "        return x * other.y - other.x * y;",
		  "    }",
		  " ",
		  "    TCoord len() {",
		  "        return sqrt(x * x + y * y);",
		  "    }",
		  " ",
		  "    TCoord sqrlen() {",
		  "        return x * x + y * y;",
		  "    }",
		  " ",
		  "    void input() {",
		  "        cin >> x >> y;",
		  "    }",
		  "    ",
		  "    void output() {",
		  "        cout << x << \" \" << y << endl;",
		  "    }",
		  "",
		  "};",
		  "",
		  "using TPoint = TVector;",
		  "",
		  "struct TLine {",
		  "    TCoord a, b, c;",
		  "    TLine (TCoord _a = 0, TCoord _b = 0, TCoord _c = 0) {",
		  "        a = _a;",
		  "        b = _b;",
		  "        c = _c;",
		  "    }",
		  "    bool operator == (const TLine &other) const {",
		  "        return same(a, other.a) &&  same(b, other.b) && same(c, other.c);",
		  "    }",
		  "    bool operator != (const TLine &other) const {",
		  "        return !same(a, other.a) || !same(b, other.b) || !same(c, other.c);",
		  "    }",
		  "    void output() {",
		  "        cout << a << \" \" << b << \" \" << c << endl;",
		  "    }",
		  "};",
		  "",
		  "struct TPolygon {",
		  "    vector<TPoint> s;",
		  "    TCoord area;",
		  "    TPolygon(vector<TPoint> _s = {}, TCoord _area = 0) {",
		  "        s = _s;",
		  "        area = _area;",
		  "    }",
		  "    void input() {",
		  "        int sz = 3;",
		  "        // cin >> sz;",
		  "        for (int i = 1; i <= sz; i++) {",
		  "            TCoord x, y;",
		  "            cin >> x >> y;",
		  "            s.pushb(TPoint(x, y));",
		  "        } ",
		  "        sort(ALL(s));",
		  "        for (int i = 0; i < sz - 1; i++) {",
		  "            area += (s[i] - s[0]) * (s[i + 1] - s[0]);",
		  "        }",
		  "        area = abs(area / 2);",
		  "    }",
		  "    TCoord CalcArea() {",
		  "        TCoord ans = 0;",
		  "        int n = SZ(s) - 1;",
		  "        for (int i = 0; i <= n - 1; i++) {",
		  "            ans += (s[i] - s[0]) * (s[i + 1] - s[0]);",
		  "        }",
		  "        return abs(ans / 2);",
		  "    }",
		  "    void output() {",
		  "        cout << \"polygon\" << endl;",
		  "        for (auto x : s) x.output();",
		  "    }",
		  "",
		  "};",
		  "",
		  "TCoord dist(const TPoint &a, const TPoint &b) {",
		  "    return sqrt(sqr(a.x - b.x) + sqr(b.y - a.y));",
		  "}",
		  "",
		  "TCoord sqrdist(const TPoint &a, const TPoint &b) {",
		  "    return sqr(a.x - b.x) + sqr(b.y - a.y);",
		  "}",
		  "",
		  "TPoint middle(TPoint a, TPoint b) {",
		  "    return TPoint((a.x + b.x) / 2 * 2, (a.y + b.y) / 2 * 2);",
		  "}",
		  " ",
		  "bool BotLeft(const TPoint &a, const TPoint &b) {",
		  "    return a.y == b.y ? a.x < b.x : a.y < b.y;",
		  "}",
		  " ",
		  "bool CCWCoord(const TPoint &a, const TPoint &b, const TPoint &c) {",
		  "    return (b - a) * (c - a) > 0;",
		  "} ",
		  " ",
		  "bool CCWVector(const TVector &u, const TVector &v) {",
		  "    return u * v > 0;",
		  "} ",
		  "",
		  "bool OnLine(TPoint a, TPoint b, TPoint c) {",
		  "    TVector u = b - a;",
		  "    TVector v = c - a;",
		  "    return u * v == 0;",
		  "}",
		  "",
		  "bool Line(TPoint a, TPoint b, TPoint c) {",
		  "    TVector u = b - a;",
		  "    TVector v = c - a;",
		  "    return u * v == 0 && u.sqrlen() < v.sqrlen();",
		  "}",
		  "",
		  "TLine line(TPoint u, TPoint v) {",
		  "    TVector n = v - u;",
		  "    swap(n.x, n.y);",
		  "    n.y = -n.y;",
		  "    TCoord a = n.x;",
		  "    TCoord b = n.y;",
		  "    TCoord c = -a * u.x - b * u.y;",
		  "    return TLine(a, b, c);",
		  "}",
		  "",
		  "pair<TPoint, bool> intersection(TLine u, TLine v) {",
		  "    TCoord a1 = u.a, b1 = u.b, c1 = -u.c;",
		  "    TCoord a2 = v.a, b2 = v.b, c2 = -v.c;",
		  "    TCoord D = a1 * b2 - a2 * b1;",
		  "    TCoord Dx = c1 * b2 - c2 * b1;",
		  "    TCoord Dy = a1 * c2 - a2 * c1;",
		  "    if (D == 0) return mapa(TPoint(), false);",
		  "    return mapa(TPoint(Dx / D, Dy / D), true);",
		  "}",
		  "",
		  "bool InPolygonNoEdge(const TPolygon &u, const TPoint &v) {",
		  "    TCoord ans = 0;",
		  "    int n = SZ(u.s) - 1;",
		  "    // size >= 3",
		  "    if (n < 2) return false;",
		  "    for (int i = 0; i < n; i++) {",
		  "        TVector p = u.s[i] - v;",
		  "        TVector q = u.s[i + 1] - v;",
		  "        ans += atan2(p * q, p % q) * 180;",
		  "    }   ",
		  "    TVector p = u.s[n] - v;",
		  "    TVector q = u.s[0] - v;",
		  "    ans += atan2(p * q, p % q) * 180;",
		  "    return abs(ans) >= 100;",
		  "}",
		  "",
		  "// on the edge",
		  "bool InPolygOnEdge(const TPolygon &u, const TPoint &v) {",
		  "    TCoord ans = 0;",
		  "    int n = SZ(u.s) - 1;",
		  "    // size >= 3",
		  "    if (n < 2) return false;",
		  "    for (int i = 0; i <= n - 1; i++) {",
		  "        ans += abs((u.s[i] - v) * (u.s[i + 1] - v));",
		  "    }",
		  "    ans += abs((u.s[n] - v) * (u.s[0] - v));",
		  "    ans /= 2;",
		  "    return same(ans, u.area);",
		  "}",
		  "",
		  "",
		  "vector<TLine> edge(const TPolygon &u) {",
		  "    vector<TLine> ans;",
		  "    int n = SZ(u.s) - 1;",
		  "    // size >= 3",
		  "    if (n < 2) return ans;",
		  "    for (int i = 0; i <= n - 1; i++) {",
		  "        ans.pushb(line(u.s[i], u.s[i + 1]));",
		  "    }",
		  "    ans.pushb(line(u.s[n], u.s[0]));",
		  "    return ans;",
		  "}",
		  "",
		  "TPolygon intersection(const TPolygon &a, const TPolygon &b) {",
		  "    vector<TLine> s = edge(a);",
		  "    vector<TLine> t = edge(b);",
		  "    vector<TPoint> ans;",
		  "    for (auto x : s) {",
		  "        for (auto y : t) {",
		  "            auto [tmp, ok] = intersection(x, y);",
		  "            if (ok && InPolygOnEdge(a, tmp) && InPolygOnEdge(b, tmp)) ans.pushb(tmp);",
		  "        }   ",
		  "    }",
		  "    for (auto x : b.s) {",
		  "        if (InPolygOnEdge(a, x)) ans.pushb(x);",
		  "    }",
		  "    for (auto x : a.s) {",
		  "        if (InPolygOnEdge(b, x)) ans.pushb(x);",
		  "    }",
		  "    if (ans.empty()) return ans;",
		  "    sort(ALL(ans), [&](const TPoint &b, const TPoint &c){",
		  "        TVector u = b - ans[0];",
		  "        TVector v = c - ans[0];",
		  "        return u * v > 0 || u.sqrlen() < v.sqrlen() && u * v == 0;",
		  "    });",
		  "    vector<TPoint> res; ",
		  "    res.pushb(ans[0]);",
		  "    for (int i = 1; i < SZ(ans); i++) if (!(ans[i] == ans[i - 1])) {",
		  "        res.pushb(ans[i]);",
		  "    }",
		  "    return TPolygon(res);",
		  "}"
		],
		"description": "geometry"
	},
	"BigCnK": {
		"prefix": "@BigCnK",
		"body": [
		  "const int LimN = 1e6 + 5;",
		  "",
		  "int pref[LimN];",
		  "",
		  "pii ExtendedEuclid(int a, int b, int c) {",
		  "    int m = a, xm = 1;",
		  "    int n = b, xn = 0;",
		  "    int d = __gcd(a, b);",
		  "    while (n) {",
		  "        int q = m / n;",
		  "        int r = m - q * n;",
		  "        int xr = xm - q * xn;",
		  "        m = n; xm = xn;",
		  "        n = r; xn = xr;",
		  "    }",
		  "    int ansx = xm * c / d;",
		  "    int ansy = (d - a * xm) / b * c / d;",
		  "    return pii(ansx, ansy);",
		  "}",
		  "",
		  "int invmodulo(int a, int p) {",
		  "    assert(__gcd(a, p) == 1);",
		  "    auto [x, y] = ExtendedEuclid(a, p, 1);",
		  "    return (x % p + p) % p;",
		  "}",
		  "",
		  "int power(const int &x, const int &n) {",
		  "    if (n == 0) return 1;",
		  "    if (n == 1) return x;",
		  "    int tmp = power(x, n / 2);",
		  "    return tmp * tmp * (n % 2 == 0 ? 1 : x);",
		  "}",
		  "",
		  "int powermod(const int &x, const int &n, const int &mod) {",
		  "    if (n == 0) return 1;",
		  "    if (n == 1) return x;",
		  "    int tmp = powermod(x, n / 2, mod);",
		  "    return tmp * tmp % mod * (n % 2 == 0 ? 1 : x) % mod;",
		  "}",
		  " ",
		  "",
		  "",
		  "int BigCnK(int n, int k, int mod) {",
		  "",
		  "    // 0(mod * log10(mod) + log(n) * log10(mod) + log())",
		  "",
		  "    // 18 = pii(2, 1), pii(3, 2)",
		  "    function<vector<pii>(int)> sprime = [&](int n) {",
		  "        // O(sqrt(n))",
		  "        vector<pii> ans;",
		  "        for (int i = 2; i * i <= n; i++) if (n % i == 0) {",
		  "            int cnt = 0;",
		  "            while (n % i == 0) {",
		  "                n /= i;",
		  "                cnt++;",
		  "            }",
		  "            ans.pushb(pii(i, cnt));",
		  "        }",
		  "        if (n > 1) ans.pushb(pii(n, 1));",
		  "        return ans;",
		  "    };",
		  "    ",
		  "    // nCk! mod prime P^pow",
		  "    function<pii(int, int)> r = [&](int p, int ppow) {",
		  "        int num = power(p, ppow);",
		  "",
		  "        int mul = 1;",
		  "        pref[0] = 1;",
		  "        for (int i = 1; i <= num; i++) {",
		  "            pref[i] = pref[i - 1];",
		  "            if (i % p == 0) {",
		  "                continue;",
		  "            }",
		  "            pref[i] = pref[i - 1] * i % num;",
		  "        }",
		  "",
		  "        function<pii(int)> f = [&](int n) {",
		  "        ",
		  "            // 1 2 3 4 5 6 7 8 pp ppp ppp",
		  "            function<int(int)> calc = [&](int n) {",
		  "                if (n < p) return pref[n];",
		  "                int div = n / num;",
		  "                int r = n - div * num;",
		  "                return calc(n / p) * powermod(pref[num - 1], div, num) % num * pref[r] % num;",
		  "            };",
		  "",
		  "",
		  "            function<int(int)> sumpow = [&](int n) {",
		  "                int x = p;",
		  "                int ans = 0;",
		  "                while (x <= n) {",
		  "                    ans += n / x;",
		  "                    x *= p;",
		  "                }",
		  "                return ans;",
		  "            };",
		  "",
		  "",
		  "            return pii(calc(n), sumpow(n));",
		  "",
		  "        };",
		  "",
		  "        auto [a, suma] = f(n);",
		  "        auto [b, sumb] = f(k);",
		  "        auto [c, sumc] = f(n - k);",
		  "",
		  "        int tmp = suma - sumb - sumc;",
		  "        if (tmp >= ppow) return pii(0, num);",
		  "        tmp = power(p, tmp);",
		  "        return pii(tmp * a % num * invmodulo(b, num) % num * invmodulo(c, num) % num, num);",
		  "    };",
		  "",
		  "    function<int(vector<pii>)> ChineseRemainder = [&](const vector<pii> &v) {",
		  "        int ans = 0;",
		  "        for (auto [x, y] : v) {",
		  "            int m = mod / y;",
		  "            int z = invmodulo(m, y);",
		  "            ans += x * m * z % mod;",
		  "            ans %= mod;",
		  "        }",
		  "        return ans % mod;",
		  "    };",
		  "",
		  "    vector<pii> prime = sprime(mod);",
		  "",
		  "    vector<pii> v;",
		  "    for (auto [p, ppow] : prime) {",
		  "        v.pushb(pii(r(p, ppow)));",
		  "    }",
		  "",
		  "    return ChineseRemainder(v);",
		  "",
		  "}"
		],
		"description": "BigCnK"
	},
	"bridge&criticalnode": {
		"prefix": "@bridge&criticalnode",
		"body": [
		  "int low[LimN], num[LimN], timeDFS;",
		  "",
		  "struct DataEdge {",
		  "    int u, v;",
		  "    bool used, bridge;",
		  "",
		  "    DataEdge(int _u = 0, int _v = 0) {",
		  "        u = _u; v = _v;",
		  "        used = false;",
		  "        bridge = false;",
		  "    }",
		  "",
		  "    int other(const int &x) const {",
		  "        return u ^ v ^ x;",
		  "    }",
		  "};",
		  "",
		  "void dfs(int u) {",
		  "    num[u] = low[u] = ++timeDFS;",
		  "    for (auto tmp : adj[u]) if (!edge[tmp].used) {",
		  "        int v = edge[tmp].other(u);",
		  "        edge[tmp].used = true;",
		  "        if (num[v]) {",
		  "            minimize(low[u], num[v]);",
		  "        }",
		  "        else {",
		  "            dfs(v);",
		  "            minimize(low[u], low[v]);",
		  "            edge[tmp].bridge = low[v] > num[u];",
		  "            IsJoin[u] = low[v] >= num[u];",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "bridge&criticalnode"
	},
	"cd": {
		"prefix": "@cd",
		"body": [
		  "const int LimN = 1e5 + 5;",
		  "",
		  "int NumNode;",
		  "vector<int> adj[LimN];",
		  "",
		  "struct CentroidDecomposition {",
		  "    int sz[LimN];",
		  "    bool CanGo[LimN];",
		  "",
		  "    void resize(int NumNode) {",
		  "        for (int i = 1; i <= NumNode; i++) {",
		  "            CanGo[i] = true;",
		  "            adj[i].clear();",
		  "        }",
		  "    }",
		  "",
		  "    int DfsSz(int u, int p) {",
		  "        sz[u] = 1;",
		  "        for (auto v : adj[u]) if (v != p && CanGo[v]) {",
		  "            sz[u] += DfsSz(v, u);",
		  "        }",
		  "        return sz[u];",
		  "    }",
		  "",
		  "    int FindCentroid(int u, int p, int NumNode) {",
		  "        for (auto v : adj[u]) if (v != p && CanGo[v]) {",
		  "            if (sz[v] > NumNode / 2) return FindCentroid(v, u, NumNode);",
		  "        }",
		  "        return u;",
		  "    }",
		  "    ",
		  "    void dfs(int u, int p) {",
		  "        for (auto v : adj[u]) if (v != p && CanGo[v]) {",
		  "            dfs(v, u);",
		  "        }",
		  "    }",
		  "",
		  "    void calc(int u) {",
		  "        for (auto v : adj[u]) if (CanGo[v]) {",
		  "            dfs(v, u);",
		  "        }",
		  "        // reset",
		  "    }",
		  "",
		  "    void build(int u) {",
		  "        int NumNode = DfsSz(u, u);",
		  "        int centroid = FindCentroid(u, u, NumNode);",
		  "        calc(centroid);",
		  "        CanGo[centroid] = false;",
		  "        for (auto v : adj[centroid]) if (CanGo[v]) {",
		  "            build(v);",
		  "        }",
		  "    }",
		  "",
		  "} cd;"
		],
		"description": "cd"
	},
	"dinic": {
		"prefix": "@dinic",
		"body": [
		  "struct FlowEdge {",
		  "    int v, u;",
		  "    int cap, flow = 0;",
		  "    FlowEdge(int v, int u, int cap) : v(v), u(u), cap(cap) {}",
		  "};",
		  " ",
		  "struct Dinic {",
		  "    const int flow_inf = INF;",
		  "    vector<FlowEdge> edges;",
		  "    vector<vector<int>> adj;",
		  "    int n, m = 0;",
		  "    int s, t;",
		  "    vector<int> level, ptr;",
		  "    queue<int> q;",
		  " ",
		  "    Dinic(int n, int s, int t) : n(n), s(s), t(t) {",
		  "        adj.resize(n + 5);",
		  "        level.resize(n + 5);",
		  "        ptr.resize(n + 5);",
		  "    }",
		  " ",
		  "    void add_edge(int v, int u, int cap) {",
		  "        edges.emplace_back(v, u, cap);",
		  "        edges.emplace_back(u, v, 0);",
		  "        adj[v].push_back(m);",
		  "        adj[u].push_back(m + 1);",
		  "        m += 2;",
		  "    }",
		  " ",
		  "    bool bfs() {",
		  "        while (!q.empty()) {",
		  "            int v = q.front();",
		  "            q.pop();",
		  "            for (int id : adj[v]) {",
		  "                if (edges[id].cap - edges[id].flow < 1)",
		  "                    continue;",
		  "                if (level[edges[id].u] != -1)",
		  "                    continue;",
		  "                level[edges[id].u] = level[v] + 1;",
		  "                q.push(edges[id].u);",
		  "            }",
		  "        }",
		  "        return level[t] != -1;",
		  "    }",
		  " ",
		  "    int dfs(int v, int pushed) {",
		  "        if (pushed == 0)",
		  "            return 0;",
		  "        if (v == t)",
		  "            return pushed;",
		  "        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {",
		  "            int id = adj[v][cid];",
		  "            int u = edges[id].u;",
		  "            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)",
		  "                continue;",
		  "            int tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));",
		  "            if (tr == 0)",
		  "                continue;",
		  "            edges[id].flow += tr;",
		  "            edges[id ^ 1].flow -= tr;",
		  "            return tr;",
		  "        }",
		  "        return 0;",
		  "    }",
		  " ",
		  "    int flow() {",
		  "        int f = 0;",
		  "        for (int i = 0; i < m; i++) edges[i].flow = 0;",
		  "        while (true) {",
		  "            fill(level.begin(), level.end(), -1);",
		  "            level[s] = 0;",
		  "            q.push(s);",
		  "            if (!bfs())",
		  "                break;",
		  "            fill(ptr.begin(), ptr.end(), 0);",
		  "            while (int pushed = dfs(s, flow_inf)) {",
		  "                f += pushed;",
		  "            }",
		  "        }",
		  "        return f;",
		  "    }",
		  "};"
		],
		"description": "dinic"
	},
	"DisjoinSet": {
		"prefix": "@DisjoinSet",
		"body": [
		  "class DisjoinSet {",
		  "private:",
		  "    vector<int> lab;",
		  "    int n;",
		  "public:",
		  "    DisjoinSet(int _n = 0) {",
		  "        n = _n;",
		  "        lab.assign(n + 5, -1);",
		  "    }",
		  "    void resize(int n) {",
		  "        lab.assign(n + 5, -1);",
		  "    }",
		  "    int root(int x) {",
		  "        return lab[x] < 0 ? x : lab[x] = root(lab[x]);",
		  "    }",
		  "    int sz(int x) {",
		  "        return -lab[root(x)];",
		  "    }",
		  "    bool join(int a, int b) {",
		  "        int x = root(a);",
		  "        int y = root(b);",
		  "        if (x == y) return false;",
		  "        if (lab[x] > lab[y]) swap(x, y);",
		  "        lab[x] += lab[y];",
		  "        lab[y] = x;",
		  "        return true;",
		  "    }",
		  "};"
		],
		"description": "DisjoinSet"
	},
	"dsurollback": {
		"prefix": "@dsurollback",
		"body": [
		  "class DsuRollBack {",
		  "private:",
		  "    int n;",
		  "    vector<int> lab;",
		  "    stack<DataDsu> st;",
		  "public:",
		  "    DsuRollBack(int _n = 0) {",
		  "        n = _n;",
		  "        lab.resize(n + 5, -1);",
		  "    }",
		  "    void reset() {",
		  "        for (int i = 1; i <= n; i++) lab[i] = -1;",
		  "    }",
		  "    void resize(int _n = 0) {",
		  "        n = _n;",
		  "        lab.resize(n + 5, -1);",
		  "    }",
		  "    int root(int x, int t) {",
		  "        if (lab[x] < 0) return x;",
		  "        st.push(DataDsu(x, lab[x], t));",
		  "        return lab[x] = root(lab[x], t);",
		  "    }",
		  "    int sz(int x, int t) {",
		  "        return -lab[root(x, t)];",
		  "    }",
		  "    bool join(int a, int b, int t) {",
		  "        int x = root(a, t);",
		  "        int y = root(b, t);",
		  "        if (x == y) return false;",
		  "        if (lab[x] > lab[y]) swap(x, y);",
		  "        lab[x] += lab[y];",
		  "        st.push(DataDsu(y, lab[y], t));",
		  "        lab[y] = x;",
		  "        return true;",
		  "    }",
		  "    void undo(int t) {",
		  "        while (!st.empty() && st.top().t > t) {",
		  "            int u = st.top().u;",
		  "            int pu = st.top().old;",
		  "            if (pu < 0) {",
		  "                lab[lab[u]] -= pu;",
		  "            }",
		  "            lab[u] = pu;",
		  "            st.pop();",
		  "        }",
		  "    }",
		  "    bool connect(int u, int v, int t) {",
		  "        return root(u, t) == root(v, t);",
		  "    }",
		  "} dsu;"
		],
		"description": "dsurollback"
	},
	"ExtendedEuclid": {
		"prefix": "@ExtendedEuclid",
		"body": [
		  "pii ExtendedEuclid(int a, int b, int c) {",
		  "    int m = a, xm = 1;",
		  "    int n = b, xn = 0;",
		  "    int d = __gcd(a, b);",
		  "    while (n) {",
		  "        int q = m / n;",
		  "        int r = m - q * n;",
		  "        int xr = xm - q * xn;",
		  "        m = n; xm = xn;",
		  "        n = r; xn = xr;",
		  "    }",
		  "    int ansx = xm * c / d;",
		  "    int ansy = (d - a * xm) / b * c / d;",
		  "    return pii(ansx, ansy);",
		  "}"
		],
		"description": "ExtendedEuclid"
	},
	"factorial": {
		"prefix": "@factorial",
		"body": [
		  "template <typename T> T mod_inv_in_range(T a, T m) {",
		  "    // assert(0 <= a && a < m);",
		  "    T x = a, y = m;",
		  "    T vx = 1, vy = 0;",
		  "    while (x) {",
		  "        T k = y / x;",
		  "        y %= x;",
		  "        vy -= k * vx;",
		  "        std::swap(x, y);",
		  "        std::swap(vx, vy);",
		  "    }",
		  "    assert(y == 1);",
		  "    return vy < 0 ? m + vy : vy;",
		  "}",
		  " ",
		  "template <typename T> T mod_inv(T a, T m) {",
		  "    a %= m;",
		  "    a = a < 0 ? a + m : a;",
		  "    return mod_inv_in_range(a, m);",
		  "}",
		  " ",
		  "template <int32_t MOD_> struct modnum {",
		  "    static constexpr int32_t MOD = MOD_;",
		  "    static_assert(MOD_ > 0, \"MOD must be positive\");",
		  " ",
		  "    using ll = long long;",
		  " ",
		  "    int32_t v;",
		  " ",
		  "public:",
		  " ",
		  "    modnum() : v(0) {}",
		  "    modnum(ll v_) : v(int32_t(v_ % MOD)) { if (v < 0) v += MOD; }",
		  "    explicit operator int32_t() const { return v; }",
		  "    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int32_t(n); }",
		  "    friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }",
		  " ",
		  "    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
		  "    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
		  " ",
		  "    modnum inv() const {",
		  "        modnum res;",
		  "        res.v = mod_inv_in_range(v, MOD);",
		  "        return res;",
		  "    }",
		  "    friend modnum inv(const modnum& m) { return m.inv(); }",
		  "    modnum neg() const {",
		  "        modnum res;",
		  "        res.v = v ? MOD-v : 0;",
		  "        return res;",
		  "    }",
		  "    friend modnum neg(const modnum& m) { return m.neg(); }",
		  " ",
		  "    modnum operator- () const {",
		  "        return neg();",
		  "    }",
		  "    modnum operator+ () const {",
		  "        return modnum(*this);",
		  "    }",
		  " ",
		  "    modnum& operator ++ () {",
		  "        v ++;",
		  "        if (v == MOD) v = 0;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator -- () {",
		  "        if (v == 0) v = MOD;",
		  "        v --;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator += (const modnum& o) {",
		  "        v -= MOD-o.v;",
		  "        v = (v < 0) ? v + MOD : v;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator -= (const modnum& o) {",
		  "        v -= o.v;",
		  "        v = (v < 0) ? v + MOD : v;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator *= (const modnum& o) {",
		  "        v = int32_t(ll(v) * ll(o.v) % MOD);",
		  "        return *this;",
		  "    }",
		  "    modnum& operator /= (const modnum& o) {",
		  "        return *this *= o.inv();",
		  "    }",
		  " ",
		  "    friend modnum operator ++ (modnum& a, int32_t) { modnum r = a; ++a; return r; }",
		  "    friend modnum operator -- (modnum& a, int32_t) { modnum r = a; --a; return r; }",
		  "    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
		  "    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
		  "    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
		  "    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }",
		  "};",
		  "using num = modnum<MOD>;",
		  "",
		  "",
		  "const int LimN = 1e5 + 5;",
		  "num fact[LimN], invf[LimN];",
		  "num powermod(const num &x, const int &n) {",
		  "    if (n == 0) return 1;",
		  "    if (n == 1) return x;",
		  "    num tmp = powermod(x, n / 2);",
		  "    return tmp * tmp * (n % 2 == 0 ? 1 : x);",
		  "}",
		  " ",
		  "void factorial(const int &lim) {",
		  "    fact[0] = 1;",
		  "    for (int i = 1; i <= lim; i++) fact[i] = fact[i - 1] * i;",
		  "    invf[lim] = powermod(fact[lim], MOD - 2);",
		  "    for (int i = lim - 1; i >= 0; i--) invf[i] = invf[i + 1] * (i + 1);",
		  "}",
		  " ",
		  "num C(const int &n, const int &k) {",
		  "    if (n < k) return 0;",
		  "    return fact[n] * invf[k] * invf[n - k];",
		  "}"
		],
		"description": "factorial"
	},
	"FenwickTreeDown": {
		"prefix": "@FenwickTreeDown",
		"body": [
		  "class FenwickTreeDown {",
		  "",
		  "private:",
		  "    int n;",
		  "    vector<int> v;",
		  "public:",
		  "    FenwickTreeDown(int _n = 0) {",
		  "        n = _n;",
		  "        v.assign(n + 1, 0);",
		  "    }",
		  "    void resize(int _n = 0) {",
		  "        n = _n;",
		  "        v.resize(n + 1, 0);",
		  "    }",
		  "    void reset() {",
		  "        for (int i = 1; i <= n; i++) v[i] = 0;",
		  "    }",
		  "    void update(int i, int val) {",
		  "        for (; i <= n; i += i & -i) {",
		  "            v[i] += val;",
		  "        }",
		  "    }",
		  "    int get(int i) {",
		  "        int ans = 0;",
		  "        for (; i >= 1; i -= i & -i) {",
		  "            ans += v[i];",
		  "        }",
		  "        return ans;",
		  "    }",
		  "",
		  "};"
		],
		"description": "FenwickTreeDown"
	},
	"FenwickTreeUp": {
		"prefix": "@FenwickTreeUp",
		"body": [
		  "class FenwickTreeUp {",
		  "",
		  "private:",
		  "    int n;",
		  "    vector<int> v;",
		  "public:",
		  "    FenwickTreeUp(int _n = 0) {",
		  "        n = _n;",
		  "        v.assign(n + 1, 0);",
		  "    }",
		  "    void resize(int _n = 0) {",
		  "        n = _n;",
		  "        v.resize(n + 1, 0);",
		  "    }",
		  "    void reset() {",
		  "        for (int i = 1; i <= n; i++) v[i] = 0;",
		  "    }",
		  "    void update(int i, int val) {",
		  "        for (; i >= 1; i -= i & -i) {",
		  "            v[i] += val;",
		  "        }",
		  "    }",
		  "    int get(int i) {",
		  "        int ans = 0;",
		  "        for (; i <= n; i += i & -i) {",
		  "            ans += v[i];",
		  "        }",
		  "        return ans;",
		  "    }",
		  "",
		  "};"
		],
		"description": "FenwickTreeUp"
	},
	"freopen": {
		"prefix": "@freopen",
		"body": [
		  "#ifndef ONLINE_JUDGE",
		  "freopen(\"ab.inp\", \"r\", stdin);",
		  "freopen(\"ab.out\", \"w\", stdout);",
		  "#else",
		  "// freopen(\"task.inp\", \"r\", stdin);",
		  "// freopen(\"task.out\", \"w\", stdout);",
		  "#endif"
		],
		"description": "freopen"
	},
	"hld": {
		"prefix": "@hld",
		"body": [
		  "const int LimN = 1e5 + 5;",
		  " ",
		  "int NumNode, timeDFS;",
		  "int chain[LimN], sz[LimN], high[LimN], BigChild[LimN], lab[LimN], par[LimN][LOG], LOG2[LimN];",
		  "vector<int> adj[LimN];",
		  "",
		  "",
		  "",
		  "void hld() {",
		  " ",
		  "    function<void(int, int)> DfsSz = [&](int u, int p) {",
		  "        sz[u] = 1;",
		  "        for (auto v : adj[u]) if (v != p) {",
		  "            high[v] = high[u] + 1;",
		  "            par[v][0] = u;",
		  "            DfsSz(v, u);",
		  "            sz[u] += sz[v];",
		  "            if (sz[BigChild[u]] < sz[v]) BigChild[u] = v;",
		  "        }",
		  "    };",
		  " ",
		  "    function<void(int, int)> dfs = [&](int u, int p) {",
		  "        if (BigChild[u]) { //BigChild[par[u][0]] == u",
		  "            lab[u] = ++timeDFS;",
		  "            chain[BigChild[u]] = chain[u];",
		  "            dfs(BigChild[u], u);",
		  "        }",
		  "        for (auto v : adj[u]) if (v != p && v != BigChild[u]) {",
		  "            dfs(v, u);",
		  "        }",
		  "    };",
		  "",
		  "    function<void()> RMQ = [&]() {",
		  "        for (int i = 2; i <= NumNode; i++) LOG2[i] = LOG2[i / 2] + 1;",
		  "        for (int j = 1; j < LOG; j++) {",
		  "            for (int i = 1; i <= NumNode; i++) {",
		  "                par[i][j] = par[par[i][j - 1]][j - 1];",
		  "            }",
		  "        } ",
		  "    };",
		  " ",
		  "    high[1] = 1;",
		  "    DfsSz(1, 0);    ",
		  "    dfs(1, 0); ",
		  "    RMQ();",
		  "",
		  "}",
		  "",
		  "// note: HeavyEdge is BigChild[u] == v with high[u] < high[v]",
		  "",
		  "int lca(int u, int v) {",
		  "",
		  "    if (high[u] < high[v]) swap(u, v);",
		  "    for (int i = LOG2[high[u] - high[v]]; i >= 0; i--) {",
		  "        if (high[par[u][i]] >= high[v]) {",
		  "            u = par[u][i];",
		  "        }",
		  "    }",
		  "    if (u == v) return u;",
		  "    for (int i = LOG2[high[u]]; i >= 0; i--) {",
		  "        if (par[u][i] != par[v][i]) {",
		  "            u = par[u][i];",
		  "            v = par[v][i];",
		  "        }",
		  "    }",
		  "    return par[u][0];",
		  "}",
		  "",
		  "",
		  "void UpdateBranch(int u, int p) {",
		  "    while (u != p) {",
		  "        int v = chain[u];",
		  "        if (u == v) {",
		  "            ",
		  "            u = par[u][0];",
		  "        }",
		  "        else {",
		  "            if (high[v] <= high[p]) {",
		  "                // lab[p], lab[par[u][0]] or lab[u]",
		  "                u = p; // u = par[p][0];",
		  "            }",
		  "            else {",
		  "                // lab[v], lab[par[u][0]] or lab[u]",
		  "                u = v; // u = par[v][0];",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "void UpdatePath(int u, int v) {",
		  "    int root = lca(u, v);",
		  "    UpdateBranch(u, root);",
		  "    UpdateBranch(v, root);",
		  "}",
		  "",
		  "int GetBranch(int u, int p) {",
		  "    int ans = -INF;",
		  "    while (u != p) {",
		  "        int v = chain[u];",
		  "        if (u == v) {",
		  "            ",
		  "            u = par[u][0];",
		  "        }",
		  "        else {",
		  "            if (high[v] <= high[p]) {",
		  "                // lab[p], lab[par[u][0]] or lab[u]",
		  "                u = p; // u = par[p][0];",
		  "            }",
		  "            else {",
		  "                // lab[v], lab[par[u][0]] or lab[u]",
		  "                u = v; // u = par[v][0];",
		  "            }",
		  "        }",
		  "    }",
		  "    return ans;",
		  "}",
		  "",
		  "int GetPath(int u, int v) {",
		  "    if (u == v) return 0;",
		  "    int root = lca(u, v);",
		  "    return max(GetBranch(u, root), GetBranch(v, root));",
		  "}",
		  "",
		  "void reset() {",
		  "    timeDFS = 0;",
		  "    for (int i = 1; i <= NumNode; i++) {",
		  "        chain[i] = i;",
		  "        lab[i] = 0;",
		  "        adj[i].clear();",
		  "        BigChild[i] = 0;",
		  "    }",
		  "}"
		],
		"description": "hld"
	},
	"invmodulo": {
		"prefix": "@invmodulo",
		"body": [
		  "pii ExtendedEuclid(int a, int b, int c) {",
		  "    int m = a, xm = 1;",
		  "    int n = b, xn = 0;",
		  "    int d = __gcd(a, b);",
		  "    while (n) {",
		  "        int q = m / n;",
		  "        int r = m - q * n;",
		  "        int xr = xm - q * xn;",
		  "        m = n; xm = xn;",
		  "        n = r; xn = xr;",
		  "    }",
		  "    int ansx = xm * c / d;",
		  "    int ansy = (d - a * xm) / b * c / d;",
		  "    return pii(ansx, ansy);",
		  "}",
		  "",
		  "int invmodulo(int a, int p) {",
		  "    assert(__gcd(a, p) == 1);",
		  "    auto [x, y] = ExtendedEuclid(a, p, 1);",
		  "    return (x % p + p) % p;",
		  "}"
		],
		"description": "invmodulo"
	},
	"IsPrime": {
		"prefix": "@IsPrime",
		"body": [
		  "bool IsPrime(int x) {",
		  "    if (x == 1 || x < 0) return false;",
		  "    if (x == 2 || x == 3) return true;",
		  "    if (x % 2 == 0 || x % 3 == 0) return false;",
		  "    for (int i = 5; i * i <= x; i += 6)",
		  "        if (x % i == 0 || x % ( i + 2) == 0) return false;",
		  "    return true;",
		  "}"
		],
		"description": "IsPrime"
	},
	"jump": {
		"prefix": "@jump",
		"body": [
		  "int jump(int u, int k) {",
		  "    for (int i = LOG2[k]; i >= 0; i--) if (k >= MASK(i)) {",
		  "        k -= MASK(i);",
		  "        u = par[u][i];",
		  "    }",
		  "    return u;",
		  "}"
		],
		"description": "jump"
	},
	"lb": {
		"prefix": "@lb",
		"body": [
		  "int lb(int a[], int n, int k) {",
		  "    int l = 1, r = n, mid, ans = n + 1;",
		  "    while (l <= r) {",
		  "        mid = (l + r) / 2;",
		  "        if (k <= a[mid]) {",
		  "            r = mid - 1;",
		  "            ans = mid;",
		  "        }",
		  "        else l = mid + 1;",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "lb"
	},
	"lca": {
		"prefix": "@lca",
		"body": [
		  "int lca(int u, int v) {",
		  "    if (high[u] < high[v]) swap(u, v);",
		  "    for (int i = LOG2[high[u] - high[v]]; i >= 0; i--) {",
		  "        if (high[par[u][i]] >= high[v]) {",
		  "            u = par[u][i];",
		  "        }",
		  "    }",
		  "    if (u == v) return u;",
		  "    for (int i = LOG2[high[u]]; i >= 0; i--) {",
		  "        if (par[u][i] != par[v][i]) {",
		  "            u = par[u][i];",
		  "            v = par[v][i];",
		  "        }",
		  "    }",
		  "    return par[u][0];",
		  "}"
		],
		"description": "lca"
	},
	"mathching": {
		"prefix": "@matching",
		"body": [
		  "int matchX[LimN], matchY[LimN], Q[LimN], T[LimN], m, n;",
		  "void Enlarge(int y) {",
		  "    int next, x;",
		  "    for(; y; y = next) {",
		  "        x = T[y];",
		  "        next = matchX[x];",
		  "        matchX[x] = y;",
		  "        matchY[y] = x;",
		  "    }",
		  "}",
		  "",
		  "",
		  "int BFS() {",
		  "    int l = 1, r = 0, i, u, v;",
		  "    for(i = 1; i <= m; i++) if (matchX[i] == 0) ",
		  "        Q[++r] = i;",
		  "",
		  "    for (i = 1; i <= n; i++) T[i] = 0;",
		  "",
		  "    while (l <= r) {",
		  "        u = Q[l++];",
		  "        for(auto v : adj[u]) {",
		  "            if (T[v] == 0) {",
		  "                T[v] = u;",
		  "                if (matchY[v] == 0) return v;",
		  "                else Q[++r] = matchY[v];",
		  "            }",
		  "        }",
		  "    }",
		  "    return 0;",
		  "}",
		  "",
		  "int calc() {",
		  "    int node;",
		  "    while (node = BFS()) Enlarge(node);",
		  "",
		  "    int res = 0;",
		  "    for (int i = 1; i <= m; i++) if (matchX[i]) {",
		  "        // cout << i << \" \" << matchX[i] << endl;",
		  "        res++;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  ""
		],
		"description": "mathching"
	},
	"matrix2": {
		"prefix": "@matrix",
		"body": [
		  "void add(int &x, const int &y) {",
		  "    x += y;",
		  "    if (x >= MOD) x -= MOD;",
		  "}",
		  "",
		  "struct matrix {",
		  "    vector<vector<int>> v;",
		  "    int NumRow, NumColumn;",
		  "    matrix(int _NumRow = 0, int _NumColumn = 0) {",
		  "        NumRow = _NumRow;",
		  "        NumColumn = _NumColumn;",
		  "        v.assign(NumRow + 5, vector<int>(NumColumn + 5, 0));",
		  "    }",
		  "};",
		  "",
		  "matrix operator * (const matrix &one, const matrix &two) {",
		  "",
		  "    matrix result(one.NumRow, two.NumColumn);",
		  "    for (int i = 1; i <= one.NumRow; i++) {",
		  "        for (int j = 1; j <= two.NumColumn; j++) {",
		  "            for (int k = 1; k <= one.NumColumn; k++) {",
		  "                add(result.v[i][j], one.v[i][k] * two.v[k][j] % MOD);",
		  "            }",
		  "        }",
		  "    }",
		  "    return result;",
		  "",
		  "}",
		  "",
		  "matrix power(matrix x, int n) {",
		  "    if (n == 1) return x;",
		  "    matrix tmp = power(x, n / 2);",
		  "    if (n % 2 == 0) return tmp * tmp;",
		  "    else return tmp * tmp * x;",
		  "}"
		],
		"description": "matrix2"
	},
	"MiinterRabin": {
		"prefix": "@MiinterRabin",
		"body": [
		  "int binpower(int base, int e, int mod) {",
		  "    int result = 1;",
		  "    base %= mod;",
		  "    while (e) {",
		  "        if (e & 1)",
		  "            result = result * base % mod;",
		  "        base = base * base % mod;",
		  "        e >>= 1;",
		  "    }",
		  "    return result;",
		  "}",
		  "",
		  "bool check_composite(int n, int a, int d, int s) {",
		  "    int x = binpower(a, d, n);",
		  "    if (x == 1 || x == n - 1)",
		  "        return false;",
		  "    for (int r = 1; r < s; r++) {",
		  "        x = x * x % n;",
		  "        if (x == n - 1)",
		  "            return false;",
		  "    }",
		  "    return true;",
		  "}",
		  "",
		  "bool MiinterRabin(int n) { // returns true if n is prime, else returns false.",
		  "    if (n < 2)",
		  "        return false;",
		  "",
		  "    int r = 0;",
		  "    int d = n - 1;",
		  "    while ((d & 1) == 0) {",
		  "        d >>= 1;",
		  "        r++;",
		  "    }",
		  "",
		  "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
		  "        if (n == a)",
		  "            return true;",
		  "        if (check_composite(n, a, d, r))",
		  "            return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": "MiinterRabin"
	},
	"nummod": {
		"prefix": "@nummod",
		"body": [
		  "template <typename T> T mod_inv_in_range(T a, T m) {",
		  "    // assert(0 <= a && a < m);",
		  "    T x = a, y = m;",
		  "    T vx = 1, vy = 0;",
		  "    while (x) {",
		  "        T k = y / x;",
		  "        y %= x;",
		  "        vy -= k * vx;",
		  "        std::swap(x, y);",
		  "        std::swap(vx, vy);",
		  "    }",
		  "    assert(y == 1);",
		  "    return vy < 0 ? m + vy : vy;",
		  "}",
		  " ",
		  "template <typename T> T mod_inv(T a, T m) {",
		  "    a %= m;",
		  "    a = a < 0 ? a + m : a;",
		  "    return mod_inv_in_range(a, m);",
		  "}",
		  " ",
		  "template <int32_t MOD_> struct modnum {",
		  "    static constexpr int32_t MOD = MOD_;",
		  "    static_assert(MOD_ > 0, \"MOD must be positive\");",
		  " ",
		  "    using ll = long long;",
		  " ",
		  "    int32_t v;",
		  " ",
		  "public:",
		  " ",
		  "    modnum() : v(0) {}",
		  "    modnum(ll v_) : v(int32_t(v_ % MOD)) { if (v < 0) v += MOD; }",
		  "    explicit operator int32_t() const { return v; }",
		  "    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int32_t(n); }",
		  "    friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }",
		  " ",
		  "    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
		  "    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
		  " ",
		  "    modnum inv() const {",
		  "        modnum res;",
		  "        res.v = mod_inv_in_range(v, MOD);",
		  "        return res;",
		  "    }",
		  "    friend modnum inv(const modnum& m) { return m.inv(); }",
		  "    modnum neg() const {",
		  "        modnum res;",
		  "        res.v = v ? MOD-v : 0;",
		  "        return res;",
		  "    }",
		  "    friend modnum neg(const modnum& m) { return m.neg(); }",
		  " ",
		  "    modnum operator- () const {",
		  "        return neg();",
		  "    }",
		  "    modnum operator+ () const {",
		  "        return modnum(*this);",
		  "    }",
		  " ",
		  "    modnum& operator ++ () {",
		  "        v ++;",
		  "        if (v == MOD) v = 0;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator -- () {",
		  "        if (v == 0) v = MOD;",
		  "        v --;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator += (const modnum& o) {",
		  "        v -= MOD-o.v;",
		  "        v = (v < 0) ? v + MOD : v;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator -= (const modnum& o) {",
		  "        v -= o.v;",
		  "        v = (v < 0) ? v + MOD : v;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator *= (const modnum& o) {",
		  "        v = int32_t(ll(v) * ll(o.v) % MOD);",
		  "        return *this;",
		  "    }",
		  "    modnum& operator /= (const modnum& o) {",
		  "        return *this *= o.inv();",
		  "    }",
		  " ",
		  "    friend modnum operator ++ (modnum& a, int32_t) { modnum r = a; ++a; return r; }",
		  "    friend modnum operator -- (modnum& a, int32_t) { modnum r = a; --a; return r; }",
		  "    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
		  "    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
		  "    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
		  "    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }",
		  "};",
		  "using num = modnum<MOD>;"
		],
		"description": "nummod"
	},
	"PersistantIT": {
		"prefix": "@PersistantIT",
		"body": [
		  "struct DataSeg {",
		  "    int sum = 0;",
		  "    DataSeg(int _sum = 0) {",
		  "        sum = _sum;",
		  "    }",
		  "     DataSeg operator + (const DataSeg &other) const {",
		  "        return DataSeg(sum + other.sum);",
		  "    }",
		  "    DataSeg operator - (const DataSeg &other) const {",
		  "        return DataSeg(sum - other.sum);",
		  "    }",
		  "};",
		  "",
		  "struct Node {",
		  "    int next[2];",
		  "    DataSeg val;",
		  "    Node(int _left = 0, int _right = 0, DataSeg _val = DataSeg()) {",
		  "        next[0] = _left;",
		  "        next[1] = _right;",
		  "        val = _val;",
		  "    } ",
		  "    void merge(const Node &a, const Node &b) {",
		  "        val = a.val + b.val;",
		  "    }",
		  "};",
		  "",
		  "class PersistantSegmentree {",
		  "",
		  "private:",
		  "    int n, NumNode;",
		  "    Node v[LimN * LOG];",
		  "     int update(int l, int r, int pos, int val, int old) {",
		  "        // cout << l << \" \" << r << old << endl;",
		  "        if (l == r) {",
		  "            NumNode++;",
		  "            v[NumNode].merge(Node(0, 0, DataSeg(val)), v[old]);",
		  "            // cout << l << \" \" << r << \"sum\" << v[NumNode].val.sum << endl;",
		  "            return NumNode;",
		  "        }",
		  "        int mid = (l + r) >> 1;",
		  "        int node = ++NumNode;",
		  "        // cout << node << l << \" \" << r << endl;",
		  "        if (pos <= mid) {",
		  "            v[node].next[0] = update(l, mid, pos, val, v[old].next[0]);;",
		  "            v[node].next[1] = v[old].next[1];",
		  "        }",
		  "        else {",
		  "            v[node].next[0] = v[old].next[0];",
		  "            v[node].next[1] = update(mid + 1, r, pos, val, v[old].next[1]);",
		  "        }",
		  "        v[node].merge(v[v[node].next[0]], v[v[node].next[1]]);",
		  "        // cout << l << \" \" << r << \"sum\" << v[node].val.sum << endl;",
		  "        return node;",
		  "    }",
		  "    int pos(int i, int j, int l, int r) {",
		  "        DataSeg ans = v[i].val + v[j].val;",
		  "        if (!ans.sum) return 0;",
		  "        if (l == r) return l;",
		  "        int mid = (l + r) >> 1;",
		  "        DataSeg ansl = v[v[i].next[0]].val + v[v[j].next[0]].val;",
		  "        if (ansl.sum) return pos(v[i].next[0], v[j].next[0], l, mid);",
		  "        DataSeg ansr = v[v[i].next[1]].val + v[v[j].next[1]].val;",
		  "        if (ansr.sum) return pos(v[i].next[1], v[j].next[1], mid + 1, r);",
		  "        return 0;",
		  "    }",
		  "    DataSeg get(int i, int l, int r, int sta, int fin) {",
		  "        if (sta > r || fin < l) return DataSeg();",
		  "        if (sta <= l && r <= fin) return v[i].val;",
		  "        int mid = (l + r) >> 1;",
		  "        return get(v[i].next[0], l, mid, sta, fin) + get(v[i].next[1], mid + 1, r, sta, fin);",
		  "    }",
		  "public:",
		  "    int ver[LimN];",
		  "    void resize(int _n) {",
		  "        n = _n;",
		  "        NumNode = 0;",
		  "    }",
		  "    int update(int pos, int val, int old) {",
		  "        return update(1, n, pos, val, old);",
		  "    }",
		  "    DataSeg get(int i, int sta, int fin) {",
		  "        return get(i, 1, n, sta, fin);",
		  "    }",
		  "",
		  "} PersistantIT;"
		],
		"description": "PersistantIT"
	},
	"power": {
		"prefix": "@power",
		"body": [
		  "int power(const int &x, const int &n) {",
		  "    if (n == 0) return 1;",
		  "    if (n == 1) return x;",
		  "    int tmp = power(x, n / 2);",
		  "    return tmp * tmp * (n % 2 == 0 ? 1 : x);",
		  "}"
		],
		"description": "power"
	},
	"powermod": {
		"prefix": "@powermod",
		"body": [
		  "template <typename T> T mod_inv_in_range(T a, T m) {",
		  "    // assert(0 <= a && a < m);",
		  "    T x = a, y = m;",
		  "    T vx = 1, vy = 0;",
		  "    while (x) {",
		  "        T k = y / x;",
		  "        y %= x;",
		  "        vy -= k * vx;",
		  "        std::swap(x, y);",
		  "        std::swap(vx, vy);",
		  "    }",
		  "    assert(y == 1);",
		  "    return vy < 0 ? m + vy : vy;",
		  "}",
		  " ",
		  "template <typename T> T mod_inv(T a, T m) {",
		  "    a %= m;",
		  "    a = a < 0 ? a + m : a;",
		  "    return mod_inv_in_range(a, m);",
		  "}",
		  " ",
		  "template <int32_t MOD_> struct modnum {",
		  "    static constexpr int32_t MOD = MOD_;",
		  "    static_assert(MOD_ > 0, \"MOD must be positive\");",
		  " ",
		  "    using ll = long long;",
		  " ",
		  "    int32_t v;",
		  " ",
		  "public:",
		  " ",
		  "    modnum() : v(0) {}",
		  "    modnum(ll v_) : v(int32_t(v_ % MOD)) { if (v < 0) v += MOD; }",
		  "    explicit operator int32_t() const { return v; }",
		  "    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int32_t(n); }",
		  "    friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }",
		  " ",
		  "    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
		  "    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
		  " ",
		  "    modnum inv() const {",
		  "        modnum res;",
		  "        res.v = mod_inv_in_range(v, MOD);",
		  "        return res;",
		  "    }",
		  "    friend modnum inv(const modnum& m) { return m.inv(); }",
		  "    modnum neg() const {",
		  "        modnum res;",
		  "        res.v = v ? MOD-v : 0;",
		  "        return res;",
		  "    }",
		  "    friend modnum neg(const modnum& m) { return m.neg(); }",
		  " ",
		  "    modnum operator- () const {",
		  "        return neg();",
		  "    }",
		  "    modnum operator+ () const {",
		  "        return modnum(*this);",
		  "    }",
		  " ",
		  "    modnum& operator ++ () {",
		  "        v ++;",
		  "        if (v == MOD) v = 0;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator -- () {",
		  "        if (v == 0) v = MOD;",
		  "        v --;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator += (const modnum& o) {",
		  "        v -= MOD-o.v;",
		  "        v = (v < 0) ? v + MOD : v;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator -= (const modnum& o) {",
		  "        v -= o.v;",
		  "        v = (v < 0) ? v + MOD : v;",
		  "        return *this;",
		  "    }",
		  "    modnum& operator *= (const modnum& o) {",
		  "        v = int32_t(ll(v) * ll(o.v) % MOD);",
		  "        return *this;",
		  "    }",
		  "    modnum& operator /= (const modnum& o) {",
		  "        return *this *= o.inv();",
		  "    }",
		  " ",
		  "    friend modnum operator ++ (modnum& a, int32_t) { modnum r = a; ++a; return r; }",
		  "    friend modnum operator -- (modnum& a, int32_t) { modnum r = a; --a; return r; }",
		  "    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
		  "    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
		  "    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
		  "    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }",
		  "};",
		  "using num = modnum<MOD>;",
		  "",
		  "",
		  "num powermod(const int &x, const int &n) {",
		  "    if (n == 0) return 1;",
		  "    if (n == 1) return x;",
		  "    num tmp = powermod(x, n / 2);",
		  "    return tmp * tmp * (n % 2 == 0 ? 1 : x);",
		  "}",
		  " ",
		  ""
		],
		"description": "powermod"
	},
	"RMQ": {
		"prefix": "@RMQ",
		"body": [
		  "void dfs(int u, int p) {",
		  "    sta[u] = ++timeDFS;",
		  "    for (auto v : adj[u]) if (v != p) {",
		  "        high[v] = high[u] + 1;",
		  "        par[v][0] = u;",
		  "        dfs(v, u);",
		  "    }",
		  "    fin[u] = timeDFS;",
		  "}",
		  "",
		  "void RMQ() {",
		  "    high[1] = 1;",
		  "    dfs(1, 0);",
		  "    for (int i = 2; i <= NumNode; i++) LOG2[i] = LOG2[i / 2] + 1;",
		  "    for (int j = 1; j < LOG; j++) {",
		  "        for (int i = 1; i <= NumNode; i++) {",
		  "            par[i][j] = par[par[i][j - 1]][j - 1];",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "RMQ"
	},
	"SegmentTree": {
		"prefix": "@SegmentTree",
		"body": [
		  "class SegmentTree {",
		  "",
		  "private:",
		  "    int n;",
		  "    vector<int> v, lazy;",
		  "",
		  "    void PushDown() {",
		  "        ",
		  "    }",
		  "",
		  "    void update(int i, int l, int r, int sta, int fin, int val) {",
		  "        if (sta > r || fin < l) return;",
		  "        if (sta <= l && r <= fin) {",
		  "",
		  "        }",
		  "        int mid = (l + r) / 2;",
		  "        update(i * 2, l, mid, sta, fin, val);",
		  "        update(i * 2 + 1, mid + 1, r, sta, fin, val)",
		  "    }",
		  "",
		  "    int get(int i, int l, int r, int sta, int fin) {",
		  "        if (sta > r || fin < l) return ___",
		  "        if (sta <= l && r <= fin) return v[i];",
		  "        int mid = (l + r) / 2;",
		  "        get(i * 2, l, mid);",
		  "        get(i * 2 + 1, mid + 1, r);",
		  "    }",
		  "",
		  "public:",
		  "    SegmentTree(int _n = 0) {",
		  "        n = _n;",
		  "        v.assign(n * 4, 0);",
		  "        lazy.assign(n * 4, 0);",
		  "    }",
		  "    void reset() {",
		  "        for (int i = 1; i <= 4 * n; i++) v[i] = lazy[i] = 0;",
		  "    }",
		  "    void resize(int _n = 0) {",
		  "        n = _n;",
		  "        v.assign(n * 4, 0);",
		  "        lazy.assign(n * 4, 0);",
		  "    }",
		  "    void update(int sta, int fin, int val) {",
		  "        update(1, 1, n, sta, fin, val);",
		  "    }",
		  "    int get(int sta, int fin) {",
		  "        return get(1, 1, n, sta, fin);",
		  "    }",
		  "",
		  "};"
		],
		"description": "SegmentTree"
	},
	"sinhcay": {
		"prefix": "@sinhcay",
		"body": [
		  "function<void(int, bool)> sinhcay = [&](int NumNode, bool weight) {",
		  "    vector<int> node;",
		  "    out << NumNode << endl;",
		  "    for (int i = 2; i <= NumNode; i++) node.pushb(i);",
		  "    random_shuffle(ALL(node));",
		  "    int total = 1;",
		  "    function<void(int)> dfs = [&](int u) {",
		  "        if (node.empty()) return;",
		  "        total--;",
		  "        int sz;",
		  "        sz = Rand((!total ? 1 : 0), SZ(node));",
		  "        total += sz;",
		  "        vector<int> child;",
		  "        for (int i = 1; i <= sz; i++) {",
		  "            int v = node.back();",
		  "            out << u << \" \" << v << \" \";",
		  "            if (weight) out << Rand(1, 10);",
		  "            out << endl; ",
		  "            child.pushb(v);",
		  "            node.pop_back();",
		  "        } ",
		  "        for (auto v : child) dfs(v);",
		  "    };",
		  "    dfs(1);",
		  "};"
		],
		"description": "sinhcay"
	},
	"sinhtest": {
		"prefix": "@sinhtest",
		"body": [
		  "// #pragma GCC optimize(\"O3,unroll-loops\")",
		  "// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
		  "#include <bits/stdc++.h>",
		  "#include <windows.h>",
		  "using namespace std;",
		  "// __builtin_popcount",
		  "// __builtin_ctz",
		  "#define int long long",
		  "#define pii pair<int, int>",
		  "#define duoble long double",
		  "#define endl '\\n'",
		  "#define fi first",
		  "#define se second",
		  "#define mapa make_pair",
		  "#define pushb push_back",
		  "#define pushf push_front",
		  "#define popb pop_back",
		  "#define popf pop_front",
		  "#define o_ ordered_",
		  "#define ins insert",
		  "#define era erase",
		  "#define pqueue priority_queue",
		  "#define minele min_element",
		  "#define maxele max_element",
		  "#define lb lower_bound // >=",
		  "#define ub upper_bound // >",
		  "#define debug cout << \"NO ERROR\", exit(0)",
		  "#define FAST ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
		  "#define MASK(i) (1LL << (i))",
		  "#define BIT(x, i) (((x) >> (i)) & 1)",
		  "#define ALL(v) v.begin(), v.end()",
		  "#define SZ(v) (int)v.size()",
		  "#define sqr(x) ((x) * (x))",
		  "",
		  "template<class X, class Y>",
		  "    bool minimize(X &x, const Y &y) {",
		  "        if (x > y) {",
		  "            x = y;",
		  "            return true;",
		  "        }",
		  "        return false;",
		  "    }",
		  "template<class X, class Y>",
		  "    bool maximize(X &x, const Y &y) {",
		  "        if (x < y) {",
		  "            x = y;",
		  "            return true;",
		  "        }",
		  "        return false;",
		  "    }",
		  "",
		  "mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());",
		  "",
		  "int Rand(const int &l, const int &r) {",
		  "    assert(l <= r);",
		  "    int sz = (r - l + 1);",
		  "    return l + rd() % sz;",
		  "}",
		  "",
		  "",
		  "const int MOD = 1e9 + 7; //998244353;",
		  "const int LOG = 18;",
		  "const int INF = 1e9 + 7;",
		  "const int d4x[4] = {-1, 1, 0, 0};",
		  "const int d4y[4] = {0, 0, 1, -1};",
		  "const char c4[4] = {'U', 'D', 'R', 'L'};",
		  "const int d8x[8] = {0, 1, 1, 1, 0, -1, -1, -1};",
		  "const int d8y[8] = {1, 1, 0, -1, -1, -1, 0, 1};",
		  "",
		  "",
		  "",
		  "",
		  "// #define LENGTH 1000005",
		  "// #define NMOD 2",
		  "// #define BASE 256",
		  "// const int HashMod[] = {(int)1e9 + 7, (int)1e9 + 2277, (int)1e9 + 5277, (int)1e9 + 8277, (int)1e9 + 9277};",
		  "",
		  "// #include <ext/pb_ds/assoc_container.hpp>",
		  "// #include <ext/pb_ds/tree_policy.hpp>",
		  "// using namespace __gnu_pbds;",
		  "// #define o_set tree<int, null_type,less<int>, rb_tree_tag, tree_order_statistics_node_update>",
		  "// *(s.find_by_order(2)) : 3rd element in the set i.e. 6",
		  "// s.order_of_key(25) : Count of elements strictly smaller than 25 is 4",
		  "",
		  "",
		  "",
		  "",
		  "/* Listen music of IU before enjoy my code */",
		  "",
		  "",
		  "",
		  "/* Authors: Nguyen Minh Huy from Le Quy Don high school for Gifted Students Da Nang */",
		  "",
		  "",
		  "signed main() {",
		  "    HANDLE cons;",
		  "    cons = GetStdHandle(STD_OUTPUT_HANDLE);",
		  "    SetConsoleTextAttribute(cons, 15);",
		  "    cout << \"Creating ab.exe\" << endl;",
		  "    system(\"g++ -g ab.cpp -o ab.exe\");",
		  "    cout << \"Creating ab_trau.exe\" << endl;",
		  "    system(\"g++ -g ab_trau.cpp -o ab_trau.exe\");",
		  "    cout << endl;",
		  "",
		  "    for (int iTest = 1; iTest <= 1e6; iTest++) {",
		  "        ofstream out(\"ab.inp\");",
		  "        cout << \"Test \" << iTest << \": \";",
		  "        //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv<<<<<<",
		  "          ",
		  "            ",
		  "",
		  "",
		  "        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<<<<<<",
		  "        out.close();",
		  "        ifstream checkempty(\"ab.inp\");",
		  "        if (checkempty.peek() == std::ifstream::traits_type::eof()) {",
		  "            cout << \"___EMPTY INPUT___\";",
		  "            break;",
		  "        }",
		  "        int time_begin = clock();",
		  "        if (system(\"ab.exe\") != 0) {",
		  "            SetConsoleTextAttribute(cons, 96);",
		  "            cout << \" RTE \";",
		  "            SetConsoleTextAttribute(cons, 15);",
		  "            system(\"pause\");",
		  "            continue;",
		  "        }",
		  "        int time_end = clock();",
		  "        system(\"ab_trau.exe\");",
		  "        int time_trau = clock();",
		  "        cout << time_end-time_begin << \"ms\";",
		  "",
		  "        if (time_end-time_begin > 1000) {",
		  "            SetConsoleTextAttribute(cons, 112);",
		  "            cout << \" TLE \";",
		  "            SetConsoleTextAttribute(cons, 15);",
		  "            system(\"pause\");",
		  "        }",
		  "        cout << \", \" << time_trau-time_end << \"ms: \";",
		  "        ",
		  "        SetConsoleTextAttribute(cons, 15);",
		  "        if (system(\"fc ab.out ab.ans\") != 0) {",
		  "            SetConsoleTextAttribute(cons, 64);",
		  "            cout << \" WRONG \" << endl;",
		  "            SetConsoleTextAttribute(cons, 15);",
		  "            system(\"pause\");",
		  "        } else {",
		  "            SetConsoleTextAttribute(cons, 160);",
		  "            cout << \" ACCEPTED \" << endl;",
		  "            SetConsoleTextAttribute(cons, 15);",
		  "        }",
		  "    }",
		  "    system(\"pause\");",
		  "    return 0;",
		  "}"
		],
		"description": "sinhtest"
	},
	"tarjan": {
		"prefix": "@tarjan",
		"body": [
		  "int low[LimN], num[LimN];",
		  "vector<int> adj[LimN];",
		  "stack<int> st;",
		  "",
		  "void dfs(int u) {",
		  "    num[u] = low[u] = ++timeDFS;",
		  "    st.push(u);",
		  "    for (auto v : adj[u]) {",
		  "        if (num[v]) {",
		  "            minimize(low[u], num[v]);",
		  "        }",
		  "        else {",
		  "            dfs(v);",
		  "            minimize(low[u], low[v]);",
		  "        }",
		  "    }",
		  "    if (low[u] == num[u]) {",
		  "        int v;",
		  "        do {",
		  "            v = st.top();",
		  "            st.pop();",
		  "            num[v] = INF;",
		  "        } while (v != u);",
		  "    }",
		  "}"
		],
		"description": "tarjan"
	},
	"Trie2": {
		"prefix": "@Trie",
		"body": [
		  "struct Trie {",
		  "    Trie* next[26];",
		  "    int cnt;",
		  "    bool finish;",
		  "    Trie() {",
		  "        for (int i = 0; i < 26; i++) next[i] = NULL;",
		  "        cnt = 0;",
		  "        finish = false;",
		  "    }",
		  "} TrieRoot;",
		  "",
		  "void insert(const string &s) {",
		  "    Trie* par = &TrieRoot;",
		  "    for (int i = 0; i < SZ(s); i++) {",
		  "        int c = s[i] - 'a';",
		  "        if (!par->next[c]) {",
		  "            par->next[c] = new Trie();",
		  "        }",
		  "        par = par->next[c];",
		  "    }",
		  "    par->cnt++;",
		  "    par->finish = true;",
		  "}",
		  "",
		  "int get(Trie &TrieRoot, const string &s) {",
		  "    Trie *par = &TrieRoot;",
		  "    for (int i = 0; i < SZ(s); i++) {",
		  "        int c = s[i] - 'a';",
		  "        if (!par->next[c]) return 0;",
		  "        par = par->next[c];",
		  "    }",
		  "    return par->cnt;",
		  "}"
		],
		"description": "Trie2"
	},
	"ub": {
		"prefix": "@ub",
		"body": [
		  "int ub(int a[], int n, int k) {",
		  "    int l = 1, r = n, mid, ans = n + 1;",
		  "    while (l <= r) {",
		  "        mid = (l + r) / 2;",
		  "        if (k < a[mid]) {",
		  "            r = mid - 1;",
		  "            ans = mid;",
		  "        }",
		  "        else l = mid + 1;",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "ub"
	},
	"z_function": {
		"prefix": "@z_function",
		"body": [
		  "vector<int> z_function(const string &s) {",
		  "    int n = SZ(s);",
		  "    vector<int> z(n);",
		  "    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
		  "        if (i <= r)",
		  "            z[i] = min (r - i + 1, z[i - l]);",
		  "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
		  "            ++z[i];",
		  "        if (i + z[i] - 1 > r)",
		  "            l = i, r = i + z[i] - 1;",
		  "    }",
		  "    return z;",
		  "}"
		],
		"description": "z_function"
	},
  /*
  #############################################
  */
  "xau_doi_xung_tam_i": {
    "prefix": "#manacher",
    "body": [
      "const int N = 1e5+5;",
      "int f[N];",
      "int manacher(const string &s) {",
      "    int n = s.size() * 2 - 1;",
      "    string a = string(n, '.');",
      "    for (int i = 0; i < n; i += 2) a[i] = s[i >> 1];",
      "",
      "    int l = 0, r = -1, center, res = 0;",
      "    for (int i = 0, j = 0; i < n; ++i) {",
      "        j = (i > r ? 0 : min(f[l + r - i], r - i)) + 1;",
      "        while (i - j >= 0 && i + j < n && a[i - j] == a[i + j]) ++j;",
      "        f[i] = --j;",
      "        if (i + j > r) {",
      "            r = i + j;",
      "            l = i - j;",
      "        }",
      "",
      "        int len = (f[i] + i % 2) / 2 * 2 + 1 - i % 2;",
      "        if (len > res) {",
      "            res = len;",
      "            center = i;",
      "        }",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "xau_doi_xung_tam_i"
  },  
  "prefixsum2d": {
    "prefix": "#pre2d",
    "body": [
      "int pre[N][N];",
      "int getsum(int x, int y, int u, int v) {",
      "    return pre[u][v] - pre[u][y - 1] - pre[x - 1][v] + pre[x - 1][y - 1];",
      "}",
      "    for (int i = 1; i <= n; ++i)",
      "        for (int j = 1; j <= n; ++j)",
      "            pre[i][j] = a[i][j] + pre[i][j - 1] + pre[i - 1][j] - pre[i - 1][j - 1];",
      ""
    ],
    "description": "prefixsum2d"
  },
  "convexhull": {
    "prefix": "#convexhull",
    "body": [
      "int n;",
      "II a[N];",
      "II operator + (const II &u, const II &v) {",
      "    return {u.fi + v.fi, u.se + v.se};",
      "}",
      "II operator - (const II &u, const II &v) {",
      "    return {u.fi - v.fi, u.se - v.se};",
      "}",
      "int operator % (const II &u, const II &v) {",
      "    return u.fi * v.fi + u.se * v.se;",
      "}",
      "int operator * (const II &u, const II &v) {",
      "    return u.fi * v.se - u.se * v.fi;",
      "}",
      "long double degree(const II &u, const II &v) {",
      "    return atan2(u * v, u % v) / M_PI * 180.0;",
      "}",
      "int ccw(const II &a, const II &b, const II &c) {",
      "    return (b - a) * (c - b);",
      "    // đi từ a đến b đến c, khúc ngoặc ở b là",
      "    // > 0 rẻ trái",
      "    // = 0 thẳng hàng",
      "    // < 0 rẻ phải",
      "}",
      "void grahamscan() {",
      "    sort(a + 1, a + n + 1, [] (const II &u, const II &v) {",
      "        return II(u.se, u.fi) < II(v.se, v.fi);",
      "    });",
      "    int j = 1;",
      "    for (int i = 2; i <= n; ++i)",
      "        if (a[i] != a[j])",
      "            a[++j] = a[i];",
      "    n = j;",
      "    sort(a + 2, a + n + 1, [] (const II &u, const II &v) {",
      "        int s = ccw(a[1], u, v);",
      "        if (s == 0) return u < v;",
      "        return s > 0;",
      "    });",
      "}",
      "II cvh[N];",
      "int m;",
      "void convexhull() {",
      "    m = 0;",
      "    for (int i = 1; i <= n; ++i) {",
      "        while (m >= 2 && ccw(cvh[m - 1], cvh[m], a[i]) <= 0)",
      "            --m;",
      "        cvh[++m] = a[i];",
      "    }",
      "    while (m >= 3 && ccw(cvh[m - 1], cvh[m], cvh[1]) <= 0)",
      "        --m;",
      "}",
      "int S(const II &a, const II &b, const II &c) {",
      "    return (a - c) * (b - c);",
      "}",
      "int S() {",
      "    int res = 0;",
      "    for (int i = 3; i <= m; ++i)",
      "        res += (cvh[i - 1] - cvh[1]) * (cvh[i] - cvh[1]);",
      "    return res;",
      "}",
      "bool inside(II p) {",
      "    if (p.se < cvh[1].se) return 0;",
      "    if (p == cvh[1]) return 1;",
      "    int l = 2, r = m, low = 0;",
      "    while (l <= r) {",
      "        int mid = l + r >> 1;",
      "        if (ccw(cvh[1], p, cvh[mid]) <= 0) {",
      "            low = mid;",
      "            l = mid + 1;",
      "        } else",
      "            r = mid - 1;",
      "    }",
      "    if (low == 0) return 0;",
      "    ",
      "    if (ccw(cvh[1], p, cvh[low]) == 0) {",
      "        return ((cvh[1].fi <= p.fi && p.fi <= cvh[low].fi)",
      "            || (cvh[1].fi >= p.fi && p.fi >= cvh[low].fi))",
      "            && ((cvh[1].se <= p.se && p.se <= cvh[low].se)",
      "            || (cvh[1].se >= p.se && p.se >= cvh[low].se));",
      "    }",
      "    if (low == m) return 0;",
      "",
      "    return ccw(cvh[low], p, cvh[low + 1]) <= 0;",
      "}"
    ],
    "description": "convexhull"
  },
  "ordered_set": {
    "prefix": "$Treap(ordered_set)",
    "body": [
      "class Treap {",
      "    struct Node {",
      "        int key, prior, size;",
      "        Node *l, *r;",
      "        Node(int key): key(key), prior(rand()), size(1), l(NULL), r(NULL) {}",
      "        ~Node() { delete l; delete r; }",
      "    };",
      "    int size(Node *x) { return x ? x->size : 0; }",
      "    void update(Node *x) {",
      "        if (!x) return;",
      "        x->size = size(x->l) + size(x->r) + 1;",
      "    }",
      "    Node* join(Node *l, Node *r) {",
      "        if (!l || !r) return l ? l : r;",
      "        if (l->prior < r->prior)",
      "            return l->r = join(l->r, r), update(l), l;",
      "        else",
      "            return r->l = join(l, r->l), update(r), r;",
      "    }",
      "    void split(Node *v, int x, Node* &l, Node* &r) {",
      "        if (!v)",
      "            l = r = NULL;",
      "        else if (v->key < x)",
      "            split(v->r, x, v->r, r), l = v;",
      "        else",
      "            split(v->l, x, l, v->l), r = v;",
      "        update(v);",
      "    }",
      "    int getKeyByOrder(Node *v, int k) {",
      "        int cnt = size(v->l);",
      "        if (k <= cnt) return getKeyByOrder(v->l, k);",
      "        if (k == cnt + 1) return v->key;",
      "        return getKeyByOrder(v->r, k - cnt - 1);",
      "    }",
      "    void show(Node *x) {",
      "        if (!x) return;",
      "        show(x->l);",
      "        cout << x->key << ' ';",
      "        show(x->r);",
      "    }",
      "    Node *root;",
      "public:",
      "    Treap(): root(NULL) {}",
      "    ~Treap() { delete root; }",
      "    bool insert(int x) {",
      "        Node *l, *mid, *r;",
      "        split(root, x, l, mid);",
      "        split(mid, x + 1, mid, r);",
      "        if (mid) {",
      "            root = join(join(l, mid), r);",
      "            return false;",
      "        }",
      "        root = join(join(l, new Node(x)), r);",
      "        return true;",
      "    }",
      "    bool erase(int x) {",
      "        Node *l, *mid, *r;",
      "        split(root, x, l, mid);",
      "        split(mid, x + 1, mid, r);",
      "        root = join(l, r);",
      "        if (mid) {",
      "            delete mid;",
      "            return true;",
      "        }",
      "        return false;",
      "    }",
      "    int getKeyByOrder(int x) { return getKeyByOrder(root, x); }",
      "    int countSmaller(int x) {",
      "        Node *l, *r;",
      "        split(root, x, l, r);",
      "        int res = size(l);",
      "        root = join(l, r);",
      "        return res;",
      "    }",
      "    int size() const { return root ? root->size : 0; }",
      "    void show() {",
      "        cout << \"{\";",
      "        show(root);",
      "        cout << \"}\\n\";",
      "    }",
      "};"
    ],
    "description": "ordered_set"
  },
  "flow_PushRelabel": {
    "prefix": "#flow_PushRelabel",
    "body": [
      "template <class T> struct Edge {",
      "    int from, to, index;",
      "    T cap, flow;",
      "    Edge(int from, int to, T cap, T flow, int index): from(from), to(to), cap(cap), flow(flow), index(index) {}",
      "};",
      "template <class T> struct PushRelabel {",
      "    int n;",
      "    vector <vector <Edge <T>>> adj;",
      "    vector <T> excess;",
      "    vector <int> dist, count;",
      "    vector <bool> active;",
      "    vector <vector <int>> B;",
      "    int b;",
      "    queue <int> Q;",
      "    PushRelabel (int n): n(n), adj(n) {}",
      "    void AddEdge (int from, int to, int cap) {",
      "        adj[from].push_back(Edge <T>(from, to, cap, 0, adj[to].size()));",
      "        if (from == to) {",
      "            adj[from].back().index++;",
      "        }",
      "        adj[to].push_back(Edge <T>(to, from, 0, 0, adj[from].size() - 1));",
      "",
      "    }",
      "    void Enqueue (int v) {",
      "        if (!active[v] && excess[v] > 0 && dist[v] < n) {",
      "            active[v] = true;",
      "            B[dist[v]].push_back(v);",
      "            b = max(b, dist[v]);",
      "        }",
      "    }",
      "    void Push (Edge <T> &e) {",
      "        T amt = min(excess[e.from], e.cap - e.flow);",
      "        if (dist[e.from] == dist[e.to] + 1 && amt > T(0)) {",
      "            e.flow += amt;",
      "            adj[e.to][e.index].flow -= amt;",
      "            excess[e.to] += amt;    ",
      "            excess[e.from] -= amt;",
      "            Enqueue(e.to);",
      "        }",
      "    }",
      "    void Gap (int k) {",
      "        for (int v = 0; v < n; v++) if (dist[v] >= k) {",
      "            count[dist[v]]--;",
      "            dist[v] = max(dist[v], n);",
      "            count[dist[v]]++;",
      "            Enqueue(v);",
      "        }",
      "    }",
      "    void Relabel (int v) {",
      "        count[dist[v]]--;",
      "        dist[v] = n;",
      "        for (auto e: adj[v]) if (e.cap - e.flow > 0) {",
      "            dist[v] = min(dist[v], dist[e.to] + 1);",
      "        }",
      "        count[dist[v]]++;",
      "        Enqueue(v);",
      "    }",
      "    void Discharge(int v) {",
      "        for (auto &e: adj[v]) {",
      "            if (excess[v] > 0) {",
      "                Push(e);",
      "            } else {",
      "                break;",
      "            }",
      "        }",
      "        if (excess[v] > 0) {",
      "            if (count[dist[v]] == 1) {",
      "                Gap(dist[v]); ",
      "            } else {",
      "                Relabel(v);",
      "            }",
      "        }",
      "    }",
      "    T GetMaxFlow (int s, int t) {",
      "        dist = vector <int>(n, 0), excess = vector<T>(n, 0), count = vector <int>(n + 1, 0), active = vector <bool>(n, false), B = vector <vector <int>>(n), b = 0;  ",
      "        for (auto &e: adj[s]) {",
      "            excess[s] += e.cap;",
      "        }",
      "        count[0] = n;",
      "        Enqueue(s);",
      "        active[t] = true;",
      "        while (b >= 0) {",
      "            if (!B[b].empty()) {",
      "                int v = B[b].back();",
      "                B[b].pop_back();",
      "                active[v] = false;",
      "                Discharge(v);",
      "            } else {",
      "                b--;",
      "            }",
      "        }",
      "        return excess[t];",
      "    }",
      "    T GetMinCut (int s, int t, vector <int> &cut);",
      "};",
      "",
      "bool solve() {",
      "    int n, m, s, t; cin >> n >> m; s = 1, t = n;",
      "",
      "    PushRelabel<int> flow = PushRelabel<int>(n);",
      "    while (m--) {",
      "        int u, v, c; cin >> u >> v >> c;",
      "        flow.AddEdge(u, v, c);",
      "        flow.AddEdge(v, u, c);",
      "    }",
      "    ",
      "    cout << flow.GetMaxFlow(1, n) << endl;",
      "    return 0;",
      "}"
    ],
    "description": "flow_PushRelabel"
  },
  "FordFulkerson": {
    "prefix": "#flow_FordFulkerson",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define nmax 1201",
      "#define mmax 120001",
      "#define oo 2147483647",
      "struct edge {int u, v, c, f;} e[2 * mmax];",
      "int n, m, s, t, fValue = 0, head[nmax], link[2 * mmax];",
      "int h[nmax], l[nmax], p[2 * mmax], d[nmax], le[2 * mmax], lm;",
      "void enter() {",
      "    cin >> n >> m >> s >> t;",
      "    for (int u, v, c, i = 1; i <= m; i++) {",
      "        cin >> u >> v >> c;",
      "        e[i] = {u, v, c, 0};",
      "        e[i + m] = {v, u, 0, 0};",
      "    }",
      "    memset(head, 0, sizeof head);",
      "    for (int i = 1; i <= 2 * m; i++) {",
      "        link[i] = head[e[i].u];",
      "        head[e[i].u] = i;",
      "    }",
      "}",
      "",
      "bool BFS() {",
      "    queue<int> q;",
      "    q.push(s);",
      "    memset(d, -1, sizeof d);",
      "    d[s] = lm = 0;",
      "    while (q.size()) {",
      "        int u = q.front();",
      "        q.pop();",
      "        if (u == t) continue;",
      "        for (int i = head[u]; i; i = link[i]) {",
      "            int v = e[i].v, c = e[i].c, f = e[i].f;",
      "            if (c <= f) continue;",
      "            if (d[v] >= 0) {",
      "                if (d[v] == d[u] + 1)",
      "                    le[++lm] = i;",
      "            } else {",
      "                d[v] = d[u] + 1;",
      "                q.push(v);",
      "                le[++lm] = i;",
      "            }",
      "        }",
      "    }",
      "    return d[t] >= 0;",
      "",
      "}",
      "",
      "int TideCycle() {",
      "    if (!BFS()) return 0;",
      "    memset(h, 0, sizeof h);",
      "    h[s] = oo;",
      "    for (int j = 1; j <= lm; j++) {",
      "        int i = le[j];",
      "        p[i] = min(e[i].c - e[i].f, h[e[i].u]);",
      "        h[e[i].v] += p[i];",
      "    }",
      "    if (!h[t]) return 0;",
      "    memset(l, 0, sizeof l);",
      "    l[t] = h[t];",
      "    for (int j = lm; j >= 1; j--) {",
      "        int i = le[j];",
      "        p[i] = min(p[i], min(h[e[i].u] - l[e[i].u], l[e[i].v]));",
      "        l[e[i].v] -= p[i];",
      "        l[e[i].u] += p[i];",
      "    }",
      "    memset(h, 0, sizeof h);",
      "    h[s] = l[s];",
      "    for (int j = 1; j <= lm; j++) {",
      "        int i = le[j];",
      "        p[i] = min(p[i], h[e[i].u]);",
      "        h[e[i].u] -= p[i];",
      "        h[e[i].v] += p[i];",
      "        e[i].f += p[i];",
      "        e[i > m ? i - m : i + m].f -= p[i];",
      "    }",
      "    return h[t];",
      "}",
      "",
      "void TidalFlow() {",
      "    while (TideCycle())",
      "        fValue += h[t];",
      "    cout << fValue << '\\n';",
      "}",
      "int main() {",
      "    ios::sync_with_stdio(0);",
      "    cin.tie(0); cout.tie(0);",
      "    enter();",
      "    TidalFlow();",
      "}"
    ],
    "description": "FordFulkerson"
  },
  "digit_pair_2number": {
    "prefix": "#dp_digit2",
    "body": [
      "#define II pair<int,int>",
      "#define fi first",
      "#define se second",
      "const int MOD = 1e9+7;",
      "string L, R;",
      "const int N = 5e4+5;",
      "II dp[N][2][2][2][2];",
      "bool vis[N][2][2][2][2];",
      "II calc(int i, bool upp1, bool low1, bool upp2, bool low2) {",
      "    if (i < 0)",
      "        return {1, 0};",
      "    if (vis[i][upp1][low1][upp2][low2])",
      "        return dp[i][upp1][low1][upp2][low2];",
      "    vis[i][upp1][low1][upp2][low2] = 1;",
      "    int l1 = (upp1 ? 0 : L[i]-'0');",
      "    int r1 = (low1 ? 9 : R[i]-'0');",
      "    int l2 = (upp2 ? 0 : L[i]-'0');",
      "    int r2 = (low2 ? 9 : R[i]-'0');",
      "    II res = {0, 0};",
      "    for (int c = l1; c <= r1; ++c)",
      "    for (int d = l2; d <= r2; ++d) {",
      "        II tmp = calc(i-1, upp1 | (c != l1), low1 | (c != r1), ",
      "                        upp2 | (d != l2), low2 | (d != r2));",
      "        res.fi += tmp.fi;",
      "        res.se += tmp.se + tmp.fi * abs(c - d);",
      "        res.fi %= MOD;",
      "        res.se %= MOD;",
      "    }",
      "    dp[i][upp1][low1][upp2][low2] = res;",
      "    return res;",
      "}",
      "",
      "bool solve() {",
      "    cin >> L >> R;",
      "    reverse(L.begin(), L.end());",
      "    reverse(R.begin(), R.end());",
      "    while (L.size() < R.size()) L += \"0\";",
      "",
      "    cout << calc(L.size()-1, 0, 0, 0, 0).se;",
      "    return 0;",
      "}"
    ],
    "description": "digit_pair_2number"
  },
  "setbit": {
    "prefix": "#setbit",
    "body": [
      "int set1(int msk, int l, int r) {",
      "    int len = r-l+1;",
      "    int w = (1ll << len) - 1;",
      "    int nxt = msk | (w << l);",
      "    return nxt;",
      "}",
      "int set0(int msk, int l, int r) {",
      "    int len = r-l+1;",
      "    int w = (1ll << len) - 1;",
      "    int nxt = msk & ~(w << l);",
      "    return nxt;",
      "}"
    ],
    "description": "setbit"
  },
  "heavy light decomposition O(log)": {
    "prefix": "$hld",
    "body": [
      "const int N = 2e5+5, K = 18;",
      "int n, a[N];",
      "vector<int> adj[N];",
      " ",
      "int par[N][K], dep[N];",
      "int sz[N], maxsz[N], maxnd[N];",
      "void dfssize(int u, int p) {",
      "    sz[u] = 1;",
      "    for (int v: adj[u]) if (v != p) {",
      "        par[v][0] = u;",
      "        dep[v] = dep[u] + 1;",
      "        dfssize(v, u);",
      "        sz[u] += sz[v];",
      "        if (maxi(maxsz[u], sz[v]))",
      "            maxnd[u] = v;",
      "    }",
      "}",
      " ",
      "int timeDfs;",
      "int num[N], head[N];",
      "void dfshld(int u) {",
      "    num[u] = ++timeDfs;",
      "    if (!head[u]) head[u] = u;",
      " ",
      "    if (maxsz[u]) {",
      "        head[maxnd[u]] = head[u];",
      "        dfshld(maxnd[u]);",
      "    }",
      " ",
      "    for (int v: adj[u])",
      "        if (v != par[u][0] && v != maxnd[u])",
      "            dfshld(v);",
      "}",
      " ",
      "int lca(int u, int v) {",
      "    if (dep[u] < dep[v]) swap(u, v);",
      " ",
      "    for (int i = K-1; i >= 0; --i)",
      "        if (dep[par[u][i]] >= dep[v])",
      "            u = par[u][i];",
      "    ",
      "    if (u == v) return u;",
      " ",
      "    for (int i = K-1; i >= 0; --i)",
      "        if (par[u][i] != par[v][i])",
      "            u = par[u][i], v = par[v][i];",
      "    ",
      "    return par[u][0];",
      "}",
      " ",
      "int seg[N*4];",
      "void update(int pos, int val, int id = 1, int l = 1, int r = n) {",
      "    if (l == r) {",
      "        seg[id] = val;",
      "        return;",
      "    }",
      "    int mid = l + r >> 1;",
      "    if (pos <= mid) update(pos, val, id << 1, l, mid);",
      "    else update(pos, val, id << 1 | 1, mid+1, r);",
      "    seg[id] = max(seg[id << 1], seg[id << 1 | 1]);",
      "}",
      "int get(int u, int v, int id = 1, int l = 1, int r = n) {",
      "    if (r < u || l > v) return -1e18;",
      "    if (u <= l && r <= v) return seg[id];",
      "    int mid = l + r >> 1;",
      "    return max(",
      "        get(u, v, id << 1, l, mid),",
      "        get(u, v, id << 1 | 1, mid+1, r)",
      "    );",
      "}",
      " ",
      "int path(int u, int p) {",
      "    if (u == p) return a[u];",
      "    int res = -1e18;",
      "    while (dep[u] >= dep[p]) {",
      "        if (u == head[u]) {",
      "            res = max(res, a[u]);",
      "            u = par[u][0];",
      "        }",
      "        if (dep[head[u]] > dep[p]) {",
      "            maxi(res, get(num[head[u]], num[u]));",
      "            u = par[head[u]][0];",
      "        } else {",
      "            maxi(res, get(num[p], num[u]));",
      "            return res;",
      "        }",
      "    }",
      "    return res;",
      "}",
      "bool solve() {",
      "    int q; cin >> n >> q;",
      "    for (int i = 1; i <= n; ++i) cin >> a[i];",
      "    for (int i = 1; i < n; ++i) {",
      "        int u, v; cin >> u >> v;",
      "        adj[u].push_back(v);",
      "        adj[v].push_back(u);",
      "    }",
      "    dep[0] = -1;",
      "    dfssize(1, 0);",
      "    dfshld(1);",
      "    for (int j = 1; j < K; ++j)",
      "        for (int i = 1; i <= n; ++i)",
      "            par[i][j] = par[par[i][j-1]][j-1];",
      " ",
      "    // for (int i = 1; i <= n; ++i) cout << num[i] << ' ' << head[i] << ' ' << maxnd[i] << '\\n';",
      "    // for (int i = 1; i <= n; ++i) cout << get(num[i], num[i]) << '\\n';",
      "    for (int i = 1; i <= n; ++i) update(num[i], a[i]);",
      " ",
      "    while (q--) {",
      "        int typ, x, y; cin >> typ >> x >> y;",
      "        if (typ == 1) {",
      "            update(num[x], y);",
      "            a[x] = y;",
      "        }",
      "        else {",
      "            int p = lca(x, y);",
      "            cout << max(path(x, p), path(y, p)) << ' ';",
      "        }",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "heavy light decomposition O(log)"
  },
  "update_path_tree_O(n)": {
    "prefix": "#path",
    "body": [
      "int par[N], dep[N], sz[N];",
      " ",
      "void build(int u) {",
      "    sz[u] = 1;",
      "    for (int v: adj[u]) {",
      "        if (v != par[u]) {",
      "            par[v] = u;",
      "            dep[v] = dep[u] + 1;",
      "            build(v);",
      "            sz[u] += sz[v];",
      "        }",
      "    }",
      "}",
      "void update(int u) {",
      "    ",
      "}",
      "int path(int u, int v) {",
      "    if (dep[u] < dep[v]) swap(u, v);",
      "    update(u);",
      "    while (dep[u] > dep[v]) {",
      "        u = par[u];",
      "        update(u);",
      "    }",
      "    if (u == v) return u;",
      "    update(v);",
      "    while (u != v) {",
      "        u = par[u];",
      "        v = par[v];",
      "        update(u);",
      "        if (u != v) update(v);",
      "    }",
      "    return u;",
      "}"
    ],
    "description": "update_path_tree_O(n)"
  },
  "lucas": {
    "prefix": "#nCr_big",
    "body": [
      "void getRepresentation(int n, vector<int> &res) {",
      "    while (n > 0) {",
      "        res.push_back(n % MOD);",
      "        n /= MOD;",
      "    }",
      "}",
      "int f[MOD], g[MOD];",
      "int C(int k, int n) {",
      "    if (k > n) return 0;",
      "    return f[n] * g[k] % MOD * g[n-k] % MOD;",
      "}",
      "int nCr(int k, int n) {",
      "    vector<int> x, y;",
      "    x.clear(); y.clear();",
      "    getRepresentation(n, x);",
      "    getRepresentation(k, y);",
      "    int res = 1;",
      "    for (int i = 0; i < y.size(); ++i) {",
      "        res *= C(y[i], x[i]);",
      "        res %= MOD;",
      "    }",
      "    return res;",
      "}",
      "void prepare() {",
      "    f[0] = g[0] = 1;",
      "    for (int i = 1; i < MOD; ++i)",
      "        f[i] = f[i-1] * i % MOD;",
      "    g[MOD-1] = Pow(f[MOD-1], MOD-2);",
      "    for (int i = MOD-2; i > 0; --i)",
      "        g[i] = g[i+1] * (i+1) % MOD;",
      "}"
    ],
    "description": "lucas"
  },
  "bit2d_update_rectangle": {
    "prefix": "$bit2d_rect",
    "body": [
          "const int N = 1e3+5;",
          "int bit[4][N][N];",
          "void update(int no, int x, int y, int val) {",
          "    for (; x < N; x += x & (-x))",
          "        for (int i = y; i < N; i += i & (-i))",
          "            bit[no][x][i] += val;",
          "}",
          "int query(int no, int x, int y) {",
          "    int sum = 0;",
          "    for (; x > 0; x -= x & (-x))",
          "        for (int i = y; i > 0; i -= i & (-i))",
          "            sum += bit[no][x][i];",
          "    return sum;",
          "}",
          "void update(int x, int y, int u, int v, int val) {",
          "    update(0, x, y, val);",
          "    update(0, x, v+1, -val);",
          "    update(0, u+1, y, -val);",
          "    update(0, u+1, v+1, val);",
          "    update(1, x, y, val*(1-y));",
          "    update(1, x, v+1, val*v);",
          "    update(1, u+1, y, val*(y-1));",
          "    update(1, u+1, v+1, -val*v);",
          "    update(2, x, y, val*(1-x));",
          "    update(2, x, v+1, (x-1)*val);",
          "    update(2, u+1, y, val*u);",
          "    update(2, u+1, v+1, -u*val);",
          "    update(3, x, y, (x-1)*(y-1)*val);",
          "    update(3, x, v+1, -v*(x-1)*val);",
          "    update(3, u+1, y, -u*(y-1)*val);",
          "    update(3, u+1, v+1, u*v*val);",
          "}",
          "int get(int x, int y) {",
          "    return query(0, x, y)*x*y + query(1, x, y)*x",
          "        + query(2, x, y)*y + query(3, x, y);",
          "}",
          "int getsum(int x, int y, int u, int v) {",
          "    return get(u, v) - get(x-1, v)",
          "        - get(u, y-1) + get(x-1, y-1);",
          "}"
    ],
    "description": "bit2d_update_rectangle"
  },
  "bit2d_update_point": {
    "prefix": "$bit2d_point",
    "body": [
      "const int N = 1e3+5;",
      "int bit[N][N];",
      "void update(int i, int jj, int val) {",
      "    for (; i < N; i += i & -i)",
      "        for (int j = jj; j < N; j += j & -j)",
      "            bit[i][j] += val;",
      "}",
      "int get(int i, int jj) {",
      "    int res = 0;",
      "    for (; i > 0; i -= i & -i)",
      "        for (int j = jj; j > 0; j -= j & -j)",
      "            res += bit[i][j];",
      "    return res;",
      "}",
      "int get(int u, int l, int d, int r) {",
      "    return get(d, r) - get(d, l-1) - get(u-1, r) + get(u-1, l-1);",
      "}"
    ],
    "description": "bit2d_update_point"
  },
  "strongly connected": {
    "prefix": "#tpltm_SCC",
    "body": [
      "int num[N], low[N];",
      "int cntDfs, scc;",
      "stack<int> st;",
      "int id[N];",
      "void tarjan(int u) {",
      "    low[u] = num[u] = ++cntDfs;",
      "    st.push(u);",
      "    for (II e: adj[u]) { int v = e.fi;",
      "        if (!num[v]) {",
      "            tarjan(v);",
      "            low[u] = min(low[u], low[v]);",
      "        }",
      "        else low[u] = min(low[u], num[v]);",
      "    }",
      "    if (num[u] == low[u]) {",
      "        int v; ++scc;",
      "        do {",
      "            v = st.top();",
      "            st.pop();",
      "            num[v] = low[v] = 1e18;",
      "            id[v] = scc;",
      "        } while (v != u);",
      "    }",
      "}"
    ],
    "description": "strongly connected"
  },
  "BIT": {
    "prefix": "$bit",
    "body": [
      "int bit[N];",
      "void update(int i, int val) {",
      "    for (; i < N; i += i & -i)",
      "        bit[i] += val;",
      "}",
      "int get(int i) {",
      "    int res = 0;",
      "    for (; i > 0; i -= i & -i)",
      "        res += bit[i];",
      "    return res;",
      "}",
      "int get(int l, int r) {",
      "    return get(r) - get(l-1);",
      "}"
    ],
    "description": "BIT"
  },
  "Combinations": {
    "prefix": "#nCr",
    "body": [
      "int f[N], g[N];",
      "int C(int k, int n) {",
      "    return f[n] * g[k] % MOD * g[n-k] % MOD;",
      "}",
      "void prepare() {",
      "    f[0] = g[0] = 1;",
      "    for (int i = 1; i < N; ++i)",
      "        f[i] = f[i-1] * i % MOD;",
      "    g[N-1] = Pow(f[N-1], MOD-2, MOD);",
      "    for (int i = N-2; i > 0; --i)",
      "        g[i] = g[i+1] * (i+1) % MOD;",
      "}"
    ],
    "description": "Combinations"
  },
  "bao_loi": {
    "prefix": "#convexhull",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define int long long",
      "#define II pair<int,int>",
      "#define x first",
      "#define y second",
      "",
      "bool tright(II a, II b, II c) {",
      "    return a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) < 0; ",
      "}",
      "bool tleft(II a, II b, II c) {",
      "    return a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) > 0; ",
      "}",
      "",
      "const int N = 1e5+5;",
      "int n;",
      "II a[N];",
      "",
      "void ConvexHull() {",
      "    if (n == 1) return;",
      "    sort(a, a + n);",
      "    vector<II> up, down;",
      "    II p1 = a[0], p2 = a[n-1];",
      "    up.push_back(p1), down.push_back(p1);",
      "    for (int i = 1; i < n; ++i) {",
      "        if (i == n-1 || tright(p1, a[i], p2)) {",
      "            while (up.size() >= 2 && !tright(up[up.size() - 2], up.back(), a[i]))",
      "                up.pop_back();",
      "            up.push_back(a[i]);",
      "        }",
      "        if (i == n-1 || tleft(p1, a[i], p2)) {",
      "            while (down.size() >= 2 && !tleft(down[down.size() - 2], down.back(), a[i]))",
      "                down.pop_back();",
      "            down.push_back(a[i]);",
      "        }",
      "    }",
      "    n = 0;",
      "    for (int i = 0; i < up.size(); ++i)",
      "        a[n++] = up[i];",
      "    for (int i = down.size() - 2; i > 0; --i)",
      "        a[n++] = down[i];",
      "}",
      "int s(II a, II b, II c) {",
      "    return abs((b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y));",
      "}",
      "signed main() {",
      "    #ifndef ONLINE_JUDGE",
      "    freopen(\"lmhconvex.inp\", \"r\", stdin);",
      "    freopen(\"lmhconvex.out\", \"w\", stdout);",
      "    #endif",
      "    cin >> n;",
      "    for (int i = 0; i < n; ++i)",
      "        cin >> a[i].y >> a[i].x;",
      "",
      "    ConvexHull();",
      "",
      "    cout << n << '\\n';",
      "    int ans = 0;",
      "    for (int i = 2; i < n; ++i)",
      "        ans += s(a[0], a[i], a[i-1]);",
      "    cout << ans / 2 << (ans & 1 ? \".5\" : \".0\") << \"\\n\";",
      "",
      "    for (int i = 0; i < n; ++i)",
      "        cout << a[i].y << ' ' << a[i].x << '\\n';",
      "    return 0;",
      "}"
    ],
    "description": "bao_loi"
  },
  "DinicFlow": {
    "prefix": "#flow_dinic",
    "body": [
      "struct edge {",
      "    int u, v, c, f;",
      "};",
      "struct Dinic {",
      "    int n, s, t;",
      "    vector<vector<int>> adj;",
      "    vector<edge> e;",
      "    vector<int> cur, dist;",
      "    Dinic() {}",
      "    Dinic(int _n, int _s, int _t) {",
      "        n = _n; s = _s; t = _t;",
      "        adj.resize(n+1);",
      "        cur.resize(n+1);",
      "        dist.resize(n+1);",
      "    }",
      "    void addedge(int u, int v, int c) {",
      "        adj[u].push_back(e.size()); e.push_back({u, v, c, 0});",
      "        adj[v].push_back(e.size()); e.push_back({v, u, 0, 0});",
      "    }",
      "    bool bfs() {",
      "        fill(dist.begin(), dist.end(), -1);",
      "        queue<int> q; q.push(s); dist[s] = 0;",
      "        while (!q.empty()) {",
      "            int u = q.front(); q.pop();",
      "            for (int i = 0; i < adj[u].size(); ++i) {",
      "                int id = adj[u][i], v = e[id].v;",
      "                if (dist[v] < 0 && e[id].f < e[id].c) {",
      "                    dist[v] = dist[u] + 1;",
      "                    q.push(v);",
      "                }",
      "            }",
      "        }",
      "        return dist[t] >= 0;",
      "    }",
      "    int dfs(int u, int f) {",
      "        if (!f) return 0;",
      "        if (u == t) return f;",
      "        for (; cur[u] < adj[u].size(); ++cur[u]) {",
      "            int id = adj[u][cur[u]], v = e[id].v;",
      "            if (dist[v] != dist[u] + 1) continue;",
      "            int delta = dfs(v, min(f, e[id].c - e[id].f));",
      "            if (delta) {",
      "                e[id].f += delta; e[id ^ 1].f -= delta;",
      "                return delta;",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "    int maxflow() {",
      "        int ans = 0;",
      "        while (bfs()) {",
      "            cur.assign(n+1, 0);",
      "            while (1) {",
      "                int delta = dfs(s, 1e18);",
      "                if (!delta) break;",
      "                ans += delta;",
      "            }",
      "        }",
      "        return ans;",
      "    }",
      "};"
    ],
    "description": "DinicFlow"
  },
  "indexed_set": {
    "prefix": "#indexed_set",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "typedef tree<int,null_type,less<int>,rb_tree_tag, tree_order_statistics_node_update> indexed_set;",
      ""
    ],
    "description": "indexed_set"
  },
  "bignumgspvh": {
    "prefix": "#bignum_GSVPH",
    "body": [
      "struct Bignum {",
      "    static const int BASE = (int)1e9;",
      "    static const int MAX_DIGIT = 5;",
      "    int digits[MAX_DIGIT], numDigit;",
      " ",
      "    Bignum(long long x = 0) {",
      "        numDigit = 0;",
      "        memset(digits, 0, sizeof digits);",
      "        if (x == 0) numDigit = 1;",
      "        while (x > 0) {",
      "            digits[numDigit++] = x % BASE;",
      "            x /= BASE;",
      "        }",
      "    }",
      " ",
      "    Bignum& operator += (const Bignum &x) {",
      "        maximize(numDigit, x.numDigit);",
      "        int carry = 0;",
      "        REP(i, numDigit) {",
      "            digits[i] += x.digits[i] + carry;",
      "            if (digits[i] >= BASE) {",
      "                digits[i] -= BASE;",
      "                carry = 1;",
      "            } else carry = 0;",
      "        }",
      "        if (carry > 0) digits[numDigit++] = carry;",
      "        return *this;",
      "    }",
      "    Bignum operator + (const Bignum &x) const {",
      "        Bignum res = *this;",
      "        return res += x;",
      "    }",
      " ",
      "    Bignum& operator -= (const Bignum &x) { // result should be guaranteed not to be negative.",
      "        int remain = 0;",
      "        REP(i, numDigit) {",
      "            digits[i] -= x.digits[i] + remain;",
      "            if (digits[i] < 0) {",
      "                digits[i] += BASE;",
      "                remain = 1;",
      "            } else remain = 0;",
      "        }",
      "        while (numDigit > 1 && digits[numDigit - 1] == 0) numDigit--;",
      "        return *this;",
      "    }",
      "    Bignum operator - (const Bignum &x) const {",
      "        Bignum res = *this;",
      "        return res -= x;",
      "    }",
      " ",
      "    Bignum operator * (const Bignum &x) const {",
      "        if (*this == 0 || x == 0) return Bignum(0);",
      " ",
      "        Bignum res;",
      "        REP(i, numDigit) REP(j, x.numDigit) {",
      "            long long tmp = 1LL * digits[i] * x.digits[j];",
      "            int pos = i + j;",
      "            while (tmp > 0) {",
      "                tmp += res.digits[pos];",
      "                res.digits[pos] = tmp % BASE;",
      "                tmp /= BASE;",
      "                pos++;",
      "            }",
      "        }",
      "        res.numDigit = numDigit + x.numDigit - 1;",
      "        if (res.digits[res.numDigit] > 0) res.numDigit++;",
      "        return res;",
      "    }",
      " ",
      "    #define COMPARE(x, y) (((x) > (y)) - ((x) < (y)))",
      "    int compare(const Bignum &x) const {",
      "        if (numDigit != x.numDigit) return COMPARE(numDigit, x.numDigit);",
      "        FORD(i, numDigit - 1, 0) if (digits[i] != x.digits[i]) return COMPARE(digits[i], x.digits[i]);",
      "        return 0;",
      "    }",
      " ",
      "    #define DEFINE_OPERATOR(o) bool operator o (const Bignum &x) const { return compare(x) o 0; }",
      "    DEFINE_OPERATOR(>) DEFINE_OPERATOR(>=) DEFINE_OPERATOR(==)",
      "    DEFINE_OPERATOR(<) DEFINE_OPERATOR(<=) DEFINE_OPERATOR(!=)",
      "    #undef DEFINE_OPERATOR",
      " ",
      "    string toString(void) const {",
      "        string res;",
      "        REP(i, numDigit) {",
      "            int x = digits[i];",
      "            REP(love, 9) {",
      "                res.push_back('0' + x % 10);",
      "                x /= 10;",
      "            }",
      "        }",
      "        while (res.size() > 1 && res.back() == '0') res.pop_back();",
      "        reverse(ALL(res));",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "bignumgspvh"
  },
  "Maximum Independent Set": {
    "prefix": "#MIS",
    "body": [
      "#pragma GCC optimize(\"Ofast\")",
      "#pragma GCC target(\"sse3\",\"sse2\",\"sse\")",
      "#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")",
      "#pragma GCC target(\"f16c\")",
      "#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")",
      "#pragma loop_opt(on)",
      "#include <bitset>",
      "#include <cstdio>",
      "",
      "inline char readchar() {",
      "    constexpr int B = 1<<15;",
      "    static char buf[B], *p, *q;",
      "    if(p == q && (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF;",
      "    return *p++;",
      "}",
      "inline int nextint() {",
      "    int x = 0, c = readchar();",
      "    while(c < '0') c = readchar();",
      "    while(c >= '0') x=x*10+(c^'0'), c=readchar();",
      "    return x;",
      "}",
      "",
      "using namespace std;",
      "const int N = 80, inf = 1e9;",
      "using magic = bitset<N>;",
      "",
      "int n, m;",
      "magic g[N];",
      "int ans = inf;",
      "magic ans_mask;",
      "void dfs(int c, magic select, magic alive) {",
      "    if(c > ans) return;",
      "    // reduce",
      "    int mx = -1, mxDeg = -1;",
      "    for(int i = alive._Find_first(); i < n; i = alive._Find_next(i)) {",
      "        int deg = (alive & g[i]).count();",
      "        if(deg == 1) {",
      "            int j = (alive & g[i])._Find_first();",
      "            alive[i] = alive[j] = false;",
      "            select[j] = true;",
      "            dfs(c+1, select, alive);",
      "            return;",
      "        }",
      "        if(deg != 0 && deg > mxDeg)",
      "            mx = i, mxDeg = deg;",
      "    }",
      "    if(mx == -1) {",
      "        if (ans > c) {",
      "            ans = c;",
      "            ans_mask = select;",
      "        }",
      "        return;",
      "    }",
      "    alive[mx] = false;",
      "    select[mx] = true;",
      "    dfs(c+1, select, alive);",
      "    select[mx] = false;",
      "    magic adj = alive & g[mx];",
      "    dfs(c+adj.count(), select | adj, alive ^ adj);",
      "}",
      "signed main() {",
      "    n = nextint();",
      "    m = nextint();",
      "    for(int i = 0; i < m; i++) {",
      "        int a = nextint();",
      "        int b = nextint();",
      "        g[a][b] = g[b][a] = true;",
      "    }",
      "    magic select, alive;",
      "    for(int i = 0; i < n; i++) alive[i] = true;",
      "    dfs(0, select, alive);",
      "    printf(\"%d\\n\", n - ans);",
      "    bool first = true;",
      "    for (int i = 0; i < n; i++)",
      "        if (!ans_mask[i]) {",
      "            if (!first)",
      "                printf(\" \");",
      "            first = false;",
      "            printf(\"%d\", i);",
      "        }",
      "    printf(\"\\n\");",
      "}"
    ],
    "description": "Maximum Independent Set"
  },
  "lca_len_on_tree": {
    "prefix": "#LCA",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define int long long",
      "#define II pair<int,int>",
      "#define fi first",
      "#define se second",
      "",
      "const int N = 3e5+5, K = 20;",
      "int n, q;",
      "vector<II> adj[N];",
      "int dep[N], par[N][K], sum[N];",
      "",
      "void dfs(int u) {",
      "    for (II node: adj[u]) {",
      "        int v = node.fi, w = node.se;",
      "        if (v != par[u][0]) {",
      "            par[v][0] = u;",
      "            dep[v] = dep[u] + 1;",
      "            sum[v] = sum[u] + w;",
      "            dfs(v);",
      "        }",
      "    }",
      "}",
      "int lca(int u, int v) {",
      "    if (dep[u] < dep[v]) swap(u, v);",
      "",
      "    for (int i = K-1; i >= 0; --i)",
      "        if (dep[par[u][i]] >= dep[v])",
      "            u = par[u][i];",
      "    ",
      "    if (u == v) return u;",
      "",
      "    for (int i = K-1; i >= 0; --i)",
      "        if (par[u][i] != par[v][i]) {",
      "            u = par[u][i];",
      "            v = par[v][i];",
      "        }",
      "    ",
      "    return par[u][0];",
      "}",
      "signed main() {",
      "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
      "    freopen(\"distance.inp\", \"r\", stdin);",
      "    freopen(\"distance.out\", \"w\", stdout);",
      "",
      "    int subt; cin >> subt;",
      "",
      "    cin >> n;",
      "    for (int i = 1; i < n; ++i) {",
      "        int u, v, w; cin >> u >> v >> w;",
      "        adj[u].push_back({v, w});",
      "        adj[v].push_back({u, w});",
      "    }",
      "",
      "    dep[0] = -1;",
      "    dfs(1);",
      "    for (int j = 1; j < K; ++j)",
      "        for (int i = 1; i <= n; ++i)",
      "            par[i][j] = par[par[i][j-1]][j-1];",
      "",
      "    cin >> q;",
      "    while (q--) {",
      "        int u, v; cin >> u >> v;",
      "        cout << sum[u] + sum[v] - (sum[lca(u, v)] << 1) << '\\n';",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "lca_len_on_tree"
  },
  "khop_cau": {
    "prefix": "#tarjan",
    "body": [
      "vector<int> adj[N];",
      "int num[N], low[N];",
      "int cntDfs;",
      "int bridge, joint[N];",
      "void tarjan(int u, int p) {",
      "    low[u] = num[u] = ++cntDfs;",
      "    int ch = 0;",
      "    for (int v: adj[u]) if (v != p) {",
      "        if (!num[v]) {",
      "            tarjan(v, u);",
      "            low[u] = min(low[u], low[v]);",
      "            // ...",
      "            ++ch;",
      "            if (low[v] == num[v]) ++bridge;",
      "            if (u == p) {",
      "                if (ch > 1) joint[u] = 1;",
      "            }",
      "            else if (low[v] >= num[u]) joint[u] = 1;",
      "",
      "        } else low[u] = min(low[u], num[v]);",
      "    }",
      "}"
    ],
    "description": "khop_cau"
  },
  "Divide and Conquer DP": {
    "prefix": "#dp_dnc",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define int long long",
      "template<class X, class Y> bool mini(X& x, const Y y) {",
      "    if (x > y) return x = y, 1;",
      "    return 0;",
      "}",
      "const int N = 1e5+5, M = 55;",
      "int n, m;",
      "int a[N];",
      "int dp[M][N];",
      "int cnt[N];",
      "",
      "int u = 1, v = 0, res = 0;",
      "void update(int l, int r) {",
      "    while (v < r) res += cnt[a[++v]]++;",
      "    while (u > l) res += cnt[a[--u]]++;",
      "    while (v > r) res -= --cnt[a[v--]];",
      "    while (u < l) res -= --cnt[a[u++]];",
      "}",
      "void divide(int i, int l, int r, int optl, int optr) {",
      "    if (l > r) return;",
      "    int mid = l + r >> 1;",
      "    pair<int, int> best = {1e18, -1};",
      "    for (int k = optl; k <= min(mid, optr); ++k) {",
      "        update(k, mid);",
      "        best = min(best, {dp[i-1][k-1] + res, k});",
      "    }",
      "    dp[i][mid] = best.first;",
      "    int opt = best.second;",
      "    divide(i, l, mid-1, optl, opt);",
      "    divide(i, mid+1, r, opt, optr);",
      "}",
      "signed main() {",
      "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
      "    #ifndef ONLINE_JUDGE",
      "    freopen(\"MINSVAL.inp\", \"r\", stdin);",
      "    freopen(\"MINSVAL.out\", \"w\", stdout);",
      "    #endif",
      "    /*",
      "    https://lqdoj.edu.vn/problem/ltbminsval",
      "    chia dãy n thành m đoạn liên tiếp",
      "    giá trị 1 đoạn là số lượng cặp i < j mà a[i] = a[j]",
      "    tìm cách chia để tổng giá trị m đoạn là nhỏ nhất",
      "    */",
      "    cin >> n >> m;",
      "    for (int i = 1; i <= n; ++i) cin >> a[i];",
      "",
      "    memset(dp, 0x3f, sizeof dp);",
      "    for (int j = 1; j <= n; ++j) {",
      "        update(1, j);",
      "        dp[1][j] = res;",
      "    }",
      "",
      "    for (int i = 2; i <= m; ++i) {",
      "        divide(i, 1, n, 1, n);",
      "    }",
      "    cout << dp[m][n];",
      "    return 0;",
      "}",
      ""
    ],
    "description": "Divide and Conquer DP"
  },
  "dp_digit": {
    "prefix": "#dp_digit",
    "body": [
      "vector<int> L, R;",
      "void split(int x, vector<int> &a) {",
      "    while (x) {",
      "        a.push_back(x % 10);",
      "        x /= 10;",
      "    }",
      "}",
      "int dp[10][2][2][10*10];",
      "int calc(int i, bool upp, bool low, int sum) {",
      "    if (i < 0)",
      "        return ();",
      "    if (dp[i][upp][low][sum] > -1)",
      "        return dp[i][upp][low][sum];",
      "    int l = (upp ? 0 : L[i]);",
      "    int r = (low ? 9 : R[i]);",
      "    int res = 0;",
      "    for (int c = l; c <= r; ++c) {",
      "        res += calc(i-1, upp | (c != l), low | (c != r), sum+c);",
      "    }",
      "    dp[i][upp][low][sum] = res;",
      "    return res;",
      "}"
    ],
    "description": "dp_digit"
  },
  "sub-1,comp": {
    "prefix": "#comp_string",
    "body": [
      "void sub(string &a) {",
      "    a.back() -= 1;",
      "    for (int i = a.size()-1; i > 0; --i) {",
      "        if (a[i] < '0') {",
      "            a[i] = '9';",
      "            a[i-1] -= 1;",
      "        } else break;",
      "    }",
      "    if (a[0] == '0') a.erase(0, 1);",
      "}",
      "bool comp(const string &u, const string &v) { // u > v",
      "    if (u.size() > v.size()) return 1;",
      "    if (u.size() < v.size()) return 0;",
      "    for (int i = 0; i < u.size(); ++i)",
      "        if (u[i] > v[i])",
      "            return 1;",
      "        else if (u[i] < v[i])",
      "            return 0;",
      "    return 0;",
      "}"
    ],
    "description": "sub-1,comp"
  },
  "stack_lr": {
    "prefix": "$stack",
    "body": [
      "    stack<int> s;",
      "    vi maxl(n);",
      "    for (int i = 0; i < n; ++i) {",
      "        while (!s.empty() && a[s.top()] < a[i]) s.pop();",
      "        maxl[i] = (s.empty() ? -1 : s.top());",
      "        s.push(i);",
      "    }",
      "",
      "    s = stack<int>();",
      "    vi maxr(n);",
      "    for (int i = n-1; i >= 0; --i) {",
      "        while (!s.empty() && a[i] >= a[s.top()]) s.pop();",
      "        maxr[i] = (s.empty() ? n : s.top());",
      "        s.push(i);",
      "    }",
      "",
      "    s = stack<int>();",
      "    vi minl(n);",
      "    for (int i = 0; i < n; ++i) {",
      "        while (!s.empty() && a[s.top()] > a[i]) s.pop();",
      "        minl[i] = (s.empty() ? -1 : s.top());",
      "        s.push(i);",
      "    }",
      "",
      "    s = stack<int>();",
      "    vi minr(n);",
      "    for (int i = n-1; i >= 0; --i) {",
      "        while (!s.empty() && a[i] <= a[s.top()]) s.pop();",
      "        minr[i] = (s.empty() ? n : s.top());",
      "        s.push(i);",
      "    }",
      ""
    ],
    "description": "stack_lr"
  },
  "fast read (short)": {
    "prefix": "#readint",
    "body": [
      "inline char readchar() {",
      "    constexpr int B = 1<<15;",
      "    static char buf[B], *p, *q;",
      "    if(p == q && (q=(p=buf)+fread(buf,1,B,stdin)) == buf) return EOF;",
      "    return *p++;",
      "}",
      "inline int nextint() {",
      "    int x = 0, c = readchar();",
      "    while(c < '0') c = readchar();",
      "    while(c >= '0') x=x*10+(c^'0'), c=readchar();",
      "    return x;",
      "}"
    ],
    "description": "fast read (short)"
  },
  "fastio": {
    "prefix": "#fastIO",
    "body": [
      "template <class T> struct is_iterator {",
      "  template <class U, typename enable_if<!is_convertible<U, const char*>::value, int>::type = 0>",
      "  constexpr static auto has_indirection(int) -> decltype(*declval<U>(), bool()) { return true; }",
      "  template <class> constexpr static bool has_indirection(long) { return false; }",
      "  constexpr static bool value = has_indirection<T>(0);",
      "};",
      " ",
      "using uint = unsigned int;",
      "// Buffer size should be 2^12 or 2^13 for optimal performance with files.",
      "const uint BUFFER_SIZE = 1 << 12;",
      "// Maximum possible length of a string representing primitive type",
      "// assuming we won't encounter huge double values.",
      "const uint MAX_LENGTH = 1 << 7;",
      " ",
      "namespace Detail {",
      "  struct Width { uint value; };",
      "  struct Fill { char value; };",
      "  struct Base { uint value; };",
      "  struct Precision { uint value; };",
      "  struct Delimiter { const char* value; };",
      "}  // namespace Detail",
      " ",
      "Detail::Width setWidth(uint value = 0) { return {value}; }",
      "Detail::Fill setFill(char value = ' ') { return {value}; }",
      "Detail::Base setBase(uint value = 10) { assert(2 <= value && value <= 36); return {value}; }",
      "Detail::Precision setPrecision(uint value = 9) { assert(value < MAX_LENGTH); return {value}; }",
      "Detail::Delimiter setDelimiter(const char* value = \" \") { return {value}; }",
      " ",
      "/******************************* input classes ********************************/",
      "class InputDevice {",
      "protected:",
      "  const char* head;",
      "  const char* tail;",
      " ",
      "  InputDevice(const char* head, const char* tail) : head(head), tail(tail), base(setBase().value) {}",
      " ",
      "  virtual void fillInput() = 0;",
      " ",
      "  inline char nextChar() {",
      "    if (__builtin_expect(head >= tail, false)) fillInput();",
      "    return *head++;",
      "  }",
      " ",
      "  template <class I> int readUnsignedIntGeneral(I& arg, char c) {",
      "    I value = 0;",
      "    int length = 0;",
      "    for (;; ++length, c = nextChar()) {",
      "      if (isDigit(c)) c -= '0';",
      "      else if (isUpper(c)) c -= 'A' - 10;",
      "      else if (isLower(c)) c -= 'a' - 10;",
      "      else c = base;",
      "      if (c >= base) break;",
      "      value = base * value + c;",
      "    }",
      "    arg = value;",
      "    return --head, length;",
      "  }",
      " ",
      "  template <class I> inline int readUnsignedInt(I& arg, char c) {",
      "    if (__builtin_expect(base > 10, false)) return readUnsignedIntGeneral(arg, c);",
      "    I value = 0;",
      "    int length = 0;",
      "    for (; static_cast<unsigned char>(c - '0') < base; ++length, c = nextChar())",
      "      value = base * value + c - '0';",
      "    arg = value;",
      "    return --head, length;",
      "  }",
      " ",
      "  template <class I> inline bool readSignedInt(I& arg, char c) {",
      "    bool negative = c == '-';",
      "    if (negative) c = nextChar();",
      "    typename make_unsigned<I>::type unsignedArg;",
      "    if (readUnsignedInt(unsignedArg, c) == 0) return false;",
      "    arg = negative ? ~static_cast<I>(unsignedArg - 1) : static_cast<I>(unsignedArg);",
      "    return true;",
      "  }",
      " ",
      "  template <class F> bool readFloatingPoint(F& arg, char c) {",
      "    bool negative = c == '-';",
      "    if (negative) c = nextChar();",
      "    unsigned long long integerPart;",
      "    if (readUnsignedInt(integerPart, c) == 0) return false;",
      "    arg = static_cast<F>(integerPart);",
      "    if (nextChar() == '.') {",
      "      unsigned long long fractionalPart = 0;",
      "      int fractionalLength = readUnsignedInt(fractionalPart, nextChar());",
      "      if (fractionalLength > 0) {",
      "        unsigned long long basePower = 1;",
      "        for (; fractionalLength; --fractionalLength) basePower *= base;",
      "        arg += static_cast<F>(fractionalPart) / basePower;",
      "      }",
      "    } else --head;",
      "    if (negative) arg = -arg;",
      "    return true;",
      "  }",
      " ",
      "public:",
      "  uint base;",
      " ",
      "  InputDevice(InputDevice const&) = delete;",
      "  InputDevice& operator = (InputDevice const&) = delete;",
      " ",
      "  static inline bool isSpace(char c) { return static_cast<unsigned char>(c - '\\t') < 5 || c == ' '; }",
      "  static inline bool isDigit(char c) { return static_cast<unsigned char>(c - '0') < 10; }",
      "  static inline bool isUpper(char c) { return static_cast<unsigned char>(c - 'A') < 26; }",
      "  static inline bool isLower(char c) { return static_cast<unsigned char>(c - 'a') < 26; }",
      "  static inline bool isOneOf(char c, const char* str) { return strchr(str, c) != nullptr; }",
      " ",
      "  void putBack() { --head; }  // can be called only once directly after successfully reading a character",
      " ",
      "  inline bool readChar(char& arg) {",
      "    if (__builtin_expect(head >= tail, false)) {",
      "      fillInput();",
      "      if (__builtin_expect(head >= tail, false)) return arg = '\\0', false;",
      "    }",
      "    return arg = *head++, true;",
      "  }",
      " ",
      "  template <class UnaryPredicate>",
      "  inline char skipCharacters(UnaryPredicate isSkipped) {",
      "    char c;",
      "    do { c = nextChar(); } while (isSkipped(c));",
      "    return c;",
      "  }",
      "  inline char skipCharacters() { return skipCharacters(isSpace); }",
      " ",
      "  template <class UnaryPredicate>",
      "  inline int readString(char* arg, int limit, UnaryPredicate isTerminator) {",
      "    skipCharacters(isTerminator);",
      "    // put back first non-skipped character, reserve space for null character",
      "    int charsRead = 0;",
      "    for (--head, --limit; head < tail; fillInput()) {",
      "      ptrdiff_t chunkSize = find_if(head, min(tail, head + limit - charsRead), isTerminator) - head;",
      "      arg = copy_n(head, chunkSize, arg);",
      "      head += chunkSize;",
      "      charsRead += chunkSize;",
      "      if (chunkSize == 0 || head < tail) break;",
      "    }",
      "    return *arg = '\\0', charsRead;",
      "  }",
      " ",
      "  inline int readString(char* arg, int limit, const char* terminators) {",
      "    if (!*terminators) return readString(arg, limit, InputDevice::isSpace);",
      "    return readString(arg, limit, [terminators](char c) { return InputDevice::isOneOf(c, terminators); });",
      "  }",
      " ",
      "  // property setters",
      "  inline bool read(Detail::Base newBase) { base = newBase.value; return true; }",
      "  // primitive types",
      "  inline bool read() { return true; }",
      "  inline bool read(char& arg) { return readChar(arg); }",
      "  template <class I> inline typename enable_if<is_integral<I>::value && is_unsigned<I>::value,",
      "  bool>::type read(I& arg) { return readUnsignedInt(arg, skipCharacters()) > 0; }",
      "  template <class I> inline typename enable_if<is_integral<I>::value && is_signed<I>::value,",
      "  bool>::type read(I& arg) { return readSignedInt(arg, skipCharacters()); }",
      "  template <class F> inline typename enable_if<is_floating_point<F>::value,",
      "  bool>::type read(F& arg) { return readFloatingPoint(arg, skipCharacters()); }",
      "  // characters skip",
      "  inline bool read(const char& arg) { skipCharacters([arg](char c) { return arg != c; }); return true; }",
      "  inline bool read(const char* arg) {",
      "    if (*arg) skipCharacters([arg](char c) { return InputDevice::isOneOf(c, arg); });",
      "    else skipCharacters();",
      "    return putBack(), true;",
      "  }",
      "  inline bool read(bool (*isSkipped)(char)) { skipCharacters(isSkipped); putBack(); return true; }",
      "  // strings",
      "  template <class I, class Terminator, class... Ts> inline typename enable_if<is_integral<I>::value,",
      "  bool>::type read(char* arg, I limit, Terminator terminator, Ts&&... args) {",
      "    readString(arg, static_cast<int>(limit), terminator);",
      "    return read(forward<Ts>(args)...);",
      "  }",
      "  template <class I> inline typename enable_if<is_integral<I>::value,",
      "  bool>::type read(char* arg, I limit) { return read(arg, limit, \"\"); }",
      "  template <class... Ts>",
      "  inline bool read(char* first, char* last, Ts&&... args) {",
      "    return read(first, static_cast<int>(last - first), forward<Ts>(args)...);",
      "  }",
      "  template <int N, class... Ts>",
      "  inline bool read(char (&arg)[N], Ts&&... args) { return read(static_cast<char*>(arg), N, forward<Ts>(args)...); }",
      "  template <class Terminator, class... Ts>",
      "  inline bool read(string& arg, Terminator terminator, Ts&&... args) {",
      "    for (int length = 16, last = 0;; last += length, length <<= 1) {",
      "      arg.resize(last + length);",
      "      int charsRead = readString(&arg[last], length + 1, terminator);",
      "      if (charsRead < length) {",
      "        arg.resize(last + charsRead);",
      "        return read(forward<Ts>(args)...);",
      "      }",
      "    }",
      "  }",
      "  inline bool read(string& arg) { return read(arg, \"\"); }",
      "  // complex types and ranges",
      "  template <class T1, class T2>",
      "  inline bool read(pair<T1, T2>& arg) { return read(arg.first, arg.second); }",
      "  template <class T>",
      "  inline bool read(complex<T>& arg) {",
      "    T real, imag;",
      "    if (!read(real, imag)) return false;",
      "    arg.real(real), arg.imag(imag);",
      "    return true;",
      "  }",
      "  template <class T>",
      "  inline bool read(vector<T>& arg) {",
      "    uint n;",
      "    if (!read(n)) return false;",
      "    arg.resize(n);",
      "    return read(arg.begin(), arg.end());",
      "  }",
      "  template <class Iterator, class... Ts> inline typename enable_if<is_iterator<Iterator>::value,",
      "  bool>::type read(Iterator first, Iterator last, Ts&&... args) {",
      "    for (; first != last; ++first) if (!read(*first)) return false;",
      "    return read(forward<Ts>(args)...);",
      "  }",
      "  template <class Iterator, class I, class... Ts>",
      "  inline typename enable_if<is_iterator<Iterator>::value && is_integral<I>::value,",
      "  bool>::type read(Iterator first, I count, Ts&&... args) { return read(first, first + count, forward<Ts>(args)...); }",
      "  // generic forwarding",
      "  template <class T>",
      "  inline auto read(T& arg) -> decltype(arg.read(*this)) { return arg.read(*this); }",
      "  template <class T0, class T1, class... Ts>",
      "  inline typename enable_if<!is_iterator<T0>::value && !is_convertible<T0, char*>::value,",
      "  bool>::type read(T0&& arg0, T1&& arg1, Ts&&... args) {",
      "    return read(forward<T0>(arg0)) && read(forward<T1>(arg1), forward<Ts>(args)...);",
      "  }",
      "};",
      " ",
      "class InputFile : public InputDevice {",
      "  FILE* file;",
      "  bool lineBuffered;",
      "  bool owner;",
      "  char buffer[BUFFER_SIZE];",
      " ",
      "  void fillInput() override {",
      "    head = buffer;",
      "    *buffer = '\\0';",
      "    if (__builtin_expect(!lineBuffered, true)) {",
      "      tail = head + fread(buffer, 1, BUFFER_SIZE, file);",
      "    } else {",
      "      tail = head;",
      "      if (fgets(buffer, BUFFER_SIZE, file)) while (*tail) ++tail;",
      "    }",
      "  }",
      " ",
      "public:",
      "  InputFile(FILE* file = stdin, bool lineBuffered = true, bool takeOwnership = false)",
      "  : InputDevice(buffer, buffer) , file(file), lineBuffered(lineBuffered), owner(takeOwnership) {}",
      "  InputFile(const char* fileName) : InputFile(fopen(fileName, \"r\"), false, true) {}",
      "  ~InputFile() { if (owner) fclose(file); }",
      "};",
      " ",
      "// Picks up data appended to the string but doesn't handle reallocation.",
      "class InputString : public InputDevice {",
      "  void fillInput() override { while (*tail) ++tail; }",
      " ",
      "public:",
      "  InputString(const string& s) : InputDevice(s.data(), s.data() + s.size()) {}",
      "  InputString(const char* s) : InputDevice(s, s + strlen(s)) {}",
      "};",
      " ",
      "/******************************* output classes *******************************/",
      "class OutputDevice {",
      "protected:",
      "  char buffer[BUFFER_SIZE + MAX_LENGTH];",
      "  char* output;",
      "  char* end;",
      "  bool separate;",
      " ",
      "  OutputDevice() : output(buffer), end(buffer + BUFFER_SIZE + MAX_LENGTH), separate(false)",
      "  , width(setWidth().value), fill(setFill().value), base(setBase().value), precision(setPrecision().value)",
      "  , delimiter(setDelimiter().value) { computeBasePower(); }",
      " ",
      "  virtual void writeToDevice(uint count) = 0;",
      " ",
      "  inline void flushMaybe() {",
      "    if (__builtin_expect(output >= buffer + BUFFER_SIZE, false)) {",
      "      writeToDevice(BUFFER_SIZE);",
      "      output = copy(buffer + BUFFER_SIZE, output, buffer);",
      "    }",
      "  }",
      " ",
      "  void computeBasePower() {",
      "    basePower = 1;",
      "    for (uint i = 0; i < precision; ++i) basePower *= base;",
      "  }",
      " ",
      "  template <class I> inline char* writeUnsignedInt(I arg, char* last) {",
      "    if (__builtin_expect(arg == 0, false)) *--last = '0';",
      "    if (__builtin_expect(base == 10, true)) {",
      "      for (; arg; arg /= 10) *--last = '0' + arg % 10;",
      "    } else for (; arg; arg /= base) {",
      "      I digit = arg % base;",
      "      *--last = digit < 10 ? '0' + digit : 'A' - 10 + digit;",
      "    }",
      "    return last;",
      "  }",
      " ",
      "  template <class I> inline char* writeSignedInt(I arg, char* last) {",
      "    auto unsignedArg = static_cast<typename make_unsigned<I>::type>(arg);",
      "    if (arg < 0) {",
      "      last = writeUnsignedInt(~unsignedArg + 1, last);",
      "      *--last = '-';",
      "      return last;",
      "    }",
      "    return writeUnsignedInt(unsignedArg, last);",
      "  }",
      " ",
      "  template <class F> char* writeFloatingPoint(F arg, char* last) {",
      "    bool negative = signbit(arg);",
      "    if (negative) arg = -arg;",
      "    if (isnan(arg)) for (int i = 0; i < 3; ++i) *--last = i[\"NaN\"];",
      "    else if (isinf(arg)) for (int i = 0; i < 3; ++i) *--last = i[\"fnI\"];",
      "    else {",
      "      auto integerPart = static_cast<unsigned long long>(arg);",
      "      auto fractionalPart = static_cast<unsigned long long>((arg - integerPart) * basePower + F(0.5));",
      "      if (fractionalPart >= basePower) ++integerPart, fractionalPart = 0;",
      "      char* point = last - precision;",
      "      if (precision > 0) {",
      "        ::fill(point, writeUnsignedInt(fractionalPart, last), '0');",
      "        *--point = '.';",
      "      }",
      "      last = writeUnsignedInt(integerPart, point);",
      "    }",
      "    if (negative) *--last = '-';",
      "    return last;",
      "  }",
      " ",
      "  inline int writeT(char* first) {",
      "    int delimiterLenght = separate ? writeDelimiter() : 0;",
      "    separate = true;",
      "    uint charsWritten = static_cast<uint>(end - first);",
      "    if (__builtin_expect(charsWritten < width, false))",
      "      charsWritten += writeFill(width - charsWritten);",
      "    output = copy(first, end, output);",
      "    flushMaybe();",
      "    return delimiterLenght + static_cast<int>(charsWritten);",
      "  }",
      " ",
      "  inline int writeFill(uint count) {",
      "    int charsWritten = static_cast<int>(count);",
      "    if (__builtin_expect(output + count + MAX_LENGTH < end, true)) {",
      "      if (count == 1) *output++ = fill;",
      "      else output = fill_n(output, count, fill);",
      "    } else for (uint chunkSize = static_cast<uint>(buffer + BUFFER_SIZE - output);; chunkSize = BUFFER_SIZE) {",
      "      if (chunkSize > count) chunkSize = count;",
      "      output = fill_n(output, chunkSize, fill);",
      "      flushMaybe();",
      "      if ((count -= chunkSize) == 0) break;",
      "    }",
      "    return charsWritten;",
      "  }",
      " ",
      "public:",
      "  uint width;",
      "  char fill;",
      "  uint base;",
      "  uint precision;",
      "  unsigned long long basePower;",
      "  string delimiter;",
      " ",
      "  OutputDevice(OutputDevice const&) = delete;",
      "  OutputDevice& operator = (OutputDevice const&) = delete;",
      "  virtual ~OutputDevice() {};",
      " ",
      "  inline int writeChar(char arg) { separate = false; *output++ = arg; flushMaybe(); return 1; }",
      " ",
      "  inline int writeString(const char* arg, size_t length, bool checkWidth = true) {",
      "    separate = false;",
      "    uint count = static_cast<uint>(length);",
      "    int charsWritten = static_cast<int>(count) + (checkWidth && count < width ? writeFill(width - count) : 0);",
      "    if (__builtin_expect(output + count + MAX_LENGTH < end, true)) {",
      "      if (count == 1) *output++ = *arg;",
      "      else output = copy_n(arg, count, output);",
      "    } else for (uint chunkSize = static_cast<uint>(buffer + BUFFER_SIZE - output);; chunkSize = BUFFER_SIZE) {",
      "      if (chunkSize > count) chunkSize = count;",
      "      output = copy_n(arg, chunkSize, output);",
      "      flushMaybe();",
      "      if ((count -= chunkSize) == 0) break;",
      "      arg += chunkSize;",
      "    }",
      "    return charsWritten;",
      "  }",
      " ",
      "  inline int writeDelimiter() { return writeString(delimiter.c_str(), delimiter.size(), false); }",
      " ",
      "  inline void flush() {",
      "    writeToDevice(static_cast<uint>(output - buffer));",
      "    output = buffer;",
      "  }",
      " ",
      "  // property setters",
      "  inline int write(Detail::Width newWidth) { width = newWidth.value; return 0; }",
      "  inline int write(Detail::Fill newFill) { fill = newFill.value; return 0; }",
      "  inline int write(Detail::Base newBase) { base = newBase.value; computeBasePower(); return 0; }",
      "  inline int write(Detail::Precision newPrecision) {",
      "    precision = newPrecision.value; computeBasePower(); return 0;",
      "  }",
      "  inline int write(Detail::Delimiter newDelimiter) { delimiter = newDelimiter.value; return 0; }",
      "  // primitive types",
      "  inline int write() { return 0; }",
      "  inline int write(char arg) { return writeChar(arg); }",
      "  template <class I> inline typename enable_if<is_integral<I>::value && is_unsigned<I>::value,",
      "  int>::type write(I arg) { return writeT(writeUnsignedInt(arg, end)); }",
      "  template <class I> inline typename enable_if<is_integral<I>::value && is_signed<I>::value,",
      "  int>::type write(I arg) { return writeT(writeSignedInt(arg, end)); }",
      "  template <class F> inline typename enable_if<is_floating_point<F>::value,",
      "  int>::type write(F arg) { return writeT(writeFloatingPoint(arg, end)); }",
      "  // complex types",
      "  inline int write(const char* arg) { return writeString(arg, strlen(arg)); }",
      "  template <int N>",
      "  inline int write(char (&arg)[N]) { return writeString(arg, strlen(arg)); }",
      "  inline int write(const string& arg) { return writeString(arg.c_str(), arg.size()); }",
      "  template <class T1, class T2>",
      "  inline int write(const pair<T1, T2>& arg) {",
      "    int charsWritten = write(arg.first);",
      "    charsWritten += writeDelimiter();",
      "    return charsWritten + write(arg.second);",
      "  }",
      "  template <class T>",
      "  inline int write(const complex<T>& arg) { return write(real(arg), imag(arg)); }",
      "  // ranges",
      "  template <class Iterator, class... Ts> inline typename enable_if<is_iterator<Iterator>::value,",
      "  int>::type write(Iterator first, Iterator last, Ts&&... args) {",
      "    int charsWritten = 0;",
      "    for (; first != last; charsWritten += ++first == last ? 0 : writeDelimiter()) charsWritten += write(*first);",
      "    return charsWritten + write(forward<Ts>(args)...);",
      "  }",
      "  template <class Iterator, class I, class... Ts>",
      "  inline typename enable_if<is_iterator<Iterator>::value && is_integral<I>::value,",
      "  int>::type write(Iterator first, I count, Ts&&... args) { return write(first, first + count, forward<Ts>(args)...); }",
      "  // generic forwarding",
      "  template <class T>",
      "  inline auto write(const T& arg) -> decltype(arg.write(*this)) { return arg.write(*this); }",
      "  template <class T0, class T1, class... Ts> inline typename enable_if<!is_iterator<T0>::value,",
      "  int>::type write(T0&& arg0, T1&& arg1, Ts&&... args) {",
      "    int charsWritten = write(forward<T0>(arg0));",
      "    return charsWritten + write(forward<T1>(arg1), forward<Ts>(args)...);",
      "  }",
      "};",
      " ",
      "class OutputFile : public OutputDevice {",
      "  FILE* file;",
      "  bool owner;",
      " ",
      "  void writeToDevice(uint count) override {",
      "    fwrite(buffer, 1, count, file);",
      "    fflush(file);",
      "  }",
      " ",
      "public:",
      "  OutputFile(FILE* file = stdout, bool takeOwnership = false) : file(file), owner(takeOwnership) {}",
      "  OutputFile(const char* fileName) : OutputFile(fopen(fileName, \"w\"), true) {}",
      "  ~OutputFile() override { flush(); if (owner) fclose(file); }",
      "};",
      " ",
      "class OutputString : public OutputDevice {",
      "  string& str;",
      " ",
      "  void writeToDevice(uint count) override { str.append(buffer, count); }",
      " ",
      "public:",
      "  OutputString(string& str) : OutputDevice(), str(str) {}",
      "  ~OutputString() override { flush(); }",
      "};",
      " ",
      "unique_ptr<InputDevice> input;",
      "unique_ptr<OutputDevice> output;",
      " ",
      "template <class... Ts> inline bool read(Ts&&... args) { return input->read(forward<Ts>(args)...); }",
      "template <class... Ts> inline int write(Ts&&... args) { return output->write(forward<Ts>(args)...); }",
      "template <class... Ts> inline int writeln(Ts&&... args) { return write(forward<Ts>(args)..., '\\n'); }",
      "void flush() { output->flush(); }",
      "#ifdef ONLINE_JUDGE",
      "  input.reset(new InputFile(stdin, false));    // usual problem",
      "  input.reset(new InputFile());                // interactive problem",
      "  output.reset(new OutputFile());",
      "#else",
      "  input.reset(new InputFile());                // local testing using a console",
      "  input.reset(new InputFile(\"DGROUPS.inp\"));     // local testing using a file",
      "  output.reset(new OutputFile());              // output to console",
      "  output.reset(new OutputFile(\"DGROUPS.out\"));  // output to a file",
      "#endif"
    ],
    "description": "fastio"
  },
  "trinh_cham_ngoai_themis": {
    "prefix": "#trinhchamngoai",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "ifstream fi, fo, fa;",
      "char TestPath[1000], CurrPath[1000];",
      "char fINP[1000], fOUT[1000], fANS[1000];",
      "",
      "void themis_init(const char* inName, const char* outName) {",
      "    gets(TestPath);",
      "    gets(CurrPath);",
      "",
      "    sprintf(fINP, \"%s/%s\", TestPath, inName);",
      "    sprintf(fANS, \"%s/%s\", TestPath, outName);",
      "    sprintf(fOUT, \"%s/%s\", CurrPath, outName);",
      "    fi.open(fINP, ifstream::in);",
      "    fa.open(fANS, ifstream::in);",
      "    fo.open(fOUT, ifstream::in);",
      "}",
      "void themis_close() {",
      "    fi.close();",
      "    fa.close();",
      "    fo.close();",
      "}",
      "",
      "#define int long long",
      "#define nametask \"VANTAI\"",
      "// g++ -g checkVANTAI.cpp -o checkVANTAI.exe",
      "bool check() {",
      "    // nhập input",
      "    int m, n;",
      "    fi >> m >> n;",
      "    int a[n+1];",
      "    for (int i = 1; i <= n; ++i) fi >> a[i];",
      "",
      "    // nhập đáp án",
      "    int res;",
      "    fa >> res;",
      "",
      "    // nhập output và xử lí, return 1:đúng, 0:sai.",
      "    int cnt;",
      "    fo >> cnt;",
      "    if (cnt != res)",
      "        return cout << \"sai tong so chuyen\", 0;",
      "    if (cnt == 0)",
      "        return 1;",
      "",
      "    int sum = 0;",
      "    for (int i = 1; i <= n; ++i) {",
      "        int x; fo >> x;",
      "        if (x < 1)",
      "            return cout << \"xe \" << i << \" chua duoc chay\", 0;",
      "        sum += x * a[i];",
      "    }",
      "    if (sum != m)",
      "        return cout << \"sai truy vet\", 0;",
      "",
      "    return 1;",
      "}",
      "",
      "signed main() {",
      "    char inputFile[] = nametask\".inp\";",
      "    char outputFile[] = nametask\".out\";",
      "    themis_init(inputFile, outputFile);",
      "    ",
      "    cout << (check() ? \"\\n1\\n\" : \"\\n0\\n\");",
      "",
      "    themis_close();",
      "    return 0;",
      "}",
      ""
    ],
    "description": "trinh_cham_ngoai_themis"
  },
  "hash_fast_mod": {
    "prefix": "$hash_mod",
    "body": [
      "const int MAX = 1e6+5, NMOD = 1;",
      "const int MOD[] = {(int)1e9 + 2277, (int)1e9 + 5277, (int)1e9 + 8277, (int)1e9 + 9277};",
      "const int BASE = 256;",
      "int pw[NMOD][MAX];",
      "void prepare(int len = MAX) {",
      "    for (int j = 0 ; j < NMOD; j++) {",
      "        pw[j][0] = 1;",
      "        for (int i = 1; i < MAX; i++)",
      "            pw[j][i] = pw[j][i - 1] * BASE % MOD[j];",
      "    }",
      "}",
      "struct Hash {",
      "    int value[NMOD];",
      "    Hash() {",
      "        memset(value, 0, sizeof value);",
      "    }",
      "    Hash(char c) {",
      "        for (int j = 0; j < NMOD; j++) value[j] = c;",
      "    }",
      "    Hash operator + (const Hash &x) const {",
      "        Hash res;",
      "        for (int j = 0; j < NMOD; j++) {",
      "            res.value[j] = value[j] + x.value[j];",
      "            if (res.value[j] >= MOD[j]) res.value[j] -= MOD[j];",
      "        }",
      "        return res;",
      "    }",
      "    Hash operator - (const Hash &x) const {",
      "        Hash res;",
      "        for (int j = 0; j < NMOD; j++) {",
      "            res.value[j] = value[j] - x.value[j];",
      "            if (res.value[j] < 0) res.value[j] += MOD[j];",
      "        }",
      "        return res;",
      "    }",
      "    Hash operator * (int k) const {",
      "        Hash res;",
      "        for (int j = 0; j < NMOD; j++) ",
      "            res.value[j] = value[j] * pw[j][k] % MOD[j];",
      "        return res;",
      "    }",
      "    bool operator == (const Hash &x) const {",
      "        for (int j = 0; j < NMOD; j++)",
      "            if (value[j] != x.value[j])",
      "                return 0;",
      "        return 1;",
      "    }",
      "    bool operator != (const Hash &x) const {",
      "        for (int j = 0; j < NMOD; j++)",
      "            if (value[j] != x.value[j])",
      "                return 1;",
      "        return 0;",
      "    }",
      "};",
      "",
      "int len;",
      "Hash h[MAX];",
      "",
      "Hash gethash(int l, int r) {",
      "    return (h[r] - h[l - 1]) * (len - r);",
      "}"
    ],
    "description": "hash_fast_mod"
  },
  "bignum": {
    "prefix": "#bignumsqrt",
    "body": [
      "typedef int64_t ll;",
      "typedef long long ll;",
      "typedef pair<ll,ll> lll;",
      "typedef pair<ll,int> lli;",
      "typedef pair<int,int> ii;",
      "",
      "#define pb push_back",
      "#define mp make_pair",
      "#define ep emplace_back",
      "#define X  first",
      "#define Y  second",
      "#define fillchar(a,x) memset(a, x, sizeof(a))",
      "#define FOR(i,l,r) for (int i=l;i<=r;i++)",
      "#define FORD(i,r,l) for (int i=r;i>=l;i--)",
      "const int base = 1e9;",
      "",
      "typedef vector<int> big;",
      "",
      "void Set(big &a) {",
      "    while (a.size() > 1 && a.back() == 0) a.pop_back();",
      "}",
      "",
      "void Print(big a) {",
      "    Set(a);",
      "    cout << ((a.size() == 0) ? 0 : a.back());",
      "    FORD(i,a.size()-2,0) cout << a[i];",
      "}",
      "const int base_digits = 9;",
      "big Integer(string s) {",
      "    big ans;",
      "    if (s[0] == '-') return ans;",
      "    if (s.size() == 0) {ans.pb(0); return ans;}",
      "    while (s.size()%9 != 0) s = '0'+s;",
      "    for (int i=0;i<s.size();i+=9) {",
      "        int v = 0;",
      "        for (int j=i;j<i+9;j++) v = v*10+(s[j]-'0');",
      "        ans.insert(ans.begin(),v);",
      "    }",
      "    Set(ans);",
      "    return ans;",
      "}",
      "",
      "big Integer(char c[]) {",
      "    string s = \"\";",
      "    FOR(i,0,strlen(c)-1) s = s + c[i];",
      "    return Integer(s);",
      "}",
      "",
      "big Integer(ll x) {",
      "    string s = \"\";",
      "    while (x > 0) s = char(x%10+'0') + s, x /= 10;",
      "    return Integer(s);",
      "}",
      "",
      "big Integer(int x) {",
      "    return Integer((ll) x);",
      "}",
      "",
      "",
      "",
      "",
      "void operator >> (istream &in, big &a) {",
      "    string s;",
      "    getline(cin, s);",
      "    a = Integer(s);",
      "}",
      "",
      "void operator << (ostream &out, big a) {",
      "    Print(a);",
      "}",
      "",
      "",
      "",
      "",
      "bool operator < (big a, big b) {",
      "    Set(a);",
      "    Set(b);",
      "    if (a.size() != b.size()) return (a.size() < b.size());",
      "    FORD(i,a.size()-1,0)",
      "        if (a[i] != b[i]) return (a[i] < b[i]);",
      "    return false;",
      "}",
      "",
      "bool operator > (big a, big b) {",
      "    return (b < a);",
      "}",
      "",
      "bool operator == (big a, big b) {",
      "    return (!(a < b) && !(b < a));",
      "}",
      "",
      "bool operator <= (big a, big b) {",
      "    return (a < b || a == b);",
      "}",
      "",
      "bool operator >= (big a, big b) {",
      "    return (b < a || b == a);",
      "}",
      "",
      "bool operator < (big a, int b) {",
      "    return (a < Integer(b));",
      "}",
      "",
      "bool operator > (big a, int b) {",
      "    return (a > Integer(b));",
      "}",
      "",
      "bool operator == (big a, int b) {",
      "    return (a == Integer(b));",
      "}",
      "",
      "bool operator >= (big a, int b) {",
      "    return (a >= Integer(b));",
      "}",
      "",
      "bool operator <= (big a, int b) {",
      "    return (a <= Integer(b));",
      "}",
      "",
      "",
      "",
      "big max(big a, big b) {",
      "    if (a > b) return a;",
      "    return b;",
      "}",
      "",
      "big min(big a, big b) {",
      "    if (a < b) return a;",
      "    return b;",
      "}",
      "",
      "",
      "",
      "",
      "big operator + (big a, big b) {",
      "    Set(a);",
      "    Set(b);",
      "    big ans;",
      "    int carry = 0;",
      "    FOR(i,0,max(a.size(), b.size())-1) {",
      "        if (i < a.size()) carry += a[i];",
      "        if (i < b.size()) carry += b[i];",
      "        ans.pb(carry%base);",
      "        carry /= base;",
      "    }",
      "    if (carry) ans.pb(carry);",
      "    Set(ans);",
      "    return ans;",
      "}",
      "",
      "big operator + (big a, int b) {",
      "    return a + Integer(b);",
      "}",
      "",
      "big operator ++ (big &a) { // ++a",
      "    a = a + 1;",
      "    return a;",
      "}",
      "",
      "void operator += (big &a, big b) {",
      "    a = a + b;",
      "}",
      "",
      "void operator += (big &a, int b) {",
      "    a = a + b;",
      "}",
      "",
      "",
      "",
      "",
      "big operator - (big a, big b) {",
      "    Set(a);",
      "    Set(b);",
      "    big ans;",
      "    int carry = 0;",
      "    FOR(i,0,a.size()-1) {",
      "        carry += a[i] - (i < b.size() ? b[i] : 0);",
      "        if (carry < 0) ans.pb(carry+base), carry = -1;",
      "        else ans.pb(carry), carry = 0;",
      "    }",
      "    Set(ans);",
      "    return ans;",
      "}",
      "",
      "big operator - (big a, int b) {",
      "    return a - Integer(b);",
      "}",
      "",
      "void operator -- (big &a) { // --a",
      "    a = a - 1;",
      "}",
      "",
      "void operator -= (big &a, big b) {",
      "    a = a + b;",
      "}",
      "",
      "void operator -= (big &a, int b) {",
      "    a = a - b;",
      "}",
      "",
      "",
      "",
      "",
      "big operator * (big a, big b) {",
      "    Set(a);",
      "    Set(b);",
      "    big ans;",
      "    ans.assign(a.size()+b.size(), 0);",
      "    FOR(i,0,a.size()-1) {",
      "        ll carry = 0ll;",
      "        for (int j=0;j<b.size() || carry > 0;j++) {",
      "            ll s = ans[i+j] + carry + (ll)a[i]*(j<b.size()?(ll)b[j]:0ll);",
      "            ans[i+j] = s%base;",
      "            carry = s/base;",
      "        }",
      "    }",
      "    Set(ans);",
      "    return ans;",
      "}",
      "",
      "big operator * (big a, int b) {",
      "    return a * Integer(b);",
      "}",
      "",
      "void operator *= (big &a, big b) {",
      "    a = a * b;",
      "}",
      "",
      "void operator *= (big &a, int b) {",
      "    a = a * b;",
      "}",
      "",
      "",
      "",
      "big operator / (big a, big b) {",
      "    Set(a);",
      "    Set(b);",
      "    big ans, cur;",
      "    FORD(i,a.size()-1,0) {",
      "        cur.insert(cur.begin(), a[i]);",
      "        int x = 0, L = 0, R = base;",
      "        while (L <= R) {",
      "            int mid = (L+R)>>1;",
      "            if (b*Integer(mid) > cur) {",
      "                x = mid;",
      "                R = mid-1;",
      "            }",
      "            else",
      "                L = mid+1;",
      "        }",
      "        cur = cur - Integer(x-1)*b;",
      "        ans.insert(ans.begin(),x-1);",
      "    }",
      "    Set(ans);",
      "    return ans;",
      "}",
      "",
      "big operator / (big a, int b) {",
      "    Set(a);",
      "    big ans;",
      "    ll cur = 0ll;",
      "    FORD(i,a.size()-1,0) {",
      "        cur = (cur*(ll)base + (ll)a[i]);",
      "        ans.insert(ans.begin(),cur/b);",
      "        cur %= b;",
      "    }",
      "    Set(ans);",
      "    return ans;",
      "}",
      "",
      "void operator /= (big &a, big b) {",
      "    a = a / b;",
      "}",
      "",
      "void operator /= (big &a, int b) {",
      "    a = a / b;",
      "}",
      "",
      "big operator % (big a, big b) {",
      "    Set(a);",
      "    Set(b);",
      "    big ans;",
      "    FORD(i,a.size()-1,0) {",
      "        ans.insert(ans.begin(), a[i]);",
      "        int x = 0, L = 0, R = base;",
      "        while (L <= R) {",
      "            int mid = (L+R)>>1;",
      "            if (b*Integer(mid) > ans) {",
      "                x = mid;",
      "                R = mid-1;",
      "            }",
      "            else",
      "                L = mid+1;",
      "        }",
      "        ans = ans - Integer(x-1)*b;",
      "    }",
      "    Set(ans);",
      "    return ans;",
      "}",
      "",
      "int operator % (big a, int b) {",
      "    Set(a);",
      "    if (b == 0) return -1;",
      "    int ans = 0;",
      "    FORD(i,a.size()-1,0)",
      "        ans = (ans*(base%b) + a[i]%b)%b;",
      "    return ans;",
      "}",
      "",
      "void operator %= (big &a, big b) {",
      "    a = a % b;",
      "}",
      "",
      "void operator %= (big &a, int b) {",
      "    a = a % Integer(b);",
      "}",
      "",
      "big gcd(big a, big b) {",
      "    Set(a);",
      "    Set(b);",
      "    while (b > Integer(0)) {",
      "        big r = a%b;",
      "        a = b;",
      "        b = r;",
      "    }",
      "    Set(a);",
      "    return a;",
      "}",
      "",
      "big lcm(big a, big b) {",
      "    return (a*b/gcd(a,b));",
      "}",
      "",
      "",
      "big sqrt(big a) {",
      "    big x0 = a, x1 = (a+1)/2;",
      "    while (x1 < x0) {",
      "        x0 = x1;",
      "        x1 = (x1+a/x1)/2;",
      "    }",
      "    return x0;",
      "}",
      "",
      "",
      "big pow(big a, big b) {",
      "    if (b == Integer(0)) return Integer(1);",
      "    big tmp = pow(a, b/2);",
      "    if (b%2 == 0) return tmp * tmp;",
      "    return tmp * tmp * a;",
      "}",
      "",
      "",
      "big pow(big a, int b) {",
      "    return pow(a,(Integer(b)));",
      "}",
      "",
      "",
      "int log(int n, big a) { // log_n(a)",
      "    Set(a);",
      "    int ans = 0;",
      "    while (a > Integer(1)) {",
      "        ans++;",
      "        a /= n;",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "bignum"
  },
  "bignum_TXB": {
    "prefix": "#bignum_TXB",
    "body": [
      "const int BASE_DIGITS = 9;",
      "const int BASE = 1000000000;",
      "",
      "struct BigInt {",
      "    int sign;",
      "    vector<int> a;",
      "",
      "    // -------------------- Constructors -------------------- ",
      "    // Default constructor.",
      "    BigInt() : sign(1) {}",
      "",
      "    // Constructor from long long.",
      "    BigInt(long long v) {",
      "        *this = v;",
      "    }",
      "    BigInt& operator = (long long v) {",
      "        sign = 1;",
      "        if (v < 0) {",
      "            sign = -1;",
      "            v = -v;",
      "        }",
      "        a.clear();",
      "        for (; v > 0; v = v / BASE)",
      "            a.push_back(v % BASE);",
      "        return *this;",
      "    }",
      "",
      "    // Initialize from string.",
      "    BigInt(const string& s) {",
      "        read(s);",
      "    }",
      "",
      "    // -------------------- Input / Output --------------------",
      "    void read(const string& s) {",
      "        sign = 1;",
      "        a.clear();",
      "        int pos = 0;",
      "        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
      "            if (s[pos] == '-')",
      "                sign = -sign;",
      "            ++pos;",
      "        }",
      "        for (int i = s.size() - 1; i >= pos; i -= BASE_DIGITS) {",
      "            int x = 0;",
      "            for (int j = max(pos, i - BASE_DIGITS + 1); j <= i; j++)",
      "                x = x * 10 + s[j] - '0';",
      "            a.push_back(x);",
      "        }",
      "        trim();",
      "    }",
      "    friend istream& operator>>(istream &stream, BigInt &v) {",
      "        string s;",
      "        stream >> s;",
      "        v.read(s);",
      "        return stream;",
      "    }",
      "",
      "    friend ostream& operator<<(ostream &stream, const BigInt &v) {",
      "        if (v.sign == -1 && !v.isZero())",
      "            stream << '-';",
      "        stream << (v.a.empty() ? 0 : v.a.back());",
      "        for (int i = (int) v.a.size() - 2; i >= 0; --i)",
      "            stream << setw(BASE_DIGITS) << setfill('0') << v.a[i];",
      "        return stream;",
      "    }",
      "",
      "    // -------------------- Comparison --------------------",
      "    bool operator<(const BigInt &v) const {",
      "        if (sign != v.sign)",
      "            return sign < v.sign;",
      "        if (a.size() != v.a.size())",
      "            return a.size() * sign < v.a.size() * v.sign;",
      "        for (int i = ((int) a.size()) - 1; i >= 0; i--)",
      "            if (a[i] != v.a[i])",
      "                return a[i] * sign < v.a[i] * sign;",
      "        return false;",
      "    }",
      "",
      "    bool operator>(const BigInt &v) const {",
      "        return v < *this;",
      "    }",
      "    bool operator<=(const BigInt &v) const {",
      "        return !(v < *this);",
      "    }",
      "    bool operator>=(const BigInt &v) const {",
      "        return !(*this < v);",
      "    }",
      "    bool operator==(const BigInt &v) const {",
      "        return !(*this < v) && !(v < *this);",
      "    }",
      "    bool operator!=(const BigInt &v) const {",
      "        return *this < v || v < *this;",
      "    }",
      "",
      "    // Returns:",
      "    // 0 if |x| == |y|",
      "    // -1 if |x| < |y|",
      "    // 1 if |x| > |y|",
      "    friend int __compare_abs(const BigInt& x, const BigInt& y) {",
      "        if (x.a.size() != y.a.size()) {",
      "            return x.a.size() < y.a.size() ? -1 : 1;",
      "        }",
      "",
      "        for (int i = ((int) x.a.size()) - 1; i >= 0; --i) {",
      "            if (x.a[i] != y.a[i]) {",
      "                return x.a[i] < y.a[i] ? -1 : 1;",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "",
      "    // -------------------- Unary operator - and operators +- --------------------",
      "    BigInt operator-() const {",
      "        BigInt res = *this;",
      "        if (isZero()) return res;",
      "",
      "        res.sign = -sign;",
      "        return res;",
      "    }",
      "",
      "    // Note: sign ignored.",
      "    void __internal_add(const BigInt& v) {",
      "        if (a.size() < v.a.size()) {",
      "            a.resize(v.a.size(), 0);",
      "        }",
      "        for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
      "            if (i == (int) a.size()) a.push_back(0);",
      "",
      "            a[i] += carry + (i < (int) v.a.size() ? v.a[i] : 0);",
      "            carry = a[i] >= BASE;",
      "            if (carry) a[i] -= BASE;",
      "        }",
      "    }",
      "",
      "    // Note: sign ignored.",
      "    void __internal_sub(const BigInt& v) {",
      "        for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
      "            a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
      "            carry = a[i] < 0;",
      "            if (carry) a[i] += BASE;",
      "        }",
      "        this->trim();",
      "    }",
      "",
      "    BigInt operator += (const BigInt& v) {",
      "        if (sign == v.sign) {",
      "            __internal_add(v);",
      "        } else {",
      "            if (__compare_abs(*this, v) >= 0) {",
      "                __internal_sub(v);",
      "            } else {",
      "                BigInt vv = v;",
      "                swap(*this, vv);",
      "                __internal_sub(vv);",
      "            }",
      "        }",
      "        return *this;",
      "    }",
      "",
      "    BigInt operator -= (const BigInt& v) {",
      "        if (sign == v.sign) {",
      "            if (__compare_abs(*this, v) >= 0) {",
      "                __internal_sub(v);",
      "            } else {",
      "                BigInt vv = v;",
      "                swap(*this, vv);",
      "                __internal_sub(vv);",
      "                this->sign = -this->sign;",
      "            }",
      "        } else {",
      "            __internal_add(v);",
      "        }",
      "        return *this;",
      "    }",
      "",
      "    // Optimize operators + and - according to",
      "    // https://stackoverflow.com/questions/13166079/move-semantics-and-pass-by-rvalue-reference-in-overloaded-arithmetic",
      "    template< typename L, typename R >",
      "        typename std::enable_if<",
      "            std::is_convertible<L, BigInt>::value &&",
      "            std::is_convertible<R, BigInt>::value &&",
      "            std::is_lvalue_reference<R&&>::value,",
      "            BigInt>::type friend operator + (L&& l, R&& r) {",
      "        BigInt result(std::forward<L>(l));",
      "        result += r;",
      "        return result;",
      "    }",
      "    template< typename L, typename R >",
      "        typename std::enable_if<",
      "            std::is_convertible<L, BigInt>::value &&",
      "            std::is_convertible<R, BigInt>::value &&",
      "            std::is_rvalue_reference<R&&>::value,",
      "            BigInt>::type friend operator + (L&& l, R&& r) {",
      "        BigInt result(std::move(r));",
      "        result += l;",
      "        return result;",
      "    }",
      "",
      "    template< typename L, typename R >",
      "        typename std::enable_if<",
      "            std::is_convertible<L, BigInt>::value &&",
      "            std::is_convertible<R, BigInt>::value,",
      "            BigInt>::type friend operator - (L&& l, R&& r) {",
      "        BigInt result(std::forward<L>(l));",
      "        result -= r;",
      "        return result;",
      "    }",
      "",
      "    // -------------------- Operators * / % --------------------",
      "    friend pair<BigInt, BigInt> divmod(const BigInt& a1, const BigInt& b1) {",
      "        assert(b1 > 0);  // divmod not well-defined for b < 0.",
      "",
      "        long long norm = BASE / (b1.a.back() + 1);",
      "        BigInt a = a1.abs() * norm;",
      "        BigInt b = b1.abs() * norm;",
      "        BigInt q = 0, r = 0;",
      "        q.a.resize(a.a.size());",
      "",
      "        for (int i = a.a.size() - 1; i >= 0; i--) {",
      "            r *= BASE;",
      "            r += a.a[i];",
      "            long long s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
      "            long long s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
      "            long long d = ((long long) BASE * s1 + s2) / b.a.back();",
      "            r -= b * d;",
      "            while (r < 0) {",
      "                r += b, --d;",
      "            }",
      "            q.a[i] = d;",
      "        }",
      "",
      "        q.sign = a1.sign * b1.sign;",
      "        r.sign = a1.sign;",
      "        q.trim();",
      "        r.trim();",
      "        auto res = make_pair(q, r / norm);",
      "        if (res.second < 0) res.second += b1;",
      "        return res;",
      "    }",
      "    BigInt operator/(const BigInt &v) const {",
      "        return divmod(*this, v).first;",
      "    }",
      "",
      "    BigInt operator%(const BigInt &v) const {",
      "        return divmod(*this, v).second;",
      "    }",
      "",
      "    void operator/=(int v) {",
      "        assert(v > 0);  // operator / not well-defined for v <= 0.",
      "        if (llabs(v) >= BASE) {",
      "            *this /= BigInt(v);",
      "            return ;",
      "        }",
      "        if (v < 0)",
      "            sign = -sign, v = -v;",
      "        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
      "            long long cur = a[i] + rem * (long long) BASE;",
      "            a[i] = (int) (cur / v);",
      "            rem = (int) (cur % v);",
      "        }",
      "        trim();",
      "    }",
      "",
      "    BigInt operator/(int v) const {",
      "        assert(v > 0);  // operator / not well-defined for v <= 0.",
      "",
      "        if (llabs(v) >= BASE) {",
      "            return *this / BigInt(v);",
      "        }",
      "        BigInt res = *this;",
      "        res /= v;",
      "        return res;",
      "    }",
      "    void operator/=(const BigInt &v) {",
      "        *this = *this / v;",
      "    }",
      "",
      "    long long operator%(long long v) const {",
      "        assert(v > 0);  // operator / not well-defined for v <= 0.",
      "        assert(v < BASE);",
      "        int m = 0;",
      "        for (int i = a.size() - 1; i >= 0; --i)",
      "            m = (a[i] + m * (long long) BASE) % v;",
      "        return m * sign;",
      "    }",
      "",
      "    void operator*=(int v) {",
      "        if (llabs(v) >= BASE) {",
      "            *this *= BigInt(v);",
      "            return ;",
      "        }",
      "        if (v < 0)",
      "            sign = -sign, v = -v;",
      "        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
      "            if (i == (int) a.size())",
      "                a.push_back(0);",
      "            long long cur = a[i] * (long long) v + carry;",
      "            carry = (int) (cur / BASE);",
      "            a[i] = (int) (cur % BASE);",
      "            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
      "            /*",
      "             int val;",
      "             __asm {",
      "             lea esi, cur",
      "             mov eax, [esi]",
      "             mov edx, [esi+4]",
      "             mov ecx, base",
      "             div ecx",
      "             mov carry, eax",
      "             mov val, edx;",
      "             }",
      "             a[i] = val;",
      "             */",
      "        }",
      "        trim();",
      "    }",
      "",
      "    BigInt operator*(int v) const {",
      "        if (llabs(v) >= BASE) {",
      "            return *this * BigInt(v);",
      "        }",
      "        BigInt res = *this;",
      "        res *= v;",
      "        return res;",
      "    }",
      "",
      "    // Convert BASE 10^old --> 10^new.",
      "    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
      "        vector<long long> p(max(old_digits, new_digits) + 1);",
      "        p[0] = 1;",
      "        for (int i = 1; i < (int) p.size(); i++)",
      "            p[i] = p[i - 1] * 10;",
      "        vector<int> res;",
      "        long long cur = 0;",
      "        int cur_digits = 0;",
      "        for (int i = 0; i < (int) a.size(); i++) {",
      "            cur += a[i] * p[cur_digits];",
      "            cur_digits += old_digits;",
      "            while (cur_digits >= new_digits) {",
      "                res.push_back((long long)(cur % p[new_digits]));",
      "                cur /= p[new_digits];",
      "                cur_digits -= new_digits;",
      "            }",
      "        }",
      "        res.push_back((int) cur);",
      "        while (!res.empty() && !res.back())",
      "            res.pop_back();",
      "        return res;",
      "    }",
      "",
      "    void fft(vector<complex<double> > & a, bool invert) const {",
      "        int n = (int) a.size();",
      "",
      "        for (int i = 1, j = 0; i < n; ++i) {",
      "            int bit = n >> 1;",
      "            for (; j >= bit; bit >>= 1)",
      "                j -= bit;",
      "            j += bit;",
      "            if (i < j)",
      "                swap(a[i], a[j]);",
      "        }",
      "",
      "        for (int len = 2; len <= n; len <<= 1) {",
      "            double ang = 2 * 3.14159265358979323846 / len * (invert ? -1 : 1);",
      "            complex<double> wlen(cos(ang), sin(ang));",
      "            for (int i = 0; i < n; i += len) {",
      "                complex<double> w(1);",
      "                for (int j = 0; j < len / 2; ++j) {",
      "                    complex<double> u = a[i + j];",
      "                    complex<double> v = a[i + j + len / 2] * w;",
      "                    a[i + j] = u + v;",
      "                    a[i + j + len / 2] = u - v;",
      "                    w *= wlen;",
      "                }",
      "            }",
      "        }",
      "        if (invert)",
      "            for (int i = 0; i < n; ++i)",
      "                a[i] /= n;",
      "    }",
      "",
      "    void multiply_fft(const vector<int> &a, const vector<int> &b, vector<int> &res) const {",
      "        vector<complex<double> > fa(a.begin(), a.end());",
      "        vector<complex<double> > fb(b.begin(), b.end());",
      "        int n = 1;",
      "        while (n < (int) max(a.size(), b.size()))",
      "            n <<= 1;",
      "        n <<= 1;",
      "        fa.resize(n);",
      "        fb.resize(n);",
      "",
      "        fft(fa, false);",
      "        fft(fb, false);",
      "        for (int i = 0; i < n; ++i)",
      "            fa[i] *= fb[i];",
      "        fft(fa, true);",
      "",
      "        res.resize(n);",
      "        long long carry = 0;",
      "        for (int i = 0; i < n; ++i) {",
      "            long long t = (long long) (fa[i].real() + 0.5) + carry;",
      "            carry = t / 1000;",
      "            res[i] = t % 1000;",
      "        }",
      "    }",
      "",
      "    BigInt mul_simple(const BigInt &v) const {",
      "        BigInt res;",
      "        res.sign = sign * v.sign;",
      "        res.a.resize(a.size() + v.a.size());",
      "        for (int i = 0; i < (int) a.size(); ++i)",
      "            if (a[i])",
      "                for (int j = 0, carry = 0; j < (int) v.a.size() || carry; ++j) {",
      "                    long long cur = res.a[i + j] + (long long) a[i] * (j < (int) v.a.size() ? v.a[j] : 0) + carry;",
      "                    carry = (int) (cur / BASE);",
      "                    res.a[i + j] = (int) (cur % BASE);",
      "                }",
      "        res.trim();",
      "        return res;",
      "    }",
      "",
      "    typedef vector<long long> vll;",
      "",
      "    static vll karatsubaMultiply(const vll &a, const vll &b) {",
      "        int n = a.size();",
      "        vll res(n + n);",
      "        if (n <= 32) {",
      "            for (int i = 0; i < n; i++)",
      "                for (int j = 0; j < n; j++)",
      "                    res[i + j] += a[i] * b[j];",
      "            return res;",
      "        }",
      "",
      "        int k = n >> 1;",
      "        vll a1(a.begin(), a.begin() + k);",
      "        vll a2(a.begin() + k, a.end());",
      "        vll b1(b.begin(), b.begin() + k);",
      "        vll b2(b.begin() + k, b.end());",
      "",
      "        vll a1b1 = karatsubaMultiply(a1, b1);",
      "        vll a2b2 = karatsubaMultiply(a2, b2);",
      "",
      "        for (int i = 0; i < k; i++)",
      "            a2[i] += a1[i];",
      "        for (int i = 0; i < k; i++)",
      "            b2[i] += b1[i];",
      "",
      "        vll r = karatsubaMultiply(a2, b2);",
      "        for (int i = 0; i < (int) a1b1.size(); i++)",
      "            r[i] -= a1b1[i];",
      "        for (int i = 0; i < (int) a2b2.size(); i++)",
      "            r[i] -= a2b2[i];",
      "",
      "        for (int i = 0; i < (int) r.size(); i++)",
      "            res[i + k] += r[i];",
      "        for (int i = 0; i < (int) a1b1.size(); i++)",
      "            res[i] += a1b1[i];",
      "        for (int i = 0; i < (int) a2b2.size(); i++)",
      "            res[i + n] += a2b2[i];",
      "        return res;",
      "    }",
      "",
      "    BigInt mul_karatsuba(const BigInt &v) const {",
      "        vector<int> a6 = convert_base(this->a, BASE_DIGITS, 6);",
      "        vector<int> b6 = convert_base(v.a, BASE_DIGITS, 6);",
      "        vll a(a6.begin(), a6.end());",
      "        vll b(b6.begin(), b6.end());",
      "        while (a.size() < b.size())",
      "            a.push_back(0);",
      "        while (b.size() < a.size())",
      "            b.push_back(0);",
      "        while (a.size() & (a.size() - 1))",
      "            a.push_back(0), b.push_back(0);",
      "        vll c = karatsubaMultiply(a, b);",
      "        BigInt res;",
      "        res.sign = sign * v.sign;",
      "        long long carry = 0;",
      "        for (int i = 0; i < (int) c.size(); i++) {",
      "            long long cur = c[i] + carry;",
      "            res.a.push_back((int) (cur % 1000000));",
      "            carry = cur / 1000000;",
      "        }",
      "        res.a = convert_base(res.a, 6, BASE_DIGITS);",
      "        res.trim();",
      "        return res;",
      "    }",
      "",
      "    void operator*=(const BigInt &v) {",
      "        *this = *this * v;",
      "    }",
      "    BigInt operator*(const BigInt &v) const {",
      "        if (a.size() * v.a.size() <= 1000111) return mul_simple(v);",
      "        if (a.size() > 500111 || v.a.size() > 500111) return mul_fft(v);",
      "        return mul_karatsuba(v);",
      "    }",
      "",
      "    BigInt mul_fft(const BigInt& v) const {",
      "        BigInt res;",
      "        res.sign = sign * v.sign;",
      "        multiply_fft(convert_base(a, BASE_DIGITS, 3), convert_base(v.a, BASE_DIGITS, 3), res.a);",
      "        res.a = convert_base(res.a, 3, BASE_DIGITS);",
      "        res.trim();",
      "        return res;",
      "    }",
      "",
      "    // -------------------- Misc --------------------",
      "    BigInt abs() const {",
      "        BigInt res = *this;",
      "        res.sign *= res.sign;",
      "        return res;",
      "    }",
      "    void trim() {",
      "        while (!a.empty() && !a.back())",
      "            a.pop_back();",
      "        if (a.empty())",
      "            sign = 1;",
      "    }",
      "",
      "    bool isZero() const {",
      "        return a.empty() || (a.size() == 1 && !a[0]);",
      "    }",
      "",
      "    friend BigInt gcd(const BigInt &a, const BigInt &b) {",
      "        return b.isZero() ? a : gcd(b, a % b);",
      "    }",
      "    friend BigInt lcm(const BigInt &a, const BigInt &b) {",
      "        return a / gcd(a, b) * b;",
      "    }",
      "",
      "    friend BigInt sqrt(const BigInt &a1) {",
      "        BigInt a = a1;",
      "        while (a.a.empty() || a.a.size() % 2 == 1)",
      "            a.a.push_back(0);",
      "",
      "        int n = a.a.size();",
      "",
      "        int firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);",
      "        int norm = BASE / (firstDigit + 1);",
      "        a *= norm;",
      "        a *= norm;",
      "        while (a.a.empty() || a.a.size() % 2 == 1)",
      "            a.a.push_back(0);",
      "",
      "        BigInt r = (long long) a.a[n - 1] * BASE + a.a[n - 2];",
      "        firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);",
      "        int q = firstDigit;",
      "        BigInt res;",
      "",
      "        for(int j = n / 2 - 1; j >= 0; j--) {",
      "            for(; ; --q) {",
      "                BigInt r1 = (r - (res * 2 * BigInt(BASE) + q) * q) * BigInt(BASE) * BigInt(BASE) + (j > 0 ? (long long) a.a[2 * j - 1] * BASE + a.a[2 * j - 2] : 0);",
      "                if (r1 >= 0) {",
      "                    r = r1;",
      "                    break;",
      "                }",
      "            }",
      "            res *= BASE;",
      "            res += q;",
      "",
      "            if (j > 0) {",
      "                int d1 = res.a.size() + 2 < r.a.size() ? r.a[res.a.size() + 2] : 0;",
      "                int d2 = res.a.size() + 1 < r.a.size() ? r.a[res.a.size() + 1] : 0;",
      "                int d3 = res.a.size() < r.a.size() ? r.a[res.a.size()] : 0;",
      "                q = ((long long) d1 * BASE * BASE + (long long) d2 * BASE + d3) / (firstDigit * 2);",
      "            }",
      "        }",
      "",
      "        res.trim();",
      "        return res / norm;",
      "    }",
      "};"
    ],
    "description": "bignum_TXB"
  },
  "palind+comp": {
    "prefix": "$hash_palind_comp",
    "body": [
      "const int N = 1e6+5, MOD = 1e9+7, BASE = 256;",
      "string s;",
      "int n;",
      "int h[2][N], p[N];",
      "int gethash(int id, int l, int r) {",
      "    return (h[id][r] - h[id][l-1] * p[r-l+1] % MOD + MOD) % MOD;",
      "}",
      "int inv(int i) {",
      "    return n-i+1;",
      "}",
      "int palind(int l, int r) {",
      "    if (l < 1 || r > n) return 0;",
      "    return gethash(0, l, r) == gethash(1, inv(r), inv(l));",
      "}",
      "bool comp(int u, int v, int len) {",
      "    int l = 0, r = len-1, pos = len;",
      "    while (l <= r) {",
      "        int mid = l + r >> 1;",
      "        if (gethash(0, u, u+mid) != gethash(0, v, v+mid)) {",
      "            pos = mid;",
      "            r = mid-1;",
      "        } else",
      "            l = mid+1; ",
      "    }",
      "    if (pos == len) return 0;",
      "    return (s[u+pos-1] > s[v+pos-1]);",
      "}",
      "    p[0] = 1;",
      "    for (int i = 1; i <= n; ++i) p[i] = p[i-1] * BASE % MOD;",
      "    for (int i = 1; i <= n; ++i) {",
      "        h[0][i] = (h[0][i-1] * BASE + s[i-1]) % MOD;",
      "        h[1][i] = (h[1][i-1] * BASE + s[n-i]) % MOD;",
      "    }"
    ],
    "description": "palind+comp"
  },
    "hashstruct": {
        "prefix": "$hash_struct",
        "body": [
          "#define NMOD 3",
          "const int MOD[] = {(int)1e9 + 2277, (int)1e9 + 5277, (int)1e9 + 8277, (int)1e9 + 9277};",
          "const int BASE = 256;",
          "#define MAX 1000005",
          "int pw[NMOD][MAX];",
          "void prepare() {",
          "    for (int j = 0 ; j < NMOD; j++) {",
          "        pw[j][0] = 1;",
          "        for (int i = 1; i < MAX; i++)",
          "            pw[j][i] = 1LL * pw[j][i - 1] * BASE % MOD[j];",
          "    }",
          "}",
          "struct Hash {",
          "    int n;",
          "    vector<int> h[NMOD];",
          "    Hash() {}",
          "    Hash(int _n) {",
          "        n = _n;",
          "        for (int i = 0; i < NMOD; ++i) h[i].resize(n+1);",
          "    }",
          "    Hash(string s) {",
          "        n = s.size();",
          "        for (int j = 0; j < NMOD; ++j) {",
          "            h[j].resize(n+1);",
          "            h[j][0] = 0;",
          "            for (int i = 1; i <= n; ++i)",
          "                h[j][i] = (h[j][i-1] * BASE %MOD[j] + s[i-1]) %MOD[j];",
          "        }",
          "    }",
          "    vector<int> get(int l, int r) {",
          "        vector<int> ans(NMOD);",
          "        for (int i = 0; i < NMOD; ++i)",
          "            ans[i] = (h[i][r] - (h[i][l-1] * pw[i][r-l+1]",
          "                %MOD[i]) + MOD[i]) %MOD[i];",
          "        return ans;",
          "    }",
          "};"
        ],
        "description": "hashstruct"
      },
    "cong_thua_toan": {
        "prefix": "!mathcttoan",
        "body": [
          "/*",
          "Tổ hợp nCk: n! / k! / (n-k)!",
          "C0(n) = 1",
          "C1(n) = n",
          "C2(n) = n * (n-1) / 2",
          "C3(n) = n * (n-1) * (n-2) / 6",
          "C4(n) = n * (n-1) * (n-2) * (n-3) / 24",
          "C(k, n) = n * (n-1) * (n-2) * … * (n-k+1) / (2 * 3 * … * k)",
          "Tổ hợp - LQDOJ: Le Quy Don Online Judge",
          "Chỉnh hợp nPk: n! / (n-k)!",
          "Lưới ô vuông n*m:",
          "",
          "    C2(n+1) * C2(m+1);   // số hình chữ nhật",
          "    n * (n+1) * (3*m-n+1) / 6; // số hình vuông (n <= m)",
          "Lưới tam giác n cạnh:",
          "",
          "    n * (n+2) * (2*n+1) / 8; // tổng số tam giác",
          "    n * (n+1) * (n+2) / 6;  // tam giác xuôi (đáy bằng)",
          "    n * (n+2) * (2*n+1) / 8  -  n * (n+1) * (n+2) / 6; // tg ngược (đáy nhọn)",
          "",
          "",
          "Dãy tăng đều: ",
          "Xét dãy: L, L+k, L+2k, L+3k … R",
          "Số lượng số hạng: (R-L) / k + 1",
          "Tổng: (R+L) * (R-L+1) / 2",
          "",
          "Dãy bình phương: ",
          "Tổng 12+22+32+...+n2 = n * (n+1) * (2*n+1) / 6",
          "Tổng 12+32+52+...+(2n-1)2 = n * (2*n-1) *(2*n+1) / 3",
          "Tổng 22+42+62+...+(2n)2 = 4 * n * (n+1) * (2*n+1) / 6",
          "Catalan n:",
          " = 1/(n+1) * C(n, 2n) = (2n)! / ((n+1)! n!)      (n >= 0)",
          " ",
          "Fibonacci n:",
          "Đệ quy: ",
          "F(1) = 1,    F(2) = 1,   F(n) = F(n-1) + F(n-2)",
          "Nhân ma trận:",
          "{",
          "    {1, 1},",
          "    {1, 0}",
          "} ^n",
          "= {",
          "    {Fn+1, Fn}",
          "    {Fn, Fn-1}",
          "}",
          "",
          "Số gần đúng:",
          "Fn = 1/sqrt(5) * { [(1+sqrt(5))/2]^n - [(1-sqrt(5))/2]^n }",
          "",
          "Đẳng thức:",
          "F(n + 1) = F(n) + F(n - 1)",
          "F(0) + F(1) + F(2) +... + F(n) = F(n + 2) - 1",
          "F(1) + 2 F(2) + 3 F(3) +... + n F(n) = n F(n + 2) - F(n + 3) + 2",
          "Ước số:",
          "Số nguyên dương n được phân tích thành thừa số nguyên tố: p1^k1 * p2^k2 *…* pm^km thì:",
          "Số lượng ước của n = (k1+1) * (k2+1) * … * (km+1)",
          "Tổng các ước của n =  (p1*(k1+1) - 1) / (p1 - 1) * (p2*(k2+1) - 1) / (p2 - 1) * … * (pm*(km+1) - 1) / (pm - 1)",
          "",
          "*/"
        ],
        "description": "cong_thua_toan"
      },
    "sparse table template": {
        "prefix": "$sparsetablermq(template)",
        "body": [
          "#define log2(n) 31 - __builtin_clz(n)",
          "template <typename T, class F = function<T(const T&, const T&)>>",
          "class SparseTable { // 0 - index",
          "public:",
          "    int n;",
          "    vector<vector<T>> v;",
          "    F func;",
          " ",
          "    SparseTable(const vector<T>& a, const F& f) : func(f), n(a.size()) {",
          "        int k = log2(n);",
          "        v.resize(k + 1); v[0] = a;",
          "        for (int j = 1; j <= k; ++j) {",
          "            v[j].resize(n - (1 << j) + 1);",
          "            for (int i = 0; i <= n - (1 << j); ++i) {",
          "                v[j][i] = func(v[j - 1][i], v[j - 1][i + (1 << j - 1)]);",
          "            }",
          "        }",
          "    }",
          " ",
          "    T get(const int &l, const int &r) {",
          "        int k = log2(r - l + 1);",
          "        return func(v[k][l], v[k][r - (1 << k) + 1]);",
          "    }",
          "};",
          "    SparseTable<int> spt(a, [&] (int x, int y) {",
          "        return min(x, y);",
          "    });",
          "        cout << spt.get(l, r) << \"\\n\";"
        ],
        "description": "sparse table template"
      },
      "hash_array": {
        "prefix": "$hash_1str",
        "body": [
          "#define NMOD 2",
          "const int MOD[] = {(int)1e9 + 2277, (int)1e9 + 5277, (int)1e9 + 8277, (int)1e9 + 9277};",
          "struct Hash {",
          "    int v[NMOD];",
          "    bool operator == (Hash a) {",
          "        for (int i = 0; i < NMOD; ++i)",
          "            if (v[i] != a.v[i])",
          "                return 0;",
          "        return 1;",
          "    }",
          "    bool operator != (Hash a) {",
          "        for (int i = 0; i < NMOD; ++i)",
          "            if (v[i] != a.v[i])",
          "                return 1;",
          "        return 0;",
          "    }",
          "};",
          "const int BASE = 256;",
          "#define MAXN 1000005",
          "int pw[NMOD][MAXN];",
          "void prepare() {",
          "    for (int j = 0; j < NMOD; ++j) {",
          "        pw[j][0] = 1;",
          "        for (int i = 1; i < MAXN; ++i)",
          "            pw[j][i] = pw[j][i-1] * BASE % MOD[j];",
          "    }",
          "}",
          "int len;",
          "int h[NMOD][MAXN];",
          "void build_hash(string s) {",
          "    len = s.size();",
          "    for (int j = 0; j < NMOD; ++j) {",
          "        h[j][0] = 0;",
          "        for (int i = 1; i <= len; ++i)",
          "            h[j][i] = (h[j][i-1] * BASE %MOD[j] + s[i-1]) %MOD[j];",
          "    }",
          "}",
          "Hash gethash(int l, int r) {",
          "    Hash ans;",
          "    for (int i = 0; i < NMOD; ++i)",
          "        ans.v[i] = (h[i][r] - (h[i][l-1] * pw[i][r-l+1]",
          "            %MOD[i]) + MOD[i]) %MOD[i];",
          "    return ans;",
          "}"
        ],
        "description": "hash_array"
      },
      "HASH": {
        "prefix": "$hash",
        "body": [
          "const int MOD = (int)(1e9+7);",
          "const int BASE = (int)(257);",
          "const int N = (int)(5005);",
          "int p[N], h[N];",
          "int gethash(int l, int r) {",
          "    return (h[r] - (h[l-1] * p[r-l+1])%MOD + MOD) %MOD;",
          "}",
          "main() {",
          "    p[0] = 1;",
          "    for (int i = 1; i <= n; ++i)",
          "        p[i] = (p[i-1] * BASE) %MOD;",
          "    h[0] = 0;",
          "    for (int i = 1; i <= n; ++i)",
          "        h[i] = (h[i-1] * BASE %MOD + (s[i-1]-'a')) %MOD;",
          "}",
          ""
        ],
        "description": "HASH"
      },
      "hash_nstr": {
        "prefix": "$hash_nstr_2mod",
        "body": [
          "const int MOD = 1e9+7, MOD2 = 1e9+9, BASE = 256;",
          "int n;",
          "string s[N];",
          "vector<II> h[N];",
          "int p[N];",
          "II gethash(int id, int l, int r) {",
          "    return {",
          "        (h[id][r].fi - h[id][l-1].fi * p[r-l+1] % MOD + MOD) % MOD,",
          "        (h[id][r].se - h[id][l-1].se * p[r-l+1] % MOD2 + MOD2) % MOD2",
          "    };",
          "}",
          "    p[0] = 1;",
          "    for (int i = 1; i < N; ++i) p[i] = p[i-1] * BASE % MOD;",
          "    for (int id = 1; id <= n; ++id) {",
          "        h[id].resize(s[id].size() + 1);",
          "        for (int i = 1; i <= s[id].size(); ++i) {",
          "            h[id][i].fi = (h[id][i-1].fi * BASE + s[id][i-1]) % MOD;",
          "            h[id][i].se = (h[id][i-1].se * BASE + s[id][i-1]) % MOD2;",
          "        }",
          "    }"
        ],
        "description": "hash_nstr"
      },
    "sparse table main()": {
        "prefix": "$sparsetablermq(main)",
        "body": [
          "const int N = 1e6+5, K = 21;",
          "int lg[N];",
          "int st[N][K];",
          "    ",
          "int get(int l, int r) {",
          "    int j = lg[r - l + 1];",
          "    return min(st[l][j], st[r - (1 << j) + 1][j]);",
          "}",
          "",
          "    lg[1] = 0;",
          "    for (int i = 2; i <= n; ++i)",
          "        lg[i] = lg[i >> 1] + 1;",
          "",
          "    for (int i = 1; i <= n; ++i)",
          "        st[i][0] = a[i].se;",
          " ",
          "    for (int j = 1; j < K; ++j)",
          "        for (int i = 1; i <= n - (1 << j) + 1; ++i)",
          "            st[i][j] = min(st[i][j-1], st[i + (1 << (j - 1))][j - 1]);"
        ],
        "description": "sparse table main()"
      },
    "bit(sum)_struct": {
        "prefix": "$bitsum_struct",
        "body": [
          "struct FenwickTree {",
          "    vector<int> v;",
          "    int n;",
          "    FenwickTree(int _n = 0) {",
          "        n = _n;",
          "        v.assign(n + 1, 0);",
          "    }",
          "    void update(int x, int c) { // gán a[x] = a[x] + c",
          "        for (; x <= n; x += x & -x) v[x] += c;",
          "    }",
          "    int get(int x) const { // tính tổng a[1] + a[2] + ... + a[x]",
          "        int res = 0;",
          "        for (; x >= 1; x &= x - 1) res += v[x];",
          "        return res;",
          "    }",
          "    int getSum(int l, int r) const {",
          "        return get(r) - get(l - 1);",
          "    }",
          "};",
          ""
        ],
        "description": "bit(sum)_struct"
      },
    "bit(max)_struct": {
        "prefix": "$bitmax_struct",
        "body": [
          "struct FenwickTree {",
          "    vector<int> v;",
          "    int n;",
          "    FenwickTree(int _n = 0) {",
          "        n = _n;",
          "        v.assign(n + 1, 0);",
          "    }",
          "    void update(int x, int c) { // gán a[x] = max(a[x], c)",
          "        for (; x <= n; x += x & -x) maximize(v[x], c);",
          "    }",
          "    int get(int x) const { // tính max(a[1], a[2],..., a[x])",
          "        int res = 0;",
          "        for (; x >= 1; x &= x - 1) maximize(res, v[x]);",
          "        return res;",
          "    }",
          "};",
          ""
        ],
        "description": "bit(max)_struct"
      },
    "seg_up1all,get:minuv": {
        "prefix": "$seg_allmin",
        "body": [
          "const int INF = 0x3f3f3f3f3f3f3f3f;",
          "const int N = 2e5+5;",
          "int n, k;",
          "int a[N];",
          "int seg[N*4];",
          " ",
          "void update(int id, int l, int r) {",
          "    if (l > r || n < l || r < 1) return ;",
          "    if (l == r) {",
          "        seg[id] = a[l];",
          "        return ;",
          "    }",
          "    int mid = l + r >> 1;",
          "    update(id << 1, l, mid);",
          "    update(id << 1 | 1, mid+1, r);",
          "    seg[id] = min(seg[id << 1], seg[id << 1 | 1]);",
          "}",
          "void update() { update(1, 1, n); }",
          "int getmin(int id, int l, int r, int u, int v) {",
          "    if (l > r || r < u || v < l) return INF;",
          "    if (u <= l && r <= v) return seg[id];",
          "    int mid = l + r >> 1;",
          "    int L = getmin(id << 1, l, mid, u, v);",
          "    int R = getmin(id << 1 | 1, mid+1, r, u, v);",
          "    return min(L, R);",
          "}",
          "int getmin(int l, int r) {",
          "    if (l == r) return a[l];",
          "    return getmin(1, 1, n, l, r);",
          "}",
          ""
        ],
        "description": "seg_up1all,get:minuv"
      },
    "seg_up1all,get:maxuv": {
        "prefix": "$seg_allmax",
        "body": [
          "const int INF = 0x3f3f3f3f3f3f3f3f;",
          "const int N = 1e5+5;",
          "int n, k;",
          "int a[N];",
          "int seg[N*4];",
          " ",
          "void update(int id, int l, int r) {",
          "    if (l > r || n < l || r < 1) return ;",
          "    if (l == r) {",
          "        seg[id] = a[l];",
          "        return ;",
          "    }",
          "    int mid = l + r >> 1;",
          "    update(id << 1, l, mid);",
          "    update(id << 1 | 1, mid+1, r);",
          "    seg[id] = max(seg[id << 1], seg[id << 1 | 1]);",
          "}",
          "void update() { update(1, 1, n); }",
          "int getmax(int id, int l, int r, int u, int v) {",
          "    if (l > r || r < u || v < l) return -INF;",
          "    if (u <= l && r <= v) return seg[id];",
          "    int mid = l + r >> 1;",
          "    int L = getmax(id << 1, l, mid, u, v);",
          "    int R = getmax(id << 1 | 1, mid+1, r, u, v);",
          "    return max(L, R);",
          "}",
          "int getmax(int l, int r) {",
          "    if (l == r) return a[l];",
          "    return getmax(1, 1, n, l, r);",
          "}",
          ""
        ],
        "description": "seg_up1all,get:maxuv"
      },
    "seg_up1all,get:maxminuv": {
        "prefix": "$seg_allpair",
        "body": [
          "const int INF = 0x3f3f3f3f3f3f3f3f;",
          "int n, k;",
          "II seg[N*4];",
          "void update(int id, int l, int r) {",
          "    if (l > r || n < l || r < 1) return ;",
          "    if (l == r) {",
          "        seg[id] = {a[l], a[l]};",
          "        return ;",
          "    }",
          "    int mid = l + r >> 1;",
          "    update(id << 1, l, mid);",
          "    update(id << 1 | 1, mid+1, r);",
          "    seg[id] = {",
          "        min(seg[id << 1].fi, seg[id << 1 | 1].fi),",
          "        max(seg[id << 1].se, seg[id << 1 | 1].se)",
          "    };",
          "}",
          "void update() { update(1, 1, n); }",
          "II get(int id, int l, int r, int u, int v) {",
          "    if (l > r || r < u || v < l) return {INF, -INF};",
          "    if (u <= l && r <= v) return seg[id];",
          "    int mid = l + r >> 1;",
          "    II L = get(id << 1, l, mid, u, v);",
          "    II R = get(id << 1 | 1, mid+1, r, u, v);",
          "    return { ",
          "        min(L.fi, R.fi),",
          "        max(L.se, R.se)",
          "    };",
          "}",
          "II get(int l, int r) {",
          "    if (l == r) return {a[l], a[l]};",
          "    return get(1, 1, n, l, r);",
          "}",
          ""
        ],
        "description": "seg_up1all,get:maxminuv"
      },
    "seg_up:i=x,get:maxuv": {
        "prefix": "$seg_i=min",
        "body": [
              "const int INF = 1e18;",
              "int seg[N*4];",
              "void build(int id = 1, int l = 1, int r = n) {",
              "    if (l == r) {",
              "        seg[id] = a[l];",
              "        return;",
              "    }",
              "    int mid = l + r >> 1;",
              "    build(id << 1, l, mid);",
              "    build(id << 1 | 1, mid + 1, r);",
              "    seg[id] = min(seg[id << 1], seg[id << 1 | 1]);",
              "}",
              "void update(int pos, int val, int id = 1, int l = 1, int r = n) {",
              "    if (l == r) {",
              "        seg[id] = val;",
              "        return ;",
              "    }",
              "    int mid = l + r >> 1;",
              "    if (pos <= mid)",
              "        update(pos, val, id << 1, l, mid);",
              "    else",
              "        update(pos, val, id << 1 | 1, mid + 1, r);",
              "    seg[id] = min(seg[id << 1], seg[id << 1 | 1]);",
              "}",
              "int get(int u, int v, int id = 1, int l = 1, int r = n) {",
              "    if (l > r || r < u || v < l) return INF;",
              "    if (u <= l && r <= v) return seg[id];",
              "    int mid = l + r >> 1;",
              "    return min(",
              "        get(u, v, id << 1, l, mid),",
              "        get(u, v, id << 1 | 1, mid + 1, r)",
              "    );",
              "}"
            ],
        "description": "seg_up:i=x,get:minuv"
      },
      "seg_up:uv=x,get:sumuv": {
        "prefix": "$seg_uv=sum",
        "body": [
          "const int INF = 0x3f3f3f3f3f3f3f3f;",
          "int n;",
          "int seg[N*4], lazy[N*4];",
          "void pushdown(int i, int l, int r) {",
          "    if (lazy[i] == -1) return;",
          "    int m = l + r >> 1;",
          "    seg[i << 1] = lazy[i] * (m - l + 1);",
          "    seg[i << 1 | 1] = lazy[i] * (r - m);",
          "    lazy[i << 1] = lazy[i];",
          "    lazy[i << 1 | 1] = lazy[i];",
          "    lazy[i] = -1;",
          "}",
          "void update(int id, int l, int r, int u, int v, int x) {",
          "    if (l > r || r < u || v < l) return ;",
          "    if (u <= l && r <= v) {",
          "        seg[id] = x * (r - l + 1);",
          "        lazy[id] = x;",
          "        return ;",
          "    }",
          "    pushdown(id, l, r);",
          "    int mid = l + r >> 1;",
          "    update(id << 1, l, mid, u, v, x);",
          "    update(id << 1 | 1, mid+1, r, u, v, x);",
          "    seg[id] = seg[id << 1] + seg[id << 1 | 1];",
          "}",
          "void update(int u, int v, int x) { update(1, 1, n, u, v, x); }",
          "int getsum(int id, int l, int r, int u, int v) {",
          "    if (l > r || r < u || v < l) return 0;",
          "    if (u <= l && r <= v) return seg[id];",
          "    pushdown(id, l, r);",
          "    int mid = l + r >> 1;",
          "    return getsum(id << 1, l, mid, u, v)",
          "        + getsum(id << 1 | 1, mid+1, r, u, v);",
          "}",
          "int getsum(int l, int r) { return getsum(1, 1, n, l, r); }",
          ""
        ],
        "description": "seg_up:uv=x,get:sumuv"
      },
      "seg_up:uv=x,get:maxuv": {
        "prefix": "$seg_uv=max",
        "body": [
          "const int INF = 0x3f3f3f3f3f3f3f3f;",
          "int n;",
          "int seg[N*4], lazy[N*4];",
          "void pushdown(int i) {",
          "    if (lazy[i] < 0) return;",
          "    seg[i << 1] = lazy[i << 1] = lazy[i];",
          "    seg[i << 1 | 1] = lazy[i << 1 | 1] = lazy[i];",
          "    lazy[i] = -1;",
          "}",
          "void update(int id, int l, int r, int u, int v, int x) {",
          "    if (l > r || r < u || v < l) return ;",
          "    if (u <= l && r <= v) {",
          "        seg[id] = lazy[id] = x;",
          "        return ;",
          "    }",
          "    pushdown(id);",
          "    int mid = l + r >> 1;",
          "    update(id << 1, l, mid, u, v, x);",
          "    update(id << 1 | 1, mid+1, r, u, v, x);",
          "    seg[id] = max(seg[id << 1], seg[id << 1 | 1]);",
          "}",
          "void update(int u, int v, int x) { update(1, 1, n, u, v, x); }",
          "int getmax(int id, int l, int r, int u, int v) {",
          "    if (l > r || r < u || v < l) return -INF;",
          "    if (u <= l && r <= v) return seg[id];",
          "    pushdown(id);",
          "    int mid = l + r >> 1;",
          "    return max(",
          "        getmax(id << 1, l, mid, u, v),",
          "        getmax(id << 1 | 1, mid+1, r, u, v)",
          "    );",
          "}",
          "int getmax(int l, int r) { return getmax(1, 1, n, l, r); }",
          ""
        ],
        "description": "seg_up:uv=x,get:maxuv"
      },
      "seg_up:uv+=x,get:sumuv": {
        "prefix": "$seg_uv+=sum",
        "body": [
              "int seg[N*4], lazy[N*4];",
              "void pushdown(int i, int l, int r) {",
              "    if (lazy[i] == 0) return;",
              "    int m = l + r >> 1;",
              "    seg[i << 1] += lazy[i] * (m - l + 1);",
              "    seg[i << 1 | 1] += lazy[i] * (r - m);",
              "    lazy[i << 1] += lazy[i];",
              "    lazy[i << 1 | 1] += lazy[i];",
              "    lazy[i] = 0;",
              "}",
              "void update(int u, int v, int val, int id = 1, int l = 1, int r = n) {",
              "    if (l > r || r < u || v < l) return ;",
              "    if (u <= l && r <= v) {",
              "        seg[id] += val * (r - l + 1);",
              "        lazy[id] += val;",
              "        return ;",
              "    }",
              "    pushdown(id, l, r);",
              "    int mid = l + r >> 1;",
              "    update(u, v, val, id << 1, l, mid);",
              "    update(u, v, val, id << 1 | 1, mid + 1, r);",
              "    seg[id] = seg[id << 1] + seg[id << 1 | 1];",
              "}",
              "int getsum(int u, int v, int id = 1, int l = 1, int r = n) {",
              "    if (l > r || r < u || v < l) return 0;",
              "    if (u <= l && r <= v) return seg[id];",
              "    pushdown(id, l, r);",
              "    int mid = l + r >> 1;",
              "    return getsum(u, v, id << 1, l, mid)",
              "        + getsum(u, v, id << 1 | 1, mid + 1, r);",
              "}"
            ],
        "description": "seg_up:uv+=x,get:sumuv"
      },
      "seg_up:uv+=x,get:maxuv": {
        "prefix": "$seg_uv+=max",
        "body": [
              "const int INF = 1e18;",
              "int seg[N*4], lazy[N*4];",
              "void pushdown(int id) {",
              "    seg[id << 1] += lazy[id]; seg[id << 1 | 1] += lazy[id];",
              "    lazy[id << 1] += lazy[id]; lazy[id << 1 | 1] += lazy[id];",
              "    lazy[id] = 0;",
              "}",
              "void update(int u, int v, int x, int id = 1, int l = 1, int r = n) {",
              "    if (l > r || r < u || v < l) return ;",
              "    if (u <= l && r <= v) {",
              "        seg[id] += x; lazy[id] += x;",
              "        return ;",
              "    }",
              "    pushdown(id);",
              "    int mid = l + r >> 1;",
              "    update(u, v, x, id << 1, l, mid);",
              "    update(u, v, x, id << 1 | 1, mid + 1, r);",
              "    seg[id] = max(seg[id << 1], seg[id << 1 | 1]);",
              "}",
              "int get(int u, int v, int id = 1, int l = 1, int r = n) {",
              "    if (l > r || r < u || v < l) return -INF;",
              "    if (u <= l && r <= v) return seg[id];",
              "    pushdown(id);",
              "    int mid = l + r >> 1;",
              "    return max(",
              "        get(u, v, id << 1, l, mid),",
              "        get(u, v, id << 1 | 1, mid + 1, r)",
              "    );",
              "}"
        ],
        "description": "seg_up:uv+=x,get:maxuv"
      },
    "sangnguyento": {
        "prefix": "#sangnt",
        "body": [
          "void sangnt(vector<int> &p, int n = 1e7) {",
          "    vector<bool> nt(n, 1);",
          "    for (int i = 3; i*i < n; i += 2) if (nt[i])",
          "        for (int j = i*i ; j < n; j += i)",
          "            nt[j] = 0;",
          "    p.assign(1, 2);",
          "    for (int i = 3; i < n; i += 2) if (nt[i])",
          "        p.push_back(i);",
          "}"
        ],
        "description": "sangnguyento"
      },
    "struct_modulo": {
        "prefix": "#mod",
        "body": [
          "struct Z {",
          "    int value;",
          "",
          "    Z (int x) { value = norm(x); }",
          "    Z operator + (const Z& rhs) const { ",
          "        int sum = (value + rhs.value) % MOD;",
          "        return Z(sum);",
          "    } ",
          "    Z operator - (const Z& rhs) const {",
          "        int minus = (value - rhs.value + MOD) % MOD;",
          "        return Z(minus);",
          "    }",
          "    Z operator * (const Z& rhs) const {",
          "        int mul = value * rhs.value % MOD;",
          "        return Z(mul);",
          "    }",
          "    Z operator / (const Z& rhs) const {",
          "        int div = value * fpow(rhs.value, MOD - 2, MOD) % MOD;",
          "        return Z(div);",
          "    }",
          "",
          "    int norm(int x) { return (x % MOD + MOD) % MOD; }",
          "",
          "    friend ostream& operator<<(std::ostream& o, const Z& z) {",
          "        return o << z.value;",
          "    }",
          "};"
        ],
        "description": "struct_modulo"
      },
    "solvecodemau": {
        "prefix": "#codemausolve",
        "body": [
          "bool solve(ifstream &cin, ofstream &cout) {"
        ],
        "description": "solvecodemau"
      },
    "filecodemau": {
        "prefix": "#codemaufile",
        "body": [
          "string LINK = \"E:\";",
          "ifstream filenum((LINK+\"/VScode/C++/Online/filenum.txt\").c_str());",
          "string finp = \"\", fout = \"\";",
          "filenum >> finp >> fout;",
          "ifstream cin(finp.c_str());",
          "ofstream cout(fout.c_str());"
        ],
        "description": "filecodemau"
      },
      "temp_playcode": {
        "prefix": "#plc",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "",
          "signed main() {",
          "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "    #ifndef ONLINE_JUDGE",
          "        freopen(\"ab.inp\", \"r\", stdin);",
          "        freopen(\"ab.out\", \"w\", stdout);",
          "    #endif",
          "    ",
          "    return 0;",
          "}"
        ],
        "description": "temp_playcode"
      },
    "dijkstra": {
      "prefix": "#dijkstra",
      "body": [
        "int f[N];",
        "void dijkstra(int node) {",
        "    memset(f, 0x3f, sizeof f);",
        "    priority_queue<II, vector<II>, greater<II>> q;",
        "    q.push({0, node});",
        "    f[node] = 0;",
        "    while (!q.empty()) {",
        "        II u = q.top(); q.pop();",
        "        if (u.fi != f[u.se])",
        "            continue;",
        "        for (II v: adj[u.se]) {",
        "            if (mini(f[v.se], f[u.se] + v.fi)) {",
        "                q.push({f[v.se], v.se});",
        "            }",
        "        }",
        "    }",
        "}"
      ],
      "description": "dijkstra"
    },
    "fast_read": {
      "prefix": "#fast_read",
      "body": [
        "void read(int &x) {",
        "    x = 0;",
        "    for (char c = getchar(); c > 47 && c < 58; c = getchar())",
        "        x = (x << 1) + (x << 3) + c - 48;",
        "}"
      ],
      "description": "fast_read"
    },
    "nen_day_so(roi_rat)": {
        "prefix": "#compress",
        "body": [
          "void compress(vector<int> &a) {",
          "    set<int> s(a.begin(), a.end());",
          "    vector<int> b(s.begin(), s.end());",
          "    for (int &i: a) i = lower_bound(b.begin(), b.end(), i) - b.begin() + 1;",
          "}"
        ],
        "description": "nen_day_so(roi_rat)"
      },
    "define_long_double": {
        "prefix": "#defld",
        "body": [
          "#define ld long double",
          "#define thapphan(x) cout << fixed << setprecision((x))",
          "#define IId pair<ld,ld>"
        ],
        "description": "define_long_double"
      },
    "define_pair": {
        "prefix": "#defpair",
        "body": [
          "#define II pair<int,int>",
          "#define fi first",
          "#define se second"
        ],
        "description": "define_pair"
      },
    "define_vector": {
        "prefix": "#defvec",
        "body": [
          "#define vi vector<int>",
          "#define vvi vector<vi>",
          "#define vii vector<II>",
          "#define mii unordered_map<int, int>",
          "#define all(a) (a).begin(), (a).end()",
          "#define lower(a, x) (int)(lower_bound(all(a), (x))-(a).begin())",
          "#define upper(a, x) (int)(upper_bound(all(a), (x))-(a).begin())",
          "#define delet(a) sort(all(a));(a).erase(unique(all(a)),(a).end())",
          "#define pf push_front",
          "#define pb push_back",
          "#define pof pop_front",
          "#define pob pop_back"
        ],
        "description": "define_vector"
      },
      "maximize": {
        "prefix": "#maxi",
        "body": [
          "template<class X, class Y> bool maxi(X& x, const Y y) {",
          "    if (x < y) return x = y, 1;",
          "    return 0;",
          "}"
        ],
        "description": "maximize"
      },
      "minimize": {
        "prefix": "#mini",
        "body": [
          "template<class X, class Y> bool mini(X& x, const Y y) {",
          "    if (x > y) return x = y, 1;",
          "    return 0;",
          "}"
        ],
        "description": "minimize"
      },
    "define_x12y12": {
        "prefix": "#defxy",
        "body": [
          "#define x1 asdfegsdth",
          "#define y1 sdfgasrgse",
          "#define x2 dfghwgedgs",
          "#define y2 fghjshrthy",
          "#define data xiusdhfaiu"
        ],
        "description": "define_x12y12"
      },
    "define_bitmask": {
        "prefix": "#defmsk",
        "body": [
          "#define MASK(i) (int)(1LL << (i))",
          "#define SET1(msk, i) (int)((msk) | MASK(i))",
          "#define SET0(msk, i) (int)((msk) & ~MASK(i))",
          "#define BIT(msk, i) (int)(((msk) >> (i)) & 1ll)",
          "#define cnt1(x) (int)__builtin_popcountll((int)(x))",
          "#define logg(x) (int)__builtin_clzll((int)(x))",
          "#define pos1(x) (int)__builtin_ctzll((int)(x))"
        ],
        "description": "define_bitmask"
      },
      "for_subset": {
        "prefix": "#forsubset",
        "body": [
          "for (int x = msk; x; x = (x - 1) & msk) {",
          "",
          "}"
        ],
        "description": "for_subset"
      },
      "duyet_bitmask": {
        "prefix": "#forbit1",
        "body": [
          "for (int tmp = msk; tmp > 0; tmp ^= tmp & -tmp) {",
          "    int i = __builtin_ctz(tmp & -tmp);",
          "    ",
          "}",
        ],
        "description": "duyet_bitmask"
      },
    "dp_bitmask": {
        "prefix": "#dp_bitmask",
        "body": [
          "int n; cin >> n;",
          "vector<int> a(n);",
          "for (int i = 0; i < n; ++i) cin >> a[i];",
          "",
          "int M = (1 << n);",
          "vector<int> f(M, -1);",
          "for (int msk = 1; msk < M; ++msk) {",
          "    vector<int> bit0, bit1;",
          "    for (int i = 0; i < n; ++i)",
          "        if (BIT(msk, i)) bit1.pb(i);",
          "        else bit0.pb(i);",
          "    ",
          "    for (int i : bit0) {",
          "        int newmsk = SET1(msk, i);",
          "        for (int j : bit1) {",
          "",
          "        }",
          "    }",
          "}"
        ],
        "description": "dp_bitmask"
      },
    "nhap_mang_2_chieu": {
        "prefix": "#nm2",
        "body": [
            "for (int i = 0; i < n; ++i)",
            "    for (int j = 0; j < n; ++j)",
            "        cin >> a[i][j];"
        ],
        "description": ""
    },
    "nhap_mang_1_chieu": {
        "prefix": "#nm1",
        "body": [
            "for (int i = 0; i < n; ++i)",
            "    cin >> a[i];"
        ],
        "description": ""
    },
    "in_mang_2_chieu": {
        "prefix": "#im2c",
        "body": [
            "for (int i = 0; i < n; ++i) {",
            "        for (int j = 0; j < m; ++j) cout << a[i][j] << ' ';",
            "        cout << '\\n';",
            "    }"
        ],
        "description": "in_mang_2_chieu"
    },
    "in_mang_1chieu": {
        "prefix": "#im1c",
        "body": [
            "for (int i = 0; i < n; ++i) cout << a[i] << ' '; cout << '\\n';"
        ],
        "description": "in_mang_1chieu"
    },
    "a^b%m": {
        "prefix": "#PowMOD",
        "body": [
            "int Pow(int a, int b, int M) {",
            "    a %= M;",
            "    if (b == 0) return 1;",
            "    if (b == 1) return a %M;",
            "    int t = 1;",
            "    while (b) {",
            "        if (b & 1) t = t*a %M;",
            "        a = a*a %M;",
            "        b >>= 1;",
            "    }",
            "    return t;",
            "}"
        ],
        "description": "a^b%m"
    },
    "a^b": {
        "prefix": "#Pow",
        "body": [
            "int Pow(int a, int b) {",
            "    if (b == 0) return 1;",
            "    if (b == 1) return a;",
            "    int t = 1;",
            "    while (b) {",
            "        if (b & 1) t = t*a;",
            "        a = a*a;",
            "        b >>= 1;",
            "    }",
            "    return t;",
            "}"
        ],
        "description": "a^b"
    },
    "a^*b%M": {
        "prefix": "#PowMul",
        "body": [
            "int Pow(int a, int b, int M) { // Mul(), phi() (replace M-1 if M is prime)",
            "    a %= M; b %= phi(M);",
            "    if (b == 0) return 1;",
            "    if (b == 1) return a %M;",
            "    int t = 1;",
            "    while (b) {",
            "        if (b & 1) t = Mul(t, a, M) %M;",
            "        a = Mul(a, a, M) %M;",
            "        b >>= 1;",
            "    }",
            "    return t;",
            "}"
        ],
        "description": "a^*b%M"
    },
    "a*b%M": {
        "prefix": "#Mul",
        "body": [
            "int Mul(int a, int b, int M) {",
            "    a %= M; b %= M;",
            "    if (a == 0 || b == 0) return 0;",
            "    if (b == 1) return a %M;",
            "    int t = 0;",
            "    while (b) {",
            "        if (b & 1) t = (t+a) %M;",
            "        a = (a+a) %M;",
            "        b >>= 1;",
            "    }",
            "    return t;",
            "}"
        ],
        "description": "a*b%M"
    },
    "nghich_dao_euclid": {
        "prefix": "#euclid",
        "body": [
            "int euclid(int a, int m) {",
            "    int xa = 1, xm = 0; int mm = m;",
            "    while (m != 0) {",
            "        swap(xa -= a/m*xm, xm);",
            "        swap(a %= m, m);",
            "    }",
            "    if (xa >= 0) return xa;",
            "    else return xa + mm;",
            "}"
        ],
        "description": "nghich_dao_euclid"
    },
    "euclidswap": {
        "prefix": "euclidswap",
        "body": [
          "int euclid2(int a, int m) {",
          "    int xa = 1, xm = 0; int mm = m;",
          "    while (m != 0) {",
          "        swap(xm, xa -= a/m*xm);",
          "        swap(m, a %= m);",
          "    }",
          "    if (xa >= 0) return xa;",
          "    else return xa + mm;",
          "}"
        ],
        "description": "euclidswap"
      },
    "kiem_tra_nguyen_to_O(sqrt(n)/3)": {
        "prefix": "#isPrime",
        "body": [
            "bool isPrime(int x) {",
            "    if (x == 2 || x == 3) return 1;",
            "    if (x<2 || x%2 == 0 || x%3 == 0) return 0;",
            "    for (int i = 5; i*i <= x; i += 6)",
            "        if (x%i == 0 || x%(i+2) == 0)",
            "            return 0;",
            "    return 1;",
            "}"
        ],
        "description": "kiem_tra_nguyen_to_O(sqrt(n)/3)"
    },
    "phi_euler": {
        "prefix": "#phi",
        "body": [
            "int phi(int n) {",
            "    if (n == 0) return 0;",
            "    int ans = n;",
            "    for (int x = 2; x*x <= n; ++x) {",
            "        if (n % x == 0) {",
            "            ans -= ans / x;",
            "            while (n % x == 0) n /= x;",
            "        }",
            "    }",
            "    if (n > 1) ans -= ans / n;",
            "    return ans;",
            "}"
        ],
        "description": "phi_euler"
    },
    "sang_phi_euler": {
        "prefix": "#sangphi",
        "body": [
            "vector<int> sangphi(int N = 1e7+1) {",
            "    vector<int> phi(N);",
            "    for (int i = 1; i < N; ++i)",
            "        phi[i] = i;",
            "    for (int i = 2; i < N; ++i)",
            "        if (phi[i] == i)",
            "            for (int j = i; j < N; j += i)",
            "                phi[j] -= phi[j] / i;",
            "    return phi;",
            "}"
        ],
        "description": "sang_phi_euler"
    },
    "lpf_sieve": {
      "prefix": "#LPF",
      "body": [
        "const int N = 1e7+5;",
        "int lpf[N];",
        "void LPF(int n) {",
        "    for (int i = 2; i < n; i += 2) lpf[i] = 2;",
        "    for (int i = 3; i < n; i += 2) {",
        "        if (!lpf[i]) {",
        "            lpf[i] = i;",
        "            for (int j = i*i; j < n; j += i) lpf[j] = i;",
        "        }",
        "    }",
        "}"
      ],
      "description": "lpf_sieve"
    },
    "lpf_sieve_fast": {
      "prefix": "#LPFfast",
      "body": [
        "const int N = 1e7+5;",
        "int prime[N], lpf[N];",
        "void sieve(int n = N) {",
        "    prime[0] = 2;",
        "    int sz = 1;",
        "    for (int i = 2; i < n; i += 2) lpf[i] = 2;",
        "    for (int i = 3; i < n; i += 2) {",
        "        if (!lpf[i]) prime[sz++] = (lpf[i] = i);",
        "        for (int j = 0; j < sz && prime[j] <= lpf[i] && i * prime[j] < n; ++j)",
        "            lpf[i * prime[j]] = prime[j];",
        "    }",
        "}"
      ],
      "description": "lpf_sieve_fast"
    },
    "lpf_sieve_vector": {
        "prefix": "#LPFvector",
        "body": [
            "vector<int> prime, lpf;",
            "void sieve(int lim = 1e7+1) {",
            "    prime.assign(1, 2);",
            "    lpf.assign(lim + 1, 2);",
            "    for (int i = 3; i <= lim; i += 2) {",
            "        if (lpf[i] == 2) prime.push_back(lpf[i] = i);",
            "        for (int j = 0; j < prime.size() && prime[j] <= lpf[i] && i * prime[j] <= lim; ++j)",
            "            lpf[i * prime[j]] = prime[j];",
            "    }",
            "}"
        ],
        "description": "lpf_sieve_vector"
    },
    "ktnt_miller": {
        "prefix": "#miller",
        "body": [
            "bool check_composite(int n, int a, int d, int s) { // Pow()",
            "    int x = Pow(a, d, n);",
            "    if (x == 1 || x == n - 1)",
            "        return false;",
            "    for (int r = 1; r < s; ++r) {",
            "        x = (int)x * x % n;",
            "        if (x == n - 1)",
            "            return false;",
            "    }",
            "    return true;",
            "}",
            "bool Miller(int n) { // check_composite(), Pow()",
            "    if (n < 2)",
            "        return false;",
            "    int r = 0;",
            "    int d = n - 1;",
            "    while ((d & 1) == 0) {",
            "        d >>= 1;",
            "        ++r;",
            "    }",
            "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {",
            "        if (n == a)",
            "            return true;",
            "        if (check_composite(n, a, d, r))",
            "            return false;",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "ktnt_miller"
    },
    "dem_so_nguyen_to_<x": {
        "prefix": "#pint",
        "body": [
            "const int MOD = (int)(1e9+7);",
            "const int N = (int)(1e3+1);",
            "int np[N];",
            "int p[N], pp=0;",
            "map<int, int> Phi[N];",
            "void eratos() {",
            "    for(int i=2; i<=N; ++i) {",
            "        if (!np[i]) np[i] = p[++pp] = i;",
            "        int j = 1;",
            "        while (j <= pp && p[j] <= np[i] && p[j]*i <= N) {",
            "            np[p[j]*i] = p[j];",
            "            ++j;",
            "        }",
            "    }",
            "}",
            "int power(int a, int k) {",
            "    int P = 1;",
            "    while (k) {",
            "        if (k & 1) P = P*a;",
            "        k >>= 1; a = a*a;",
            "    }",
            "    return P;",
            "}",
            "int power(int a, int k, int M) {",
            "    int P = 1;",
            "    for (a = a%M; k; k >>= 1) {",
            "        if (k & 1) P = P*a %M;",
            "        a = a*a %M;",
            "    }",
            "    return P;",
            "}",
            "int root(int n, int k) { // power( , , ), power( , )",
            "    int x = pow(n, 1.0/k);",
            "    while (power(x, k)%MOD == power(x, k, MOD) && power(x, k) < n) ++x;",
            "    while (power(x, k)%MOD != power(x, k, MOD) || power(x, k) > n) --x;",
            "    return x;",
            "}",
            "int phi(int x, int a) {",
            "    if (Phi[a].count(x)) return Phi[a][x];",
            "    if (a == 1) return (x+1)/2;",
            "    int res = phi(x, a-1) - phi(x/p[a], a-1);",
            "    return Phi[a][x] = res;",
            "}",
            "int pi(int x) { // x là số nguyên tố lớn thứ pi(x) // root(), power( , , ), power( , ), erator() first",
            "    if (x < N)",
            "        return upper_bound(p+1, p+pp+1, x) - (p+1);",
            "    int a = pi(root(x, 4));",
            "    int b = pi(root(x, 2));",
            "    int c = pi(root(x, 3));",
            "    int Sum = phi(x, a) + (b+a-2)*(b-a+1)/2;",
            "    for (int i = a+1; i <= b; ++i)",
            "        Sum -= pi(x/p[i]);",
            "    for (int i = a+1; i <= c; ++i) {",
            "        int bi = pi(root(x/p[i], 2));",
            "        for (int j = i; j <= bi; ++j)",
            "        Sum -= pi(x/p[i]/p[j]) - (j-1);",
            "    }",
            "    return Sum;",
            "}"
        ],
        "description": "dem_so_nguyen_to_<x"
    },
    "pt_diophantine": {
        "prefix": "#diophan",
        "body": [
            "int diophantine(int a, int b, int c) {",
            "    int u = __gcd(a,b);",
            "    if (c%u != 0) return 0;",
            "    for (int i = 1; ; ++i) {",
            "        if ((c-a*i)%b == 0) {",
            "            int t = (c-a*i)/b; a/=u;",
            "            if (t%a == 0) t /= a; else t = t/a+1;",
            "            return t;",
            "        }",
            "    }",
            "}"
        ],
        "description": "pt_diophantine"
    },
    "pt_bac_1,2": {
        "prefix": "#ptb12",
        "body": [
            "ld ptb1(ld a, ld b) { // ax + b = 0",
            "    if (a == 0) {",
            "        if (b == 0) return 1e18; // vô số ng",
            "        return -1e18; // vô ng",
            "    }",
            "    return (-b)/a;",
            "}",
            "pair<ld, ld> ptb2(ld a, ld b, ld c) { // ax^2 + bx + c = 0",
            "    if (a == 0) {",
            "        ld x = ptb1(b, c);",
            "        return {x, x};",
            "    } else {",
            "        ld delta = b*b - 4*a*c;",
            "        if(delta > 0) {",
            "            ld x1 = (-b + sqrt(delta)) / (2*a);",
            "            ld x2 = (-b - sqrt(delta)) / (2*a);",
            "            return {x1, x2};",
            "        } else if ( delta == 0) {",
            "            return {-b/2*a, -b/2*a}; // ng kép",
            "        } else {",
            "            return {-1e18, -1e18}; // vô ng",
            "        }",
            "    }",
            "}"
        ],
        "description": "pt_bac_1,2"
    },
    "pt_y=ax+b": {
        "prefix": "#ptdt",
        "body": [
            "pair<ld, ld> ptdt(ld xa, ld ya, ld xb, ld yb) {",
            "    // trả về {a, b} mà y = ax + b đi qua A, B",
            "    // giải hệ { ya = xa*a + b && yb = xb*a + b",
            "    // => b = ya - xa*a",
            "    // => yb = xb*a + ya-xa*a",
            "    // => yb - ya = a*(xb-xa)",
            "    // => a = (yb-ya) / (xb-xa)",
            "    ld a = (yb-ya) / (xb-xa);",
            "    ld b = ya - xa*a;",
            "    return {a, b};",
            "}"
        ],
        "description": "pt_y=ax+b"
    },
    "kt_3diem_thang_hang": {
        "prefix": "#chech3point",
        "body": [
            "bool check3point(ld xa, ld ya, ld xb, ld yb, ld xc, ld yc) {",
            "    if (xa == xb) return (xa == xc);",
            "    if (ya == yb) return (ya == yc);",
            "    if (xb == xc) return (xb == xa);",
            "    if (yb == yc) return (yb == ya);",
            "    if (xa == xc) return (xa == xb);",
            "    if (ya == yc) return (ya == yb);",
            "    return ((xc-xa)/(xb-xa) == (yc-ya)/(yb-ya));",
            "}",
            "bool checkpoints(vector<pair<ld, ld>> point) { // dt ko // voi truc Ox hoac Oy // ptdt()",
            "    if (point.size() <= 2) return 1;",
            "    pair<ld, ld> d = ptdt(point[0].first, point[0].second, point[1].first, point[1].second);",
            "    for (int i = 2; i < point.size(); ++i) {",
            "        if (point[i].second != d.first * point[i].first + d.second)",
            "            return 0;",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "kt_3diem_thang_hang"
    },
    "tong_binh_phuong": {
        "prefix": "#tongbp",
        "body": [
            "int tongbinhphuong(int N, int M) { // = ( 1^2 + 2^2 + 3^2 + ... + n^2 )%M (số hình vg trong nXn)",
            "    long long a = N, b = N+1, c = 2*N+1;",
            "    bool s2 = 1, s3 = 1;",
            "    if (c%3 == 0) c /= 3, s3 = 0;",
            "    if (a%2 == 0) a /= 2, s2 = 0;",
            "    if (s3 && a%3 == 0) a /= 3, s3 = 0;",
            "    if (s2 && b%2 == 0) b /= 2, s2 = 0;",
            "    if (s3 && b%3 == 0) b /= 3, s3 = 0;",
            "    a %= M; b %= M; c %= M;",
            "    return a*b %M *c %M;",
            "}",
            "int tongtinhtien(int dau, int cuoi, int kc) {",
            "    cuoi -= (cuoi-dau)%kc;",
            "    int ssh = (cuoi-dau)/kc+1;",
            "    if (ssh%2 == 0)",
            "        return (dau+cuoi) * (ssh/2);",
            "    else",
            "        return (dau+cuoi)/2 * ssh;",
            "}"
        ],
        "description": "tong_binh_phuong"
    },
    "lcm_gcd": {
        "prefix": "#gcdlcm",
        "body": [
            "int gcd(int a, int b) {",
            "    while (b != 0) swap(b, a %= b); ",
            "    return a; ",
            "}",
            "int lcm(int a, int b) {",
            "    if (a > b) return a/gcd(a,b)*b;",
            "    else return b/gcd(a,b)*a;",
            "}"
        ],
        "description": "lcm_gcd"
    },
    "logx(y)": {
        "prefix": "#log",
        "body": [
            "#define log2(n) 63 - __builtin_clzll(n)",
            "ld Log(ld a, ld b) {",
            "    return (ld)log(b) / (ld)log(a); // log is ln",
            "}"
        ],
        "description": "logx(y)"
    },
    "C2,C3": {
        "prefix": "#ncr23",
        "body": [
            "int C2(int n) { // số cách chọn 2 số từ n số",
            "    return n * (n-1) /2;",
            "    // return n %M * (n-1) %M * 500000004 %M;",
            "}",
            "int C3(int n) { // số cách chọn 3 số từ n số",
            "    return n * (n-1) * (n-2) / 6;",
            "    // return n %MOD * (n-1) %MOD * (n-2) %MOD * 166666668 %MOD;",
            "}",
            "int C(int k, int n) { // số cách chọn k số từ n số",
            "    int kq = n;",
            "    for (int i = n-1; i > n-k; --i) kq *= i;",
            "    int t = 1;",
            "    for (int i = 2; i <= k; ++i) t *= i;",
            "    return kq/t;",
            "}"
        ],
        "description": "C2,C3"
    },
    "mybignum": {
      "prefix": "#bignum_deque",
      "body": [
        "#define int long long",
        "#define BASE (int)(1e9)",
        "//_____________________________________________________________________________________________",
        "",
        "",
        "#define FOR(_bien,_dau,_cuoi) for(int _bien=(_dau);_bien<=(_cuoi);_bien++)",
        "struct big {",
        "    bool am=0;",
        "    deque<int>so;",
        "};",
        "int demscs(int x);",
        "string tostr(int x);",
        "string tostr(big x);",
        "int tonum(string x);",
        "int tonum(big x);",
        "big tobig(int x);",
        "big tobig(string x);",
        "void xuat(big x);",
        "bool operator>(big a, big b);",
        "big operator+(big a, big b);",
        "big operator-(big a, big b);",
        "big nhan(big a, int b);",
        "big operator*(big a, big b);",
        "big operator/(big a, big b);",
        "big operator%(big a, big b);",
        "//---------------------------------------------------------------------------------------------------",
        "int demscs(int x) {",
        "    int r = 0;",
        "    while (x > 0) {",
        "        r++;",
        "        x /= 10;",
        "    }",
        "    return r;",
        "}",
        "string tostr(int x) {",
        "    string r = \"\";",
        "    while (x > 0) {",
        "        r = (char)(x%10+'0') + r;",
        "        x /= 10;",
        "    }",
        "    return r;",
        "}",
        "string tostr(big x) {",
        "    string r = \"\";",
        "    FOR (i, 0, x.so.size()-1) r = tostr(x.so[i]) + r;",
        "    return r;",
        "}",
        "int tonum(string x) {",
        "    int r = 0;",
        "    FOR (i, 0, x.size()-1) r = r*10 + x[i]-'0';",
        "    return r;",
        "}",
        "int tonum(big x) {",
        "    int r = 0;",
        "    FOR (i, 0, x.so.size()-1) r = r*BASE + x.so[i];",
        "    return r;",
        "}",
        "big tobig(int x) {",
        "    big r;",
        "    while (x > 0) {",
        "        r.so.push_back(x %BASE);",
        "        x /= BASE;",
        "    }",
        "    return r;",
        "}",
        "big tobig(string s) {",
        "    big r; ",
        "    if (s[0] == '-') { r.am = 1; s.erase(0,1); }",
        "    int v = s.size();",
        "    while (v > 0) {",
        "        int d = 0;",
        "        if (v > 9) FOR (i, v-9, v-1) d = d*10 + s[i]-'0';",
        "        else FOR (i, 0, v-1) d = d*10 + s[i]-'0';",
        "        r.so.push_back(d);",
        "        v -= 9;",
        "    }",
        "    return r;",
        "}",
        "void xuat(big x) {",
        "    if (x.am) cout << '-';",
        "    cout << x.so.back(); //cout << ' ';",
        "    if (x.so.size() == 1) return;",
        "    for (int i = x.so.size()-2; i >= 0; i--) {",
        "        int d = demscs(x.so[i]);",
        "        FOR (j, d, 8) cout << 0; ",
        "        cout << x.so[i]; //cout << ' ';",
        "    }",
        "}",
        "//---------------------------------------------------------------------------------------------------",
        "bool operator>(big a, big b) {",
        "    if (a.so.size() > b.so.size()) return 1;",
        "    else if (a.so.size() < b.so.size()) return 0;",
        "    for (int i = a.so.size()-1; i >= 0; i--) {",
        "        if (a.so[i] > b.so[i]) return 1;",
        "        else if (a.so[i] < b.so[i]) return 0;",
        "    }",
        "    return 0;",
        "}",
        "bool operator<(big a, big b) {",
        "    if (a.so.size() < b.so.size()) return 1;",
        "    for (int i = a.so.size()-1; i >= 0; i--) {",
        "        if (a.so[i] < b.so[i]) return 1;",
        "        else if (a.so[i] > b.so[i]) return 0;",
        "    }",
        "    return 0;",
        "}",
        "bool operator==(big a, big b) {",
        "    if (a.so.size() != b.so.size()) return 0;",
        "    for (int i = a.so.size()-1; i >= 0; i--) if (a.so[i] != b.so[i]) return 0;",
        "    return 1;",
        "}",
        "big operator+(big a, big b) {",
        "    if (a.am || b.am) {",
        "        if (a.am && !b.am) { a.am = 0; return b-a; }",
        "        if (!a.am && b.am) { b.am = 0; return a-b; }",
        "    }",
        "    if (a > b) swap(a, b);",
        "    if (a.so.size() == 0) return b;",
        "    FOR (i, 0, a.so.size()-1) {",
        "        b.so[i] += a.so[i];",
        "        if (b.so[i] >= BASE) {",
        "            if (b.so.size() == i+1) b.so.push_back(0);",
        "            b.so[i+1] += b.so[i] /BASE;",
        "            b.so[i] %= BASE;",
        "        }",
        "    }",
        "    return b;",
        "}",
        "big operator-(big a, big b) {",
        "    if (b.am) { b.am=0; return a+b; }",
        "    if (a.am) { b.am=0; big t=a+b; t.am=0; return t; }",
        "    if (a.am && !b.am) { a.am=0; return b-a; }",
        "    if (!a.am && b.am) { b.am=0; return a-b; }",
        "    if (b > a) { big r=b-a; r.am=1; return r; }",
        "    int nho = 0, i = 0;",
        "    for (; i < b.so.size(); i++) {",
        "        a.so[i] -= b.so[i]+nho; nho = 0;",
        "        while (a.so[i] < 0) a.so[i] +=BASE, nho++;",
        "    }",
        "    while (nho > 0) {",
        "        a.so[i] -= nho; nho = 0;",
        "        while (a.so[i] < 0) a.so[i] += BASE, nho++;",
        "        i++;",
        "    }",
        "    return a;",
        "}",
        "big nhan(big a, int b) {",
        "    int nho=0;",
        "    FOR (i, 0, a.so.size()-1) {",
        "        a.so[i] = a.so[i]*b + nho;",
        "        nho = a.so[i] /BASE;",
        "        a.so[i] %=  BASE;",
        "    }",
        "    while (nho > 0) {",
        "        a.so.push_back(nho);",
        "        nho = a.so.back() /BASE;",
        "        a.so.back() %= BASE;",
        "    }",
        "    return a;",
        "}",
        "big operator*(big a, big b) {",
        "    if (a.am && b.am) a.am=0;",
        "    else if (!a.am && b.am) a.am=1;",
        "    big r;",
        "    FOR (i, 0, b.so.size()-1) {",
        "        big t = nhan(a, b.so[i]);",
        "        FOR (j, 0, i-1) t.so.push_front(0);",
        "        r = r+t;",
        "    }",
        "    return r;",
        "}",
        "/*",
        "98765432 187654321 / 134 625724573",
        "987654312           | 737055",
        "        9 987654321 |",
        "          114987   |",
        "          114882   |",
        "             105   |",
        "*/",
        "big operator/(big a, big b) {",
        "    if (a.am && b.am) a.am=0;",
        "    else if (!a.am && b.am) a.am=1;",
        "    big r; ",
        "    r.so.push_back(BASE-1);",
        "    while (a > r*b) r.so.push_back(BASE-1);",
        "    for (int i = r.so.size()-1; i >= 0; i--) {",
        "        int mi = 1, ma = 999999999;",
        "        while (1) {",
        "            if (ma-mi < 2) break;",
        "            r.so[i] = (mi+ma)/2;",
        "            if (r*b > a) ma = r.so[i];",
        "            else mi = r.so[i];",
        "        }",
        "        while (r*b > a) r.so[i]--;",
        "        while (a > r*b) r.so[i]++;",
        "    }",
        "    while (a > r*b) r.so[0]++;",
        "    while (r*b > a) r.so[0]--;",
        "    return r;",
        "}",
        "big operator%(big a, big b) {",
        "    return (a-((a/b)*b));",
        "}",
        "big operator^(big a, big b) {",
        "    if (b == tobig(0)) return tobig(1);",
        "    if (b == tobig(1)) return a;",
        "    if (b.so[0]%2 == 0)",
        "    {",
        "        big t = a^(b/tobig(2));",
        "        return t*t;",
        "    }",
        "    return (a^(b-tobig(1)))*a;",
        "}"
      ],
      "description": "mybignum"
    },
    "mybignumstr": {
      "prefix": "#bignum_string",
      "body": [
        "bool sostr(string a, string b);",
        "string tongstr(string a, string b);",
        "string hieustr(string a, string b);",
        "string tichstr(string a, string b);",
        "string xxx(string a, string b);",
        "string divstr(string a, string b);",
        "string modstr(string a, string b);",
        "string powstr(string a, string b);",
        "string gtstr(string a, string b);",
        "string nCrstr(string a, string b);",
        "",
        "bool sostr(string a, string b)",
        "{",
        "    while (a[0]=='0') a.erase(0,1);",
        "    while (b[0]=='0') b.erase(0,1);",
        "    if (a.size()>b.size()) return 1;",
        "    if (a.size()<b.size()) return 0;",
        "    for (long long i=0; i<a.size(); i++)",
        "    {",
        "        if (a[i]>b[i]) return 1; if (a[i]<b[i]) return 0;",
        "    } ",
        "    return 0;",
        "}",
        "",
        "string hieustr(string a, string b)",
        "{",
        "    if (b[0]=='-') { b.erase(0,1); return tongstr(a,b); }",
        "    if (a[0]=='-') { a.erase(0,1); return ('-'+tongstr(a,b)); }",
        "    string dau=\"\";",
        "    if (sostr(b,a)==1) { dau=a; a=b; b=dau; dau=\"-\"; }",
        "    if (a==b) return \"0\";",
        "    ",
        "    while (a.size()>b.size()) b='0'+b;",
        "    while (a.size()<b.size()) a='0'+a;",
        "    for (long long i=a.size()-1; i>=0; i--)       ",
        "    {",
        "        if (a[i]<b[i]) a[i]=a[i]+10,a[i-1]=a[i-1]-1;",
        "        a[i]=a[i]-b[i]+48;",
        "    }    ",
        "    while (a[0]=='0') a.erase(0,1);",
        "    return dau+a;",
        "}",
        "",
        "string tongstr(string a, string b)",
        "{",
        "    string dau=\"\";",
        "    if (a[0]=='-' && b[0]=='-') { dau=\"-\"; a.erase(0,1); b.erase(0,1); }",
        "    else if (a[0]=='-') { dau=a; a=b; b=dau; }",
        "    if (b[0]=='-' && a[0]!='-') { b.erase(0,1); return hieustr(a,b); }",
        "    ",
        "    long long x=0,nho=0;",
        "    while (a.size()>b.size()) b='0'+b;",
        "    while (a.size()<b.size()) a='0'+a;",
        "    for (long long i=a.size()-1; i>=0; i--)",
        "    {   ",
        "        x=(a[i]-48+b[i]-48+nho);",
        "        nho=x/10;",
        "        a[i]=x%10+48;",
        "    }",
        "    if (nho>0) a=to_string(nho)+a;",
        "    while (a[0]=='0') a.erase(0,1);",
        "    return dau+a;",
        "}",
        "",
        "string xxx(string a, long long c)",
        "{",
        "    long long x=0,nho=0;",
        "    for (long long i=a.size()-1; i>=0; i--)",
        "    { ",
        "        x=((a[i]-48)*c+nho);",
        "        nho=x/10;",
        "        a[i]=x%10+48;",
        "    }",
        "    if (nho>0) a=to_string(nho)+a;",
        "    return a;",
        "}",
        "",
        "string tichstr(string a, string b)",
        "{",
        "    if (a[0]=='-' && b[0]=='-') { a.erase(0,1); b.erase(0,1); return tichstr(a,b); }",
        "    if (a[0]=='-') { a.erase(0,1); return ('-'+tichstr(a,b)); }",
        "    if (b[0]=='-') { b.erase(0,1); return ('-'+tichstr(a,b)); }",
        "    string s=\"\",e=\"\";",
        "    for (long long i=b.size()-1; i>=0; i--) s=tongstr(s,xxx(a,b[i]-48)+e),e+=\"0\"; ",
        "    return s;",
        "}",
        "",
        "string divstr(string a, string b)",
        "{",
        "    if (a[0]=='-' && b[0]=='-') { a.erase(0,1); b.erase(0,1); return divstr(a,b); }",
        "    if (a[0]=='-') { a.erase(0,1); return ('-'+divstr(a,b)); }",
        "    if (b[0]=='-') { b.erase(0,1); return ('-'+divstr(a,b)); }",
        "    ",
        "    if (a==b) return \"1\";",
        "    if (sostr(b,a)==1) return \"0\";",
        "    ",
        "    string kq=\"9\"; ",
        "    while (sostr(tichstr(kq,b),a)==0) kq+=\"9\";",
        "    ",
        "    for (long long i=0; i<kq.size(); i++)",
        "    {",
        "        while (sostr(tichstr(kq,b),a)==1 && kq[i]>='0') kq[i]--;",
        "        kq[i]++;",
        "    }",
        "    kq[kq.size()-1]--;",
        "    ",
        "    while (kq[0]=='0') kq.erase(0,1);",
        "    return kq;",
        "}",
        "",
        "string modstr(string a, string b)",
        "{ return hieustr(a,tichstr(divstr(a,b),b)); }",
        "",
        "string powstr(string a, string b)",
        "{",
        "    if (b==\"0\") return \"1\";",
        "    string t=powstr(tichstr(a,a),divstr(b,\"2\"));",
        "    if ((b[b.size()-1])%2==1) t=tichstr(t,a);",
        "    return t;",
        "}"
      ],
      "description": "mybignumstr"
    },
    "": {
        "prefix": "#big_unsigned",
        "body": [
          "typedef vector<int> big;",
          "const int BASE = 1000;",
          "const int LENGTH = 3;",
          "big& fix(big &a) {",
          "    a.push_back(0);",
          "    for (int i = 0; i + 1 < a.size(); ++i) {",
          "        a[i + 1] += a[i] / BASE; a[i] %= BASE;",
          "        if (a[i] < 0) a[i] += BASE, --a[i + 1];",
          "    }",
          "    while (a.size() > 1 && a.back() == 0) a.pop_back();",
          "    return a;",
          "}",
          "big tobig(int x) {",
          "    big result;",
          "    while (x > 0) {",
          "        result.push_back(x % BASE);",
          "        x /= BASE;",
          "    }",
          "    return result;",
          "}",
          "big tobig(string s) {",
          "    big result(s.size() / LENGTH + 1);",
          "    for (int i = 0; i < s.size(); ++i) {",
          "        int pos = (s.size() - i - 1) / LENGTH;",
          "        result[pos] = result[pos] * 10 + s[i] - '0';",
          "    }",
          "    return fix(result), result;",
          "}",
          "int compare(big &a, big &b) {",
          "    if (a.size() != b.size()) return (int)a.size() - (int)b.size();",
          "    for (int i = 0; i < a.size(); ++i)",
          "        if (a[i] != b[i]) return a[i] - b[i];",
          "    return 0;",
          "}",
          "#define DEFINE_OPERATOR(x) bool operator x (big &a, big &b) { return compare(a, b) x 0; }",
          "DEFINE_OPERATOR(==)",
          "DEFINE_OPERATOR(!=)",
          "DEFINE_OPERATOR(>)",
          "DEFINE_OPERATOR(<)",
          "DEFINE_OPERATOR(>=)",
          "DEFINE_OPERATOR(<=)",
          "#undef DEFINE_OPERATOR",
          "void operator += (big &a, big b) {",
          "    a.resize(max(a.size(), b.size()));",
          "    for (int i = 0; i < b.size(); ++i)",
          "        a[i] += b[i];",
          "    fix(a);",
          "}",
          "void operator -= (big &a, big b) {",
          "    for (int i = 0; i < b.size(); ++i)",
          "        a[i] -= b[i];",
          "    fix(a);",
          "}",
          "void operator *= (big &a, int b) {",
          "    for (int i = 0; i < a.size(); ++i)",
          "        a[i] *= b;",
          "    fix(a);",
          "}",
          "void divide(big a, int b, big &q, int &r) {",
          "    for (int i = (int)a.size() - 1; i >= 0; --i) {",
          "        r = r * BASE + a[i];",
          "        q.push_back(r / b); r %= b;",
          "    }",
          "    reverse(q.begin(), q.end());",
          "    fix(q);",
          "}",
          "big operator + (big a, big b) { a += b; return a; }",
          "big operator - (big a, big b) { a -= b; return a; }",
          "big operator * (big a, int b) { a *= b; return a; }",
          "big operator / (big a, int b) {",
          "    big q; int r = 0;",
          "    divide(a, b, q, r);",
          "    return q;",
          "}",
          "int operator % (big a, int b) {",
          "    big q; int r = 0;",
          "    divide(a, b, q, r);",
          "    return r;",
          "}",
          "big operator * (big a, big b) {",
          "    big result (a.size() + b.size());",
          "    for (int i = 0; i < a.size(); ++i)",
          "        for (int j = 0; j < b.size(); ++j)",
          "            result[i + j] += a[i] * b[j];",
          "    return fix(result);",
          "}",
          "istream& operator >> (istream& cin, big &a) {",
          "    string s; cin >> s;",
          "    a = tobig(s);",
          "    return cin;",
          "}",
          "ostream& operator << (ostream& cout, const big &a) {",
          "    cout << a.back();",
          "    for (int i = (int)a.size() - 2; i >= 0; --i)",
          "        cout << setw(LENGTH) << setfill('0') << a[i];",
          "    return cout;",
          "}"
        ],
        "description": ""
      },
    "biginterger": {
        "prefix": "#bignum",
        "body": [
            "const int base = 1e9;",
            "const int base_digits = 9;",
            "",
            "struct big {",
            "    vector<int> a;",
            "    int sign;",
            "    big() :",
            "        sign(1) {",
            "    }",
            "    big(long long v) {",
            "        *this = v;",
            "    }",
            "    big(const string &s) {",
            "        read(s);",
            "    }",
            "    void operator=(const big &v) {",
            "        sign = v.sign;",
            "        a = v.a;",
            "    }",
            "    void operator=(long long v) {",
            "        sign = 1;",
            "        if (v < 0)",
            "            sign = -1, v = -v;",
            "        for (; v > 0; v = v / base)",
            "            a.push_back(v % base);",
            "    }",
            "    big operator+(const big &v) const {",
            "        if (sign == v.sign) {",
            "            big res = v;",
            "",
            "            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
            "                if (i == (int) res.a.size())",
            "                    res.a.push_back(0);",
            "                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);",
            "                carry = res.a[i] >= base;",
            "                if (carry)",
            "                    res.a[i] -= base;",
            "            }",
            "            return res;",
            "        }",
            "        return *this - (-v);",
            "    }",
            "    big operator-(const big &v) const {",
            "        if (sign == v.sign) {",
            "            if (abs() >= v.abs()) {",
            "                big res = *this;",
            "                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
            "                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
            "                    carry = res.a[i] < 0;",
            "                    if (carry)",
            "                        res.a[i] += base;",
            "                }",
            "                res.trim();",
            "                return res;",
            "            }",
            "            return -(v - *this);",
            "        }",
            "        return *this + (-v);",
            "    }",
            "    void operator*=(int v) {",
            "        if (v < 0)",
            "            sign = -sign, v = -v;",
            "        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
            "            if (i == (int) a.size())",
            "                a.push_back(0);",
            "            long long cur = a[i] * (long long) v + carry;",
            "            carry = (int) (cur / base);",
            "            a[i] = (int) (cur % base);",
            "            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
            "        }",
            "        trim();",
            "    }",
            "    big operator*(int v) const {",
            "        big res = *this;",
            "        res *= v;",
            "        return res;",
            "    }",
            "    friend pair<big, big> divmod(const big &a1, const big &b1) {",
            "        int norm = base / (b1.a.back() + 1);",
            "        big a = a1.abs() * norm;",
            "        big b = b1.abs() * norm;",
            "        big q, r;",
            "        q.a.resize(a.a.size());",
            "",
            "        for (int i = a.a.size() - 1; i >= 0; i--) {",
            "            r *= base;",
            "            r += a.a[i];",
            "            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
            "            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
            "            int d = ((long long) base * s1 + s2) / b.a.back();",
            "            r -= b * d;",
            "            while (r < 0)",
            "                r += b, --d;",
            "            q.a[i] = d;",
            "        }",
            "        q.sign = a1.sign * b1.sign;",
            "        r.sign = a1.sign;",
            "        q.trim();",
            "        r.trim();",
            "        return make_pair(q, r / norm);",
            "    }",
            "    big operator/(const big &v) const {",
            "        return divmod(*this, v).first;",
            "    }",
            "    big operator%(const big &v) const {",
            "        return divmod(*this, v).second;",
            "    }",
            "    void operator/=(int v) {",
            "        if (v < 0)",
            "            sign = -sign, v = -v;",
            "        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
            "            long long cur = a[i] + rem * (long long) base;",
            "            a[i] = (int) (cur / v);",
            "            rem = (int) (cur % v);",
            "        }",
            "        trim();",
            "    }",
            "    big operator/(int v) const {",
            "        big res = *this;",
            "        res /= v;",
            "        return res;",
            "    }",
            "    int operator%(int v) const {",
            "        if (v < 0)",
            "            v = -v;",
            "        int m = 0;",
            "        for (int i = a.size() - 1; i >= 0; --i)",
            "            m = (a[i] + m * (long long) base) % v;",
            "        return m * sign;",
            "    }",
            "    void operator+=(const big &v) {",
            "        *this = *this + v;",
            "    }",
            "    void operator-=(const big &v) {",
            "        *this = *this - v;",
            "    }",
            "    void operator*=(const big &v) {",
            "        *this = *this * v;",
            "    }",
            "    void operator/=(const big &v) {",
            "        *this = *this / v;",
            "    }",
            "    bool operator<(const big &v) const {",
            "        if (sign != v.sign)",
            "            return sign < v.sign;",
            "        if (a.size() != v.a.size())",
            "            return a.size() * sign < v.a.size() * v.sign;",
            "        for (int i = a.size() - 1; i >= 0; i--)",
            "            if (a[i] != v.a[i])",
            "                return a[i] * sign < v.a[i] * sign;",
            "        return false;",
            "    }",
            "    bool operator>(const big &v) const {",
            "        return v < *this;",
            "    }",
            "    bool operator<=(const big &v) const {",
            "        return !(v < *this);",
            "    }",
            "    bool operator>=(const big &v) const {",
            "        return !(*this < v);",
            "    }",
            "    bool operator==(const big &v) const {",
            "        return !(*this < v) && !(v < *this);",
            "    }",
            "    bool operator!=(const big &v) const {",
            "        return *this < v || v < *this;",
            "    }",
            "    void trim() {",
            "        while (!a.empty() && !a.back())",
            "            a.pop_back();",
            "        if (a.empty())",
            "            sign = 1;",
            "    }",
            "    bool isZero() const {",
            "        return a.empty() || (a.size() == 1 && !a[0]);",
            "    }",
            "    big operator-() const {",
            "        big res = *this;",
            "        res.sign = -sign;",
            "        return res;",
            "    }",
            "    big abs() const {",
            "        big res = *this;",
            "        res.sign *= res.sign;",
            "        return res;",
            "    }",
            "    long long longValue() const {",
            "        long long res = 0;",
            "        for (int i = a.size() - 1; i >= 0; i--)",
            "            res = res * base + a[i];",
            "        return res * sign;",
            "    }",
            "    friend big gcd(const big &a, const big &b) {",
            "        return b.isZero() ? a : gcd(b, a % b);",
            "    }",
            "    friend big lcm(const big &a, const big &b) {",
            "        return a / gcd(a, b) * b;",
            "    }",
            "    void read(const string &s) {",
            "        sign = 1;",
            "        a.clear();",
            "        int pos = 0;",
            "        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
            "            if (s[pos] == '-')",
            "                sign = -sign;",
            "            ++pos;",
            "        }",
            "        for (int i = s.size() - 1; i >= pos; i -= base_digits) {",
            "            int x = 0;",
            "            for (int j = max(pos, i - base_digits + 1); j <= i; ++j)",
            "                x = x * 10 + s[j] - '0';",
            "            a.push_back(x);",
            "        }",
            "        trim();",
            "    }",
            "    friend istream& operator>>(istream &stream, big &v) {",
            "        string s;",
            "        stream >> s;",
            "        v.read(s);",
            "        return stream;",
            "    }",
            "    friend ostream& operator<<(ostream &stream, const big &v) {",
            "        if (v.sign == -1)",
            "            stream << '-';",
            "        stream << (v.a.empty() ? 0 : v.a.back());",
            "        for (int i = (int) v.a.size() - 2; i >= 0; --i)",
            "            stream << setw(base_digits) << setfill('0') << v.a[i];",
            "        return stream;",
            "    }",
            "    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
            "        vector<long long> p(max(old_digits, new_digits) + 1);",
            "        p[0] = 1;",
            "        for (int i = 1; i < (int) p.size(); ++i)",
            "            p[i] = p[i - 1] * 10;",
            "        vector<int> res;",
            "        long long cur = 0;",
            "        int cur_digits = 0;",
            "        for (int i = 0; i < (int) a.size(); ++i) {",
            "            cur += a[i] * p[cur_digits];",
            "            cur_digits += old_digits;",
            "            while (cur_digits >= new_digits) {",
            "                res.push_back(int(cur % p[new_digits]));",
            "                cur /= p[new_digits];",
            "                cur_digits -= new_digits;",
            "            }",
            "        }",
            "        res.push_back((int) cur);",
            "        while (!res.empty() && !res.back())",
            "            res.pop_back();",
            "        return res;",
            "    }",
            "    typedef vector<long long> vll;",
            "",
            "    static vll karatsubaMultiply(const vll &a, const vll &b) {",
            "        int n = a.size();",
            "        vll res(n + n);",
            "        if (n <= 32) {",
            "            for (int i = 0; i < n; ++i)",
            "                for (int j = 0; j < n; ++j)",
            "                    res[i + j] += a[i] * b[j];",
            "            return res;",
            "        }",
            "        int k = n >> 1;",
            "        vll a1(a.begin(), a.begin() + k);",
            "        vll a2(a.begin() + k, a.end());",
            "        vll b1(b.begin(), b.begin() + k);",
            "        vll b2(b.begin() + k, b.end());",
            "",
            "        vll a1b1 = karatsubaMultiply(a1, b1);",
            "        vll a2b2 = karatsubaMultiply(a2, b2);",
            "",
            "        for (int i = 0; i < k; ++i)",
            "            a2[i] += a1[i];",
            "        for (int i = 0; i < k; ++i)",
            "            b2[i] += b1[i];",
            "",
            "        vll r = karatsubaMultiply(a2, b2);",
            "        for (int i = 0; i < (int) a1b1.size(); ++i)",
            "            r[i] -= a1b1[i];",
            "        for (int i = 0; i < (int) a2b2.size(); ++i)",
            "            r[i] -= a2b2[i];",
            "",
            "        for (int i = 0; i < (int) r.size(); ++i)",
            "            res[i + k] += r[i];",
            "        for (int i = 0; i < (int) a1b1.size(); ++i)",
            "            res[i] += a1b1[i];",
            "        for (int i = 0; i < (int) a2b2.size(); ++i)",
            "            res[i + n] += a2b2[i];",
            "        return res;",
            "    }",
            "    big operator*(const big &v) const {",
            "        vector<int> a6 = convert_base(this->a, base_digits, 6);",
            "        vector<int> b6 = convert_base(v.a, base_digits, 6);",
            "        vll a(a6.begin(), a6.end());",
            "        vll b(b6.begin(), b6.end());",
            "        while (a.size() < b.size())",
            "            a.push_back(0);",
            "        while (b.size() < a.size())",
            "            b.push_back(0);",
            "        while (a.size() & (a.size() - 1))",
            "            a.push_back(0), b.push_back(0);",
            "        vll c = karatsubaMultiply(a, b);",
            "        big res;",
            "        res.sign = sign * v.sign;",
            "        for (int i = 0, carry = 0; i < (int) c.size(); ++i) {",
            "            long long cur = c[i] + carry;",
            "            res.a.push_back((int) (cur % 1000000));",
            "            carry = (int) (cur / 1000000);",
            "        }",
            "        res.a = convert_base(res.a, 6, base_digits);",
            "        res.trim();",
            "        return res;",
            "    }",
            "};",
            "big Pow(big A, big b) {",
            "    if (b == big(0)) return 1;",
            "    if (b == big(1)) return A;",
            "    big t = 1;",
            "    while (1) {",
            "        if (b.a.back() & 1) t = t*A;",
            "        A = A*A;",
            "        b /= big(2);",
            "        if (b == big(0)) break;",
            "    }",
            "    return t;",
            "}"
        ],
        "description": "biginterger"
    },
    "ncr_modnotprime": {
        "prefix": "#ncr",
        "body": [
            "void giaithua(vector<int> &gt, vector<int> &gt_, vector<int> &d, int M, int N = 1e5+1) { // euclid()",
            "    gt.assign(N, 0); gt_.assign(N, 0); d.assign(N, 0);",
            "    gt[0] = gt_[0] = 1;",
            "    d[0] = 0;",
            "    for (int i = 1; i < N; ++i) {",
            "        int e = i; d[i] = d[i-1];",
            "        while (e%M == 0) ++d[i], e /= M; // erase if M is prime",
            "        gt[i] = gt[i-1]*e %M;",
            "        gt_[i] = euclid(gt[i], M);",
            "    }",
            "    return ;",
            "}",
            "int nCr(int n, int k, int M) { // euclid(), giaithua() first",
            "    //if (n < k || d[k] + d[n-k] < d[n])",
            "        return 0;",
            "    //return gt[n]*gt_[k] %M *gt_[n-k] %M;",
            "}"
        ],
        "description": "ncr_modnotprime"
    },
    "zfunction": {
        "prefix": "$Zfunction",
        "body": [
            "vector<int> makeZ(string s) {",
            "    int n = s.size();",
            "    vector<int> z(n);",
            "    z[0] = n;",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; ++i) {",
            "        if (i > r) {",
            "            l = r = i;",
            "            while (r < n && s[r] == s[r-l]) ++r;",
            "            z[i] = r-- - l;",
            "        } else {",
            "            int k = i-l;",
            "            if (z[k] < r-i+1) z[i] = z[k];",
            "            else {",
            "                l = i;",
            "                while (r < n && s[r] == s[r-l]) ++r;",
            "                z[i] = r-- - l;",
            "            }",
            "        }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "zfunction"
    },
    "matrix": {
      "prefix": "#matrix",
      "body": [
        "int MOD = 1e9 + 7;",
        "int LIM = MOD*MOD*7;",
        "struct Matrix {",
        "    int n, v[2][2];",
        "    Matrix() {}",
        "    Matrix(int n) : n(n) {",
        "        memset(v, 0, sizeof v);",
        "    }",
        "    Matrix(const vector<vector<int> > &tmp) {",
        "        n = tmp.size();",
        "        for (int i = 0; i < n; ++i)",
        "            for (int j = 0; j < n; ++j)",
        "                v[i][j] = tmp[i][j];",
        "    }",
        "    Matrix operator* (Matrix b) {",
        "        Matrix res(b.n);",
        "        for (int i = 0; i < b.n; ++i)",
        "            for (int j = 0; j < b.n; ++j) {",
        "                int x = 0;",
        "                for (int k = 0; k < b.n; k++) {",
        "                    x += v[i][k] * b.v[k][j];",
        "                    if (x > LIM) x -= LIM;",
        "                }",
        "                res.v[i][j] = x % MOD;",
        "            }",
        "        return res;",
        "    }",
        "    friend Matrix Pow(Matrix a, int b) {",
        "        Matrix ans(a.n);",
        "        for (int i = 0; i < a.n; ++i)",
        "            ans.v[i][i] = 1;",
        "        while (b) {",
        "            if (b & 1)",
        "            ans = ans * a;",
        "            a = a * a;",
        "            b >>= 1;",
        "        }",
        "        return ans;",
        "    }",
        "};",
        "int fibo(int n) {",
        "    if (n < 2) return n;",
        "    Matrix a({",
        "        {1, 1},",
        "        {1, 0}",
        "    });",
        "    a = Pow(a, n - 2);",
        "    return (a.v[0][0] + a.v[0][1]) % MOD;",
        "}"
      ],
      "description": "matrix"
    },
      "freopen_iosbase": {
        "prefix": "#fast",
        "body": [
          "void fast() {",
          "    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
          "    #ifndef ONLINE_JUDGE",
          "        freopen(\"ab.inp\", \"r\", stdin);",
          "        freopen(\"ab.out\", \"w\", stdout);",
          "    #endif",
          "}"
        ],
        "description": "freopen_iosbase"
      },
      "khu_gauss": {
        "prefix": "#gauss",
        "body": [
          "/*",
          "chọn tập S từ a nhiều phần tử nhất sao cho",
          "xor của mọi tập con trong S != 0",
          "*/",
          "    sort(a, a+n, [] (bitset<M> &u, bitset <M> &v) -> bool {",
          "        int pos = -1;",
          "        for (int i = M-1; i >= 0; --i)",
          "            if (u[i] != v[i]) {",
          "                pos = i;",
          "                break;",
          "            }",
          "        if (pos == -1) return 0;",
          "        return u[pos] > v[pos];",
          "    });",
          "    bitset<M> b0; b0.reset();",
          "    while (n > 0 && a[n-1] == b0) --n;",
          "    for (int i = 0; i < n; ++i) cout << a[i] << '\\n';"
        ],
        "description": "khu_gauss"
      },
      "BIT_update_range_sum": {
        "prefix": "$bit_range",
        "body": [
          "const int N = 2e5+5;",
          "int bit[2][N];",
          "void update(int pos, int val) {",
          "    for (int i = pos; i < N; i += i & -i) {",
          "        bit[0][i] += val;",
          "        bit[1][i] += val * (pos-1);",
          "    }",
          "}",
          "void update(int l, int r, int val) {",
          "    update(l, val);",
          "    update(r+1, -val);",
          "}",
          "int get(int pos) {",
          "    int res = 0;",
          "    for (int i = pos; i > 0; i -= i & -i)",
          "        res += bit[0][i] * pos - bit[1][i];",
          "    return res;",
          "}",
          "int get(int l, int r) {",
          "    return get(r) - get(l-1);",
          "}"
        ],
        "description": "BIT_update_range_sum"
      },
      "aomacanada": {
        "prefix": "#pragma",
        "body": [
          "#pragma comment(linker, \"/stack:200000000\")",
          "#pragma GCC optimize(\"Ofast,unroll-loops,tree-vectorize\")",
          "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")",
          ""
        ],
        "description": "aomacanada"
      },
      "pragma": {
        "prefix": "#pragma2",
        "body": [
          "#pragma GCC optimize(\"O3,unroll-loops\")",
          "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
        ],
        "description": "pragma"
      },
      "pragma3": {
        "prefix": "#pragma3",
        "body": [
          "#pragma GCC optimize(\"Ofast\")",
          "#pragma GCC target(\"sse3\",\"sse2\",\"sse\")",
          "#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")",
          "#pragma GCC target(\"f16c\")",
          "#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")",
          "#pragma loop_opt(on)"
        ],
        "description": "pragma3"
      },
      "nk1e18mod1e6": {
        "prefix": "#nCr_Big",
        "body": [
          "int hantindiembinh(const vector<II> &am) {",
          "    int md = 1;",
          "    for (int i = 0; i < am.size(); ++i)",
          "        md *= am[i].se;",
          "    int res = 0;",
          "    for (int i = 0; i < am.size(); ++i) {",
          "        int p = md / am[i].se, inv = euclid(p, am[i].se);",
          "        res = (res + am[i].fi * p % md * inv % md) % md;",
          "    }",
          "    return res;",
          "}",
          "vector<int> P, T;",
          "int fac[N][25];",
          "void prepare(int th) {",
          "    fac[0][th] = 1;",
          "    for (int i = 1; i < P[th]; ++i) {",
          "        fac[i][th] = fac[i-1][th] * (i % T[th] == 0 ? 1 : i) % P[th];",
          "    }",
          "}",
          "II factor(int n, int th) {",
          "    int pp = P[th], p = T[th];",
          "    II res = {Pow(fac[pp-1][th], n/pp, pp) * fac[n%pp][th] % pp, n/p};",
          "    if (n < p) return res;",
          "    II tmp = factor(n/p, th);",
          "    return {tmp.fi * res.fi % pp, tmp.se + res.se};",
          "}",
          "II nCr(int k, int n, int th) {",
          "    II N = factor(n, th);",
          "    II K = factor(k, th);",
          "    II NK = factor(n-k, th);",
          "    II ans = {N.fi * euclid(K.fi, P[th]) % P[th], N.se - K.se};",
          "    return {ans.fi * euclid(NK.fi, P[th]) % P[th], ans.se - NK.se};",
          "}",
          "int C(int k, int n) {",
          "    if (k > n || k < 0) return 0;",
          "    if (k == 0 || k == n) return 1;",
          "    if (k == 1 || k == n-1) return n;",
          "    if (k > n-k+1) return C(n-k, n);",
          "    int md = MOD; // MOD <= 1e6; n,k <= 1e18",
          "    for (int i = lpf[MOD]; MOD > 1; i = lpf[MOD]) {",
          "        P.push_back(1);",
          "        T.push_back(i);",
          "        while (MOD % i == 0) {",
          "            MOD /= i;",
          "            P.back() *= i;",
          "        }",
          "        prepare(P.size()-1);",
          "    }",
          "    vector<II> am;",
          "    for (int i = 0; i < P.size(); ++i) {",
          "        II x = nCr(k, n, i);",
          "        int p = P[i];",
          "        int val = x.fi % p * Pow(T[i], x.se, p) % p;",
          "        am.push_back({val % p, p});",
          "    }",
          "    return hantindiembinh(am);",
          "}"
        ],
        "description": "nk1e18,mod1e6"
      },
      "filenum_SINHTEST": {
        "prefix": "#filenum",
        "body": [
          "    ifstream filenum(\"filenum.txt\");",
          "    string finp = \"\", fout = \"\";",
          "    filenum >> finp >> fout;",
          "    ifstream cin(finp.c_str());",
          "    ofstream cout(fout.c_str());"
        ],
        "description": "filenum_SINHTEST"
      },
      "dsu_size": {
        "prefix": "$dsu_sz",
        "body": [
          "int par[N], sz[N];",
          "void init(int n) {",
          "    for (int i = 1; i <= n; ++i) {",
          "        par[i] = i;",
          "        sz[i] = 1;",
          "    }",
          "}",
          "int find(int u) {",
          "    if (par[u] != u) par[u] = find(par[u]);",
          "    return par[u];",
          "}",
          "void join(int u, int v) {",
          "    u = find(u);",
          "    v = find(v);",
          "    if (u != v) {",
          "        if (sz[u] < sz[v]) swap(u, v);",
          "        par[v] = u;",
          "        sz[u] += sz[v];",
          "    }",
          "}"
        ],
        "description": "dsu_size"
      },
      "dsu_roollback": {
        "prefix": "$dsu_roollback",
        "body": [
          "int par[N], rak[N];",
          "int *t[N*40], v[N*40], cur;",
          "int setv(int *a, int b) {",
          "    if (*a != b) t[cur] = a, v[cur] = *a, *a = b, ++cur;",
          "    return b;",
          "}",
          "void rollback(int x) {",
          "    for (; cur > x; ) --cur, *t[cur] = v[cur];",
          "}",
          "int find(int n) {",
          "    return par[n] ? find(par[n]) : n;",
          "}",
          "bool join(int a, int b) {",
          "    a = find(a), b = find(b);",
          "    if (a == b) return 0;",
          "    if (rak[b] > rak[a]) swap(a, b);",
          "    if (rak[a] == rak[b]) setv(rak + a, rak[a] + 1);",
          "    return setv(par + b, a), 1;",
          "}",
          ""
        ],
        "description": "dsu_roollback"
      },
      "Disjoint set union": {
        "prefix": "$DSU_struct",
        "body": [
          "struct DSU {",
          "    int pa[nax], rak[nax];",
          "    DSU(int n) {",
          "        for (int i = 0; i <= n; ++i) {",
          "            pa[i] = i;",
          "            rak[i] = 0;",
          "        }",
          "    }",
          "    int find(int u) {",
          "        return pa[u] = ((u != pa[u]) ? find(pa[u]) : pa[u]);",
          "    }",
          "    void join(int u, int v) {",
          "        u = find(u), v = find(v);",
          "        if (u == v) return;",
          "        if (rak[v] > rak[u])",
          "            swap(u, v);",
          "        pa[v] = u;",
          "        if (rak[u] == rak[v]) ++rak[u];",
          "    }",
          "};"
        ],
        "description": "Disjoint set union"
      },
      "Disjoint Set Union": {
        "prefix": "$dsu_rank",
        "body": [
          "const int N = 1e5+5;",
          "int par[N], rak[N];",
          "void init(int n) {",
          "    for (int i = 1; i <= n; ++i) {",
          "        par[i] = i;",
          "        rak[i] = 0;",
          "    }",
          "}",
          "int find(int u) {",
          "    if (par[u] != u) par[u] = find(par[u]);",
          "    return par[u];",
          "}",
          "bool join(int u, int v) {",
          "    u = find(u);",
          "    v = find(v);",
          "    if (u == v) return 0;",
          "    if (rak[u] == rak[v]) ++rak[u];",
          "    if (rak[u] < rak[v]) par[u] = v;",
          "    else par[v] = u;",
          "    return 1;",
          "}"
        ],
        "description": "Disjoint Set Union"
      },
      "trie_array": {
        "prefix": "$trie_array",
        "body": [
          "int child[N][26], sz;",
          "int cnt[N], iend[N];",
          "void addstr(const string &s) {",
          "    int cur = 0;",
          "    for (int i = 0; i < s.size(); ++i) {",
          "        int &nxt = child[cur][s[i] - 'a'];",
          "        if (!nxt) nxt = ++sz;",
          "        cur = nxt;",
          "        ++cnt[cur];",
          "    }",
          "    ++iend[cur];",
          "}",
          "int search(const string &s) {",
          "    int cur = 0;",
          "    for (int i = 0; i < s.size(); ++i) {",
          "        int &nxt = child[cur][s[i] - 'a'];",
          "        if (!nxt) return 0;",
          "        cur = nxt;",
          "    }",
          "    return cur;",
          "}",
          "void remove(const stirng &s) {",
          "    if (!search(s)) return;",
          "    int cur = 0;",
          "    for (int i = 0; i < s.size(); ++i) {",
          "        int &nxt = child[cur][s[i] - 'a'];",
          "        cur = nxt;",
          "        --cnt[cur];",
          "    }",
          "    --iend[cur];",
          "}"
        ],
        "description": "trie_array"
      },
      "trie": {
        "prefix": "$trie",
        "body": [
          "struct TrieNode {",
          "    TrieNode *child[26];",
          "    int cnt;",
          "    TrieNode() {",
          "        for (int i = 0; i < 26; ++i)",
          "            child[i] = NULL;",
          "        cnt = 0;",
          "    }",
          "};",
          "void TrieInsert(struct TrieNode *root, const string &s) {",
          "    int n = s.size();",
          "    struct TrieNode *p = root;",
          "    for (int i = 0; i < n; ++i) {",
          "        int nxt = s[i] - 'a';",
          "        if (p -> child[nxt] == NULL)",
          "            p -> child[nxt] = new TrieNode();",
          "        p = p -> child[nxt];",
          "    }",
          "    ++p -> cnt;",
          "}",
          "bool TrieFind(struct TrieNode *root, const string &s) {",
          "    int n = s.size();",
          "    struct TrieNode *p = root;",
          "    for (int i = 0; i < n; ++i) {",
          "        int nxt = s[i] - 'a';",
          "        if (p -> child[nxt] == NULL)",
          "            return 0;",
          "        p = p -> child[nxt];",
          "    }",
          "    return p -> cnt > 0;",
          "}"
        ],
        "description": "trie"
      },
      "Trie": {
        "prefix": "$Trie_remove",
        "body": [
          "const int SIZE = 27;",
          "struct TrieNode {",
          "    TrieNode *child[SIZE];",
          "    int count = 0;",
          "    bool EndOfWord = 0;",
          "    TrieNode() {",
          "        EndOfWord = 0;",
          "        count = 0;",
          "        for (int i = 0; i < SIZE; ++i) child[i] = NULL;",
          "    }",
          "};",
          "void addString(TrieNode *root, const string &s) {",
          "    TrieNode *curr = root;",
          "    for (int i = 0; i < s.size(); ++i) {",
          "        int id = s[i];",
          "        if (curr -> child[id] == NULL) curr -> child[id] = new TrieNode();",
          "        curr = curr -> child[id];",
          "        curr -> count += 1;",
          "        ans = max(ans, (i + 1) * curr -> count);",
          "    }",
          "    curr -> EndOfWord = 1;",
          "}",
          "int searchString(TrieNode *root , const string &s) {",
          "    TrieNode *curr = root;",
          "    for (int i = 0; i < s.size(); ++i) {",
          "        int id = s[i];",
          "        if (curr -> child[id] == NULL) return 0;",
          "        curr = curr -> child[id];",
          "    }",
          "    return curr -> count;",
          "}",
          "bool isEmpty(TrieNode *root) {",
          "    for (int i = 0; i < SIZE; ++i)",
          "        if (root -> child[i])",
          "            return 0;",
          "    return 1;",
          "}",
          "TrieNode *remove(TrieNode *root, string key, int depth = 0) {",
          "    if (!root) return NULL;",
          "    if (depth == key.size()) {",
          "        if (root -> count) root -> count--;",
          "        if (root -> count == 0) root -> EndOfWord = 0;",
          "        if (isEmpty(root)) {",
          "            delete(root);",
          "            root = NULL;",
          "        }",
          "        return root;",
          "    }",
          "    int index = key[depth];",
          "    root -> child[index] = remove(root -> child[index], key, depth + 1);",
          "    if (isEmpty(root) && root -> EndOfWord == 0) {",
          "        delete(root);",
          "        root = NULL;",
          "    }",
          "    return root;",
          "}",
          "    TrieNode *root = new TrieNode();",
          "        addString(root, s);"
        ],
        "description": "Trie"
      },
      "unordered_map_custom": {
        "prefix": "#unordered_map_custom",
        "body": [
          "struct custom_hash {",
          "    static uint64_t splitmix64(uint64_t x) {",
          "        x += 0x9e3779b97f4a7c15;",
          "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
          "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
          "        return x ^ (x >> 31);",
          "    }",
          "",
          "    size_t operator()(uint64_t x) const {",
          "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
          "        return splitmix64(x + FIXED_RANDOM);",
          "    }",
          "};",
          "unordered_map<int, int, custom_hash> cnt;"
        ],
        "description": "unordered_map_custom"
      }
}